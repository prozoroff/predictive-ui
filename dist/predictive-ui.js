/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./constants.js":
/*!**********************!*\
  !*** ./constants.js ***!
  \**********************/
/*! exports provided: particlesNumber, distributionSize, predictionFactor, predictiveAttribute, hoverClass, predictiveTimeout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"particlesNumber\", function() { return particlesNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distributionSize\", function() { return distributionSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"predictionFactor\", function() { return predictionFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"predictiveAttribute\", function() { return predictiveAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hoverClass\", function() { return hoverClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"predictiveTimeout\", function() { return predictiveTimeout; });\nconst particlesNumber = 50;\r\nconst distributionSize = 10;\r\nconst predictionFactor = 10;\r\nconst predictiveAttribute = 'predictive-item';\r\nconst hoverClass = 'predictive-item-hover';\r\nconst predictiveTimeout = 1000;\n\n//# sourceURL=webpack:///./constants.js?");

/***/ }),

/***/ "./filters.js":
/*!********************!*\
  !*** ./filters.js ***!
  \********************/
/*! exports provided: getParticleFilter, getMovingAverageFilter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getParticleFilter\", function() { return getParticleFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMovingAverageFilter\", function() { return getMovingAverageFilter; });\n/* harmony import */ var particle_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! particle-filter */ \"./node_modules/particle-filter/lib/index.js\");\n/* harmony import */ var particle_filter__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(particle_filter__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"./constants.js\");\n\r\n\r\n\r\n\r\n\r\nconst getParticleFilter = () => {\r\n\tconst variablesNumber = 2, //x,y\r\n\t\tfilter = new particle_filter__WEBPACK_IMPORTED_MODULE_0___default.a(_constants__WEBPACK_IMPORTED_MODULE_1__[\"particlesNumber\"], variablesNumber, _constants__WEBPACK_IMPORTED_MODULE_1__[\"distributionSize\"]);\r\n\r\n\treturn {\r\n\t\tupdate: coords => filter.update(coords),\r\n\t\tstate: () => filter.result.state \r\n\t}\r\n}\r\n\r\nconst getMovingAverageFilter = () => {\r\n\tconst depth = 5,\r\n\t\thistory = [],\r\n\t\taverage = arr => {\r\n\t\t\tconst sum = arr.reduce(function(a, b) { return a + b; });\r\n    \t\treturn sum / arr.length;\r\n\t\t}\r\n\r\n\treturn {\r\n\t\tupdate: coords => {\r\n\t\t\tif(history.length === 5){\r\n\t\t\t\thistory.shift();\r\n\t\t\t}\r\n\t\t\thistory.push(coords);\r\n\t\t},\r\n\t\tstate: () => [\r\n\t\t\taverage(history.map(h => h[0])),\r\n\t\t\taverage(history.map(h => h[1]))\r\n\t\t]\r\n\t}\r\n}\n\n//# sourceURL=webpack:///./filters.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _filters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filters */ \"./filters.js\");\n/* harmony import */ var _styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles */ \"./styles.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ \"./constants.js\");\n/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mouse */ \"./mouse.js\");\n/* harmony import */ var _predictor_predictAction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./predictor/predictAction */ \"./predictor/predictAction.js\");\n\r\n\r\n\r\n\r\n\r\n\t\r\n\r\nObject(_styles__WEBPACK_IMPORTED_MODULE_1__[\"addPredictiveHoverRules\"])();\r\n\r\nconst filter = Object(_filters__WEBPACK_IMPORTED_MODULE_0__[\"getParticleFilter\"])();\r\nconst elements = document.querySelectorAll(`[${_constants__WEBPACK_IMPORTED_MODULE_2__[\"predictiveAttribute\"]}]`);;\r\n\r\ndocument.body.onmousemove = Object(_mouse__WEBPACK_IMPORTED_MODULE_3__[\"getMouseHandler\"])(filter, elements, /*predictAction*/);\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./mouse.js":
/*!******************!*\
  !*** ./mouse.js ***!
  \******************/
/*! exports provided: getMouseHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMouseHandler\", function() { return getMouseHandler; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./constants.js\");\n/* harmony import */ var _styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles */ \"./styles.js\");\n\r\n\r\n\r\n//11 last positions = 10 last differences\r\nconst positionsFull = mousePositions => mousePositions.length === 11;\r\n\r\nconst isIn = (x,y,coordinates) => \r\n\tx > coordinates.x && \r\n\tx < (coordinates.x + coordinates.width) && \r\n\ty > coordinates.y && \r\n\ty < (coordinates.y + coordinates.height);\r\n\r\nconst getMouseHandler = (filter, elements, predict) => {\r\n\t\r\n\tconst coordinatesCheckers = [];\r\n\tfor(let i = 0, l = elements.length; i < l; i++){\r\n\t\tconst element = elements[i],\r\n\t\t\trect = element.getBoundingClientRect();\r\n\r\n\t\tcoordinatesCheckers.push((x,y) => isIn(x,y,rect));\r\n\t}\r\n\r\n  const timeoutIds = new Array(elements.length);\r\n\r\n\tlet globalX, \r\n\t\tglobalY,\r\n    mousePositions = [];\r\n\r\n\treturn e => {\r\n\r\n    \tlet x, y;\r\n\r\n    \tif (document.all)  { \r\n      \t\tx = event.x + document.body.scrollLeft; \r\n      \t\ty = event.y + document.body.scrollTop; \r\n    \t} else {\r\n      \t\tx = e.pageX;\r\n      \t\ty = e.pageY;\r\n    \t}\r\n\r\n    \tglobalX = globalX || x;\r\n    \tglobalY = globalY || y;\r\n\r\n    \tfilter.update([(x - globalX)*_constants__WEBPACK_IMPORTED_MODULE_0__[\"predictionFactor\"], (y - globalY)*_constants__WEBPACK_IMPORTED_MODULE_0__[\"predictionFactor\"]]);\r\n\r\n\t\tconst filterState = filter.state(),\r\n\t\t\tpredictX = globalX + filterState[0],\r\n\t\t\tpredictY = globalY + filterState[1];\r\n\r\n      if(!predict || !positionsFull(mousePositions) || predict(mousePositions)){\r\n        for(let i = 0, l = coordinatesCheckers.length; i < l; i++){\r\n          if(coordinatesCheckers[i](predictX, predictY)){\r\n            const element = elements[i];\r\n            if(!timeoutIds[i]){\r\n              Object(_styles__WEBPACK_IMPORTED_MODULE_1__[\"addHoverClass\"])(element);\r\n              timeoutIds[i] = setTimeout(() => {\r\n                Object(_styles__WEBPACK_IMPORTED_MODULE_1__[\"removeHoverClass\"])(element);\r\n                delete timeoutIds[i];\r\n              }, _constants__WEBPACK_IMPORTED_MODULE_0__[\"predictiveTimeout\"]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n    \tglobalX = x;\r\n    \tglobalY = y;\r\n\r\n      if(predict){\r\n        positionsFull(mousePositions) && mousePositions.shift();\r\n        mousePositions.push([x,y]);\r\n      }\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./mouse.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/architecture/architect.js":
/*!**************************************************************!*\
  !*** ./node_modules/neataptic/src/architecture/architect.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Import */\r\nvar methods = __webpack_require__(/*! ../methods/methods */ \"./node_modules/neataptic/src/methods/methods.js\");\r\nvar Network = __webpack_require__(/*! ./network */ \"./node_modules/neataptic/src/architecture/network.js\");\r\nvar Group = __webpack_require__(/*! ./group */ \"./node_modules/neataptic/src/architecture/group.js\");\r\nvar Layer = __webpack_require__(/*! ./layer */ \"./node_modules/neataptic/src/architecture/layer.js\");\r\nvar Node = __webpack_require__(/*! ./node */ \"./node_modules/neataptic/src/architecture/node.js\");\r\n\r\n/*******************************************************************************\r\n                                        architect\r\n*******************************************************************************/\r\n\r\nvar architect = {\r\n  /**\r\n   * Constructs a network from a given array of connected nodes\r\n   */\r\n  Construct: function (list) {\r\n    // Create a network\r\n    var network = new Network(0, 0);\r\n\r\n    // Transform all groups into nodes\r\n    var nodes = [];\r\n\r\n    var i;\r\n    for (i = 0; i < list.length; i++) {\r\n      let j;\r\n      if (list[i] instanceof Group) {\r\n        for (j = 0; j < list[i].nodes.length; j++) {\r\n          nodes.push(list[i].nodes[j]);\r\n        }\r\n      } else if (list[i] instanceof Layer) {\r\n        for (j = 0; j < list[i].nodes.length; j++) {\r\n          for (var k = 0; k < list[i].nodes[j].nodes.length; k++) {\r\n            nodes.push(list[i].nodes[j].nodes[k]);\r\n          }\r\n        }\r\n      } else if (list[i] instanceof Node) {\r\n        nodes.push(list[i]);\r\n      }\r\n    }\r\n\r\n    // Determine input and output nodes\r\n    var inputs = [];\r\n    var outputs = [];\r\n    for (i = nodes.length - 1; i >= 0; i--) {\r\n      if (nodes[i].type === 'output' || nodes[i].connections.out.length + nodes[i].connections.gated.length === 0) {\r\n        nodes[i].type = 'output';\r\n        network.output++;\r\n        outputs.push(nodes[i]);\r\n        nodes.splice(i, 1);\r\n      } else if (nodes[i].type === 'input' || !nodes[i].connections.in.length) {\r\n        nodes[i].type = 'input';\r\n        network.input++;\r\n        inputs.push(nodes[i]);\r\n        nodes.splice(i, 1);\r\n      }\r\n    }\r\n\r\n    // Input nodes are always first, output nodes are always last\r\n    nodes = inputs.concat(nodes).concat(outputs);\r\n\r\n    if (network.input === 0 || network.output === 0) {\r\n      throw new Error('Given nodes have no clear input/output node!');\r\n    }\r\n\r\n    for (i = 0; i < nodes.length; i++) {\r\n      let j;\r\n      for (j = 0; j < nodes[i].connections.out.length; j++) {\r\n        network.connections.push(nodes[i].connections.out[j]);\r\n      }\r\n      for (j = 0; j < nodes[i].connections.gated.length; j++) {\r\n        network.gates.push(nodes[i].connections.gated[j]);\r\n      }\r\n      if (nodes[i].connections.self.weight !== 0) {\r\n        network.selfconns.push(nodes[i].connections.self);\r\n      }\r\n    }\r\n\r\n    network.nodes = nodes;\r\n\r\n    return network;\r\n  },\r\n\r\n  /**\r\n   * Creates a multilayer perceptron (MLP)\r\n   */\r\n  Perceptron: function () {\r\n    // Convert arguments to Array\r\n    var layers = Array.prototype.slice.call(arguments);\r\n    if (layers.length < 3) {\r\n      throw new Error('You have to specify at least 3 layers');\r\n    }\r\n\r\n    // Create a list of nodes/groups\r\n    var nodes = [];\r\n    nodes.push(new Group(layers[0]));\r\n\r\n    for (var i = 1; i < layers.length; i++) {\r\n      var layer = layers[i];\r\n      layer = new Group(layer);\r\n      nodes.push(layer);\r\n      nodes[i - 1].connect(nodes[i], methods.connection.ALL_TO_ALL);\r\n    }\r\n\r\n    // Construct the network\r\n    return architect.Construct(nodes);\r\n  },\r\n\r\n  /**\r\n   * Creates a randomly connected network\r\n   */\r\n  Random: function (input, hidden, output, options) {\r\n    options = options || {};\r\n\r\n    var connections = options.connections || hidden * 2;\r\n    var backconnections = options.backconnections || 0;\r\n    var selfconnections = options.selfconnections || 0;\r\n    var gates = options.gates || 0;\r\n\r\n    var network = new Network(input, output);\r\n\r\n    var i;\r\n    for (i = 0; i < hidden; i++) {\r\n      network.mutate(methods.mutation.ADD_NODE);\r\n    }\r\n\r\n    for (i = 0; i < connections - hidden; i++) {\r\n      network.mutate(methods.mutation.ADD_CONN);\r\n    }\r\n\r\n    for (i = 0; i < backconnections; i++) {\r\n      network.mutate(methods.mutation.ADD_BACK_CONN);\r\n    }\r\n\r\n    for (i = 0; i < selfconnections; i++) {\r\n      network.mutate(methods.mutation.ADD_SELF_CONN);\r\n    }\r\n\r\n    for (i = 0; i < gates; i++) {\r\n      network.mutate(methods.mutation.ADD_GATE);\r\n    }\r\n\r\n    return network;\r\n  },\r\n\r\n  /**\r\n   * Creates a long short-term memory network\r\n   */\r\n  LSTM: function () {\r\n    var args = Array.prototype.slice.call(arguments);\r\n    if (args.length < 3) {\r\n      throw new Error('You have to specify at least 3 layers');\r\n    }\r\n\r\n    var last = args.pop();\r\n\r\n    var outputLayer;\r\n    if (typeof last === 'number') {\r\n      outputLayer = new Group(last);\r\n      last = {};\r\n    } else {\r\n      outputLayer = new Group(args.pop()); // last argument\r\n    }\r\n\r\n    outputLayer.set({\r\n      type: 'output'\r\n    });\r\n\r\n    var options = {};\r\n    options.memoryToMemory = last.memoryToMemory || false;\r\n    options.outputToMemory = last.outputToMemory || false;\r\n    options.outputToGates = last.outputToGates || false;\r\n    options.inputToOutput = last.inputToOutput === undefined ? true : last.inputToOutput;\r\n    options.inputToDeep = last.inputToDeep === undefined ? true : last.inputToDeep;\r\n\r\n    var inputLayer = new Group(args.shift()); // first argument\r\n    inputLayer.set({\r\n      type: 'input'\r\n    });\r\n\r\n    var blocks = args; // all the arguments in the middle\r\n\r\n    var nodes = [];\r\n    nodes.push(inputLayer);\r\n\r\n    var previous = inputLayer;\r\n    for (var i = 0; i < blocks.length; i++) {\r\n      var block = blocks[i];\r\n\r\n      // Init required nodes (in activation order)\r\n      var inputGate = new Group(block);\r\n      var forgetGate = new Group(block);\r\n      var memoryCell = new Group(block);\r\n      var outputGate = new Group(block);\r\n      var outputBlock = i === blocks.length - 1 ? outputLayer : new Group(block);\r\n\r\n      inputGate.set({\r\n        bias: 1\r\n      });\r\n      forgetGate.set({\r\n        bias: 1\r\n      });\r\n      outputGate.set({\r\n        bias: 1\r\n      });\r\n\r\n      // Connect the input with all the nodes\r\n      var input = previous.connect(memoryCell, methods.connection.ALL_TO_ALL);\r\n      previous.connect(inputGate, methods.connection.ALL_TO_ALL);\r\n      previous.connect(outputGate, methods.connection.ALL_TO_ALL);\r\n      previous.connect(forgetGate, methods.connection.ALL_TO_ALL);\r\n\r\n      // Set up internal connections\r\n      memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL);\r\n      memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL);\r\n      memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL);\r\n      var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE);\r\n      var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL);\r\n\r\n      // Set up gates\r\n      inputGate.gate(input, methods.gating.INPUT);\r\n      forgetGate.gate(forget, methods.gating.SELF);\r\n      outputGate.gate(output, methods.gating.OUTPUT);\r\n\r\n      // Input to all memory cells\r\n      if (options.inputToDeep && i > 0) {\r\n        let input = inputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL);\r\n        inputGate.gate(input, methods.gating.INPUT);\r\n      }\r\n\r\n      // Optional connections\r\n      if (options.memoryToMemory) {\r\n        let input = memoryCell.connect(memoryCell, methods.connection.ALL_TO_ELSE);\r\n        inputGate.gate(input, methods.gating.INPUT);\r\n      }\r\n\r\n      if (options.outputToMemory) {\r\n        let input = outputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL);\r\n        inputGate.gate(input, methods.gating.INPUT);\r\n      }\r\n\r\n      if (options.outputToGates) {\r\n        outputLayer.connect(inputGate, methods.connection.ALL_TO_ALL);\r\n        outputLayer.connect(forgetGate, methods.connection.ALL_TO_ALL);\r\n        outputLayer.connect(outputGate, methods.connection.ALL_TO_ALL);\r\n      }\r\n\r\n      // Add to array\r\n      nodes.push(inputGate);\r\n      nodes.push(forgetGate);\r\n      nodes.push(memoryCell);\r\n      nodes.push(outputGate);\r\n      if (i !== blocks.length - 1) nodes.push(outputBlock);\r\n\r\n      previous = outputBlock;\r\n    }\r\n\r\n    // input to output direct connection\r\n    if (options.inputToOutput) {\r\n      inputLayer.connect(outputLayer, methods.connection.ALL_TO_ALL);\r\n    }\r\n\r\n    nodes.push(outputLayer);\r\n    return architect.Construct(nodes);\r\n  },\r\n\r\n  /**\r\n   * Creates a gated recurrent unit network\r\n   */\r\n  GRU: function () {\r\n    var args = Array.prototype.slice.call(arguments);\r\n    if (args.length < 3) {\r\n      throw new Error('not enough layers (minimum 3) !!');\r\n    }\r\n\r\n    var inputLayer = new Group(args.shift()); // first argument\r\n    var outputLayer = new Group(args.pop()); // last argument\r\n    var blocks = args; // all the arguments in the middle\r\n\r\n    var nodes = [];\r\n    nodes.push(inputLayer);\r\n\r\n    var previous = inputLayer;\r\n    for (var i = 0; i < blocks.length; i++) {\r\n      var layer = new Layer.GRU(blocks[i]);\r\n      previous.connect(layer);\r\n      previous = layer;\r\n\r\n      nodes.push(layer);\r\n    }\r\n\r\n    previous.connect(outputLayer);\r\n    nodes.push(outputLayer);\r\n\r\n    return architect.Construct(nodes);\r\n  },\r\n\r\n  /**\r\n   * Creates a hopfield network of the given size\r\n   */\r\n  Hopfield: function (size) {\r\n    var input = new Group(size);\r\n    var output = new Group(size);\r\n\r\n    input.connect(output, methods.connection.ALL_TO_ALL);\r\n\r\n    input.set({\r\n      type: 'input'\r\n    });\r\n    output.set({\r\n      squash: methods.activation.STEP,\r\n      type: 'output'\r\n    });\r\n\r\n    var network = new architect.Construct([input, output]);\r\n\r\n    return network;\r\n  },\r\n\r\n  /**\r\n   * Creates a NARX network (remember previous inputs/outputs)\r\n   */\r\n  NARX: function (inputSize, hiddenLayers, outputSize, previousInput, previousOutput) {\r\n    if (!Array.isArray(hiddenLayers)) {\r\n      hiddenLayers = [hiddenLayers];\r\n    }\r\n\r\n    var nodes = [];\r\n\r\n    var input = new Layer.Dense(inputSize);\r\n    var inputMemory = new Layer.Memory(inputSize, previousInput);\r\n    var hidden = [];\r\n    var output = new Layer.Dense(outputSize);\r\n    var outputMemory = new Layer.Memory(outputSize, previousOutput);\r\n\r\n    nodes.push(input);\r\n    nodes.push(outputMemory);\r\n\r\n    for (var i = 0; i < hiddenLayers.length; i++) {\r\n      var hiddenLayer = new Layer.Dense(hiddenLayers[i]);\r\n      hidden.push(hiddenLayer);\r\n      nodes.push(hiddenLayer);\r\n      if (typeof hidden[i - 1] !== 'undefined') {\r\n        hidden[i - 1].connect(hiddenLayer, methods.connection.ALL_TO_ALL);\r\n      }\r\n    }\r\n\r\n    nodes.push(inputMemory);\r\n    nodes.push(output);\r\n\r\n    input.connect(hidden[0], methods.connection.ALL_TO_ALL);\r\n    input.connect(inputMemory, methods.connection.ONE_TO_ONE, 1);\r\n    inputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);\r\n    hidden[hidden.length - 1].connect(output, methods.connection.ALL_TO_ALL);\r\n    output.connect(outputMemory, methods.connection.ONE_TO_ONE, 1);\r\n    outputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);\r\n\r\n    input.set({\r\n      type: 'input'\r\n    });\r\n    output.set({\r\n      type: 'output'\r\n    });\r\n\r\n    return architect.Construct(nodes);\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = architect;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/architecture/architect.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/architecture/connection.js":
/*!***************************************************************!*\
  !*** ./node_modules/neataptic/src/architecture/connection.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* Export */\r\nmodule.exports = Connection;\r\n\r\n/*******************************************************************************\r\n                                      CONNECTION\r\n*******************************************************************************/\r\n\r\nfunction Connection (from, to, weight) {\r\n  this.from = from;\r\n  this.to = to;\r\n  this.gain = 1;\r\n\r\n  this.weight = (typeof weight === 'undefined') ? Math.random() * 0.2 - 0.1 : weight;\r\n\r\n  this.gater = null;\r\n  this.elegibility = 0;\r\n\r\n  // For tracking momentum\r\n  this.previousDeltaWeight = 0;\r\n\r\n  // Batch training\r\n  this.totalDeltaWeight = 0;\r\n\r\n  this.xtrace = {\r\n    nodes: [],\r\n    values: []\r\n  };\r\n}\r\n\r\nConnection.prototype = {\r\n  /**\r\n   * Converts the connection to a json object\r\n   */\r\n  toJSON: function () {\r\n    var json = {\r\n      weight: this.weight\r\n    };\r\n\r\n    return json;\r\n  }\r\n};\r\n\r\n/**\r\n * Returns an innovation ID\r\n * https://en.wikipedia.org/wiki/Pairing_function (Cantor pairing function)\r\n */\r\nConnection.innovationID = function (a, b) {\r\n  return 1 / 2 * (a + b) * (a + b + 1) + b;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/architecture/connection.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/architecture/group.js":
/*!**********************************************************!*\
  !*** ./node_modules/neataptic/src/architecture/group.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\r\nmodule.exports = Group;\r\n\r\n/* Import */\r\nvar methods = __webpack_require__(/*! ../methods/methods */ \"./node_modules/neataptic/src/methods/methods.js\");\r\nvar config = __webpack_require__(/*! ../config */ \"./node_modules/neataptic/src/config.js\");\r\nvar Layer = __webpack_require__(/*! ./layer */ \"./node_modules/neataptic/src/architecture/layer.js\");\r\nvar Node = __webpack_require__(/*! ./node */ \"./node_modules/neataptic/src/architecture/node.js\");\r\n\r\n/*******************************************************************************\r\n                                         Group\r\n*******************************************************************************/\r\n\r\nfunction Group (size) {\r\n  this.nodes = [];\r\n  this.connections = {\r\n    in: [],\r\n    out: [],\r\n    self: []\r\n  };\r\n\r\n  for (var i = 0; i < size; i++) {\r\n    this.nodes.push(new Node());\r\n  }\r\n}\r\n\r\nGroup.prototype = {\r\n  /**\r\n   * Activates all the nodes in the group\r\n   */\r\n  activate: function (value) {\r\n    var values = [];\r\n\r\n    if (typeof value !== 'undefined' && value.length !== this.nodes.length) {\r\n      throw new Error('Array with values should be same as the amount of nodes!');\r\n    }\r\n\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      var activation;\r\n      if (typeof value === 'undefined') {\r\n        activation = this.nodes[i].activate();\r\n      } else {\r\n        activation = this.nodes[i].activate(value[i]);\r\n      }\r\n\r\n      values.push(activation);\r\n    }\r\n\r\n    return values;\r\n  },\r\n\r\n  /**\r\n   * Propagates all the node in the group\r\n   */\r\n  propagate: function (rate, momentum, target) {\r\n    if (typeof target !== 'undefined' && target.length !== this.nodes.length) {\r\n      throw new Error('Array with values should be same as the amount of nodes!');\r\n    }\r\n\r\n    for (var i = this.nodes.length - 1; i >= 0; i--) {\r\n      if (typeof target === 'undefined') {\r\n        this.nodes[i].propagate(rate, momentum, true);\r\n      } else {\r\n        this.nodes[i].propagate(rate, momentum, true, target[i]);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Connects the nodes in this group to nodes in another group or just a node\r\n   */\r\n  connect: function (target, method, weight) {\r\n    var connections = [];\r\n    var i, j;\r\n    if (target instanceof Group) {\r\n      if (typeof method === 'undefined') {\r\n        if (this !== target) {\r\n          if (config.warnings) console.warn('No group connection specified, using ALL_TO_ALL');\r\n          method = methods.connection.ALL_TO_ALL;\r\n        } else {\r\n          if (config.warnings) console.warn('No group connection specified, using ONE_TO_ONE');\r\n          method = methods.connection.ONE_TO_ONE;\r\n        }\r\n      }\r\n      if (method === methods.connection.ALL_TO_ALL || method === methods.connection.ALL_TO_ELSE) {\r\n        for (i = 0; i < this.nodes.length; i++) {\r\n          for (j = 0; j < target.nodes.length; j++) {\r\n            if (method === methods.connection.ALL_TO_ELSE && this.nodes[i] === target.nodes[j]) continue;\r\n            let connection = this.nodes[i].connect(target.nodes[j], weight);\r\n            this.connections.out.push(connection[0]);\r\n            target.connections.in.push(connection[0]);\r\n            connections.push(connection[0]);\r\n          }\r\n        }\r\n      } else if (method === methods.connection.ONE_TO_ONE) {\r\n        if (this.nodes.length !== target.nodes.length) {\r\n          throw new Error('From and To group must be the same size!');\r\n        }\r\n\r\n        for (i = 0; i < this.nodes.length; i++) {\r\n          let connection = this.nodes[i].connect(target.nodes[i], weight);\r\n          this.connections.self.push(connection[0]);\r\n          connections.push(connection[0]);\r\n        }\r\n      }\r\n    } else if (target instanceof Layer) {\r\n      connections = target.input(this, method, weight);\r\n    } else if (target instanceof Node) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        let connection = this.nodes[i].connect(target, weight);\r\n        this.connections.out.push(connection[0]);\r\n        connections.push(connection[0]);\r\n      }\r\n    }\r\n\r\n    return connections;\r\n  },\r\n\r\n  /**\r\n   * Make nodes from this group gate the given connection(s)\r\n   */\r\n  gate: function (connections, method) {\r\n    if (typeof method === 'undefined') {\r\n      throw new Error('Please specify Gating.INPUT, Gating.OUTPUT');\r\n    }\r\n\r\n    if (!Array.isArray(connections)) {\r\n      connections = [connections];\r\n    }\r\n\r\n    var nodes1 = [];\r\n    var nodes2 = [];\r\n\r\n    var i, j;\r\n    for (i = 0; i < connections.length; i++) {\r\n      var connection = connections[i];\r\n      if (!nodes1.includes(connection.from)) nodes1.push(connection.from);\r\n      if (!nodes2.includes(connection.to)) nodes2.push(connection.to);\r\n    }\r\n\r\n    switch (method) {\r\n      case methods.gating.INPUT:\r\n        for (i = 0; i < nodes2.length; i++) {\r\n          let node = nodes2[i];\r\n          let gater = this.nodes[i % this.nodes.length];\r\n\r\n          for (j = 0; j < node.connections.in.length; j++) {\r\n            let conn = node.connections.in[j];\r\n            if (connections.includes(conn)) {\r\n              gater.gate(conn);\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      case methods.gating.OUTPUT:\r\n        for (i = 0; i < nodes1.length; i++) {\r\n          let node = nodes1[i];\r\n          let gater = this.nodes[i % this.nodes.length];\r\n\r\n          for (j = 0; j < node.connections.out.length; j++) {\r\n            let conn = node.connections.out[j];\r\n            if (connections.includes(conn)) {\r\n              gater.gate(conn);\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      case methods.gating.SELF:\r\n        for (i = 0; i < nodes1.length; i++) {\r\n          let node = nodes1[i];\r\n          let gater = this.nodes[i % this.nodes.length];\r\n\r\n          if (connections.includes(node.connections.self)) {\r\n            gater.gate(node.connections.self);\r\n          }\r\n        }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sets the value of a property for every node\r\n   */\r\n  set: function (values) {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      if (typeof values.bias !== 'undefined') {\r\n        this.nodes[i].bias = values.bias;\r\n      }\r\n\r\n      this.nodes[i].squash = values.squash || this.nodes[i].squash;\r\n      this.nodes[i].type = values.type || this.nodes[i].type;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Disconnects all nodes from this group from another given group/node\r\n   */\r\n  disconnect: function (target, twosided) {\r\n    twosided = twosided || false;\r\n\r\n    // In the future, disconnect will return a connection so indexOf can be used\r\n    var i, j, k;\r\n    if (target instanceof Group) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        for (j = 0; j < target.nodes.length; j++) {\r\n          this.nodes[i].disconnect(target.nodes[j], twosided);\r\n\r\n          for (k = this.connections.out.length - 1; k >= 0; k--) {\r\n            let conn = this.connections.out[k];\r\n\r\n            if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {\r\n              this.connections.out.splice(k, 1);\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (twosided) {\r\n            for (k = this.connections.in.length - 1; k >= 0; k--) {\r\n              let conn = this.connections.in[k];\r\n\r\n              if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {\r\n                this.connections.in.splice(k, 1);\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else if (target instanceof Node) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        this.nodes[i].disconnect(target, twosided);\r\n\r\n        for (j = this.connections.out.length - 1; j >= 0; j--) {\r\n          let conn = this.connections.out[j];\r\n\r\n          if (conn.from === this.nodes[i] && conn.to === target) {\r\n            this.connections.out.splice(j, 1);\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (twosided) {\r\n          for (j = this.connections.in.length - 1; j >= 0; j--) {\r\n            var conn = this.connections.in[j];\r\n\r\n            if (conn.from === target && conn.to === this.nodes[i]) {\r\n              this.connections.in.splice(j, 1);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Clear the context of this group\r\n   */\r\n  clear: function () {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].clear();\r\n    }\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/architecture/group.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/architecture/layer.js":
/*!**********************************************************!*\
  !*** ./node_modules/neataptic/src/architecture/layer.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\r\nmodule.exports = Layer;\r\n\r\n/* Import */\r\nvar methods = __webpack_require__(/*! ../methods/methods */ \"./node_modules/neataptic/src/methods/methods.js\");\r\nvar Group = __webpack_require__(/*! ./group */ \"./node_modules/neataptic/src/architecture/group.js\");\r\nvar Node = __webpack_require__(/*! ./node */ \"./node_modules/neataptic/src/architecture/node.js\");\r\n\r\n/*******************************************************************************\r\n                                         Group\r\n*******************************************************************************/\r\n\r\nfunction Layer () {\r\n  this.output = null;\r\n\r\n  this.nodes = [];\r\n  this.connections = { in: [],\r\n    out: [],\r\n    self: []\r\n  };\r\n}\r\n\r\nLayer.prototype = {\r\n  /**\r\n   * Activates all the nodes in the group\r\n   */\r\n  activate: function (value) {\r\n    var values = [];\r\n\r\n    if (typeof value !== 'undefined' && value.length !== this.nodes.length) {\r\n      throw new Error('Array with values should be same as the amount of nodes!');\r\n    }\r\n\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      var activation;\r\n      if (typeof value === 'undefined') {\r\n        activation = this.nodes[i].activate();\r\n      } else {\r\n        activation = this.nodes[i].activate(value[i]);\r\n      }\r\n\r\n      values.push(activation);\r\n    }\r\n\r\n    return values;\r\n  },\r\n\r\n  /**\r\n   * Propagates all the node in the group\r\n   */\r\n  propagate: function (rate, momentum, target) {\r\n    if (typeof target !== 'undefined' && target.length !== this.nodes.length) {\r\n      throw new Error('Array with values should be same as the amount of nodes!');\r\n    }\r\n\r\n    for (var i = this.nodes.length - 1; i >= 0; i--) {\r\n      if (typeof target === 'undefined') {\r\n        this.nodes[i].propagate(rate, momentum, true);\r\n      } else {\r\n        this.nodes[i].propagate(rate, momentum, true, target[i]);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Connects the nodes in this group to nodes in another group or just a node\r\n   */\r\n  connect: function (target, method, weight) {\r\n    var connections;\r\n    if (target instanceof Group || target instanceof Node) {\r\n      connections = this.output.connect(target, method, weight);\r\n    } else if (target instanceof Layer) {\r\n      connections = target.input(this, method, weight);\r\n    }\r\n\r\n    return connections;\r\n  },\r\n\r\n  /**\r\n   * Make nodes from this group gate the given connection(s)\r\n   */\r\n  gate: function (connections, method) {\r\n    this.output.gate(connections, method);\r\n  },\r\n\r\n  /**\r\n   * Sets the value of a property for every node\r\n   */\r\n  set: function (values) {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      var node = this.nodes[i];\r\n\r\n      if (node instanceof Node) {\r\n        if (typeof values.bias !== 'undefined') {\r\n          node.bias = values.bias;\r\n        }\r\n\r\n        node.squash = values.squash || node.squash;\r\n        node.type = values.type || node.type;\r\n      } else if (node instanceof Group) {\r\n        node.set(values);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Disconnects all nodes from this group from another given group/node\r\n   */\r\n  disconnect: function (target, twosided) {\r\n    twosided = twosided || false;\r\n\r\n    // In the future, disconnect will return a connection so indexOf can be used\r\n    var i, j, k;\r\n    if (target instanceof Group) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        for (j = 0; j < target.nodes.length; j++) {\r\n          this.nodes[i].disconnect(target.nodes[j], twosided);\r\n\r\n          for (k = this.connections.out.length - 1; k >= 0; k--) {\r\n            let conn = this.connections.out[k];\r\n\r\n            if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {\r\n              this.connections.out.splice(k, 1);\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (twosided) {\r\n            for (k = this.connections.in.length - 1; k >= 0; k--) {\r\n              let conn = this.connections.in[k];\r\n\r\n              if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {\r\n                this.connections.in.splice(k, 1);\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else if (target instanceof Node) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        this.nodes[i].disconnect(target, twosided);\r\n\r\n        for (j = this.connections.out.length - 1; j >= 0; j--) {\r\n          let conn = this.connections.out[j];\r\n\r\n          if (conn.from === this.nodes[i] && conn.to === target) {\r\n            this.connections.out.splice(j, 1);\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (twosided) {\r\n          for (k = this.connections.in.length - 1; k >= 0; k--) {\r\n            let conn = this.connections.in[k];\r\n\r\n            if (conn.from === target && conn.to === this.nodes[i]) {\r\n              this.connections.in.splice(k, 1);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Clear the context of this group\r\n   */\r\n  clear: function () {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].clear();\r\n    }\r\n  }\r\n};\r\n\r\nLayer.Dense = function (size) {\r\n  // Create the layer\r\n  var layer = new Layer();\r\n\r\n  // Init required nodes (in activation order)\r\n  var block = new Group(size);\r\n\r\n  layer.nodes.push(block);\r\n  layer.output = block;\r\n\r\n  layer.input = function (from, method, weight) {\r\n    if (from instanceof Layer) from = from.output;\r\n    method = method || methods.connection.ALL_TO_ALL;\r\n    return from.connect(block, method, weight);\r\n  };\r\n\r\n  return layer;\r\n};\r\n\r\nLayer.LSTM = function (size) {\r\n  // Create the layer\r\n  var layer = new Layer();\r\n\r\n  // Init required nodes (in activation order)\r\n  var inputGate = new Group(size);\r\n  var forgetGate = new Group(size);\r\n  var memoryCell = new Group(size);\r\n  var outputGate = new Group(size);\r\n  var outputBlock = new Group(size);\r\n\r\n  inputGate.set({\r\n    bias: 1\r\n  });\r\n  forgetGate.set({\r\n    bias: 1\r\n  });\r\n  outputGate.set({\r\n    bias: 1\r\n  });\r\n\r\n  // Set up internal connections\r\n  memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL);\r\n  memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL);\r\n  memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL);\r\n  var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE);\r\n  var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL);\r\n\r\n  // Set up gates\r\n  forgetGate.gate(forget, methods.gating.SELF);\r\n  outputGate.gate(output, methods.gating.OUTPUT);\r\n\r\n  // Add to nodes array\r\n  layer.nodes = [inputGate, forgetGate, memoryCell, outputGate, outputBlock];\r\n\r\n  // Define output\r\n  layer.output = outputBlock;\r\n\r\n  layer.input = function (from, method, weight) {\r\n    if (from instanceof Layer) from = from.output;\r\n    method = method || methods.connection.ALL_TO_ALL;\r\n    var connections = [];\r\n\r\n    var input = from.connect(memoryCell, method, weight);\r\n    connections = connections.concat(input);\r\n\r\n    connections = connections.concat(from.connect(inputGate, method, weight));\r\n    connections = connections.concat(from.connect(outputGate, method, weight));\r\n    connections = connections.concat(from.connect(forgetGate, method, weight));\r\n\r\n    inputGate.gate(input, methods.gating.INPUT);\r\n\r\n    return connections;\r\n  };\r\n\r\n  return layer;\r\n};\r\n\r\nLayer.GRU = function (size) {\r\n  // Create the layer\r\n  var layer = new Layer();\r\n\r\n  var updateGate = new Group(size);\r\n  var inverseUpdateGate = new Group(size);\r\n  var resetGate = new Group(size);\r\n  var memoryCell = new Group(size);\r\n  var output = new Group(size);\r\n  var previousOutput = new Group(size);\r\n\r\n  previousOutput.set({\r\n    bias: 0,\r\n    squash: methods.activation.IDENTITY,\r\n    type: 'constant'\r\n  });\r\n  memoryCell.set({\r\n    squash: methods.activation.TANH\r\n  });\r\n  inverseUpdateGate.set({\r\n    bias: 0,\r\n    squash: methods.activation.INVERSE,\r\n    type: 'constant'\r\n  });\r\n  updateGate.set({\r\n    bias: 1\r\n  });\r\n  resetGate.set({\r\n    bias: 0\r\n  });\r\n\r\n  // Update gate calculation\r\n  previousOutput.connect(updateGate, methods.connection.ALL_TO_ALL);\r\n\r\n  // Inverse update gate calculation\r\n  updateGate.connect(inverseUpdateGate, methods.connection.ONE_TO_ONE, 1);\r\n\r\n  // Reset gate calculation\r\n  previousOutput.connect(resetGate, methods.connection.ALL_TO_ALL);\r\n\r\n  // Memory calculation\r\n  var reset = previousOutput.connect(memoryCell, methods.connection.ALL_TO_ALL);\r\n\r\n  resetGate.gate(reset, methods.gating.OUTPUT); // gate\r\n\r\n  // Output calculation\r\n  var update1 = previousOutput.connect(output, methods.connection.ALL_TO_ALL);\r\n  var update2 = memoryCell.connect(output, methods.connection.ALL_TO_ALL);\r\n\r\n  updateGate.gate(update1, methods.gating.OUTPUT);\r\n  inverseUpdateGate.gate(update2, methods.gating.OUTPUT);\r\n\r\n  // Previous output calculation\r\n  output.connect(previousOutput, methods.connection.ONE_TO_ONE, 1);\r\n\r\n  // Add to nodes array\r\n  layer.nodes = [updateGate, inverseUpdateGate, resetGate, memoryCell, output, previousOutput];\r\n\r\n  layer.output = output;\r\n\r\n  layer.input = function (from, method, weight) {\r\n    if (from instanceof Layer) from = from.output;\r\n    method = method || methods.connection.ALL_TO_ALL;\r\n    var connections = [];\r\n\r\n    connections = connections.concat(from.connect(updateGate, method, weight));\r\n    connections = connections.concat(from.connect(resetGate, method, weight));\r\n    connections = connections.concat(from.connect(memoryCell, method, weight));\r\n\r\n    return connections;\r\n  };\r\n\r\n  return layer;\r\n};\r\n\r\nLayer.Memory = function (size, memory) {\r\n  // Create the layer\r\n  var layer = new Layer();\r\n  // Because the output can only be one group, we have to put the nodes all in óne group\r\n\r\n  var previous = null;\r\n  var i;\r\n  for (i = 0; i < memory; i++) {\r\n    var block = new Group(size);\r\n\r\n    block.set({\r\n      squash: methods.activation.IDENTITY,\r\n      bias: 0,\r\n      type: 'constant'\r\n    });\r\n\r\n    if (previous != null) {\r\n      previous.connect(block, methods.connection.ONE_TO_ONE, 1);\r\n    }\r\n\r\n    layer.nodes.push(block);\r\n    previous = block;\r\n  }\r\n\r\n  layer.nodes.reverse();\r\n\r\n  for (i = 0; i < layer.nodes.length; i++) {\r\n    layer.nodes[i].nodes.reverse();\r\n  }\r\n\r\n  // Because output can only be óne group, fit all memory nodes in óne group\r\n  var outputGroup = new Group(0);\r\n  for (var group in layer.nodes) {\r\n    outputGroup.nodes = outputGroup.nodes.concat(layer.nodes[group].nodes);\r\n  }\r\n  layer.output = outputGroup;\r\n\r\n  layer.input = function (from, method, weight) {\r\n    if (from instanceof Layer) from = from.output;\r\n    method = method || methods.connection.ALL_TO_ALL;\r\n\r\n    if (from.nodes.length !== layer.nodes[layer.nodes.length - 1].nodes.length) {\r\n      throw new Error('Previous layer size must be same as memory size');\r\n    }\r\n\r\n    return from.connect(layer.nodes[layer.nodes.length - 1], methods.connection.ONE_TO_ONE, 1);\r\n  };\r\n\r\n  return layer;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/architecture/layer.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/architecture/network.js":
/*!************************************************************!*\
  !*** ./node_modules/neataptic/src/architecture/network.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\r\nmodule.exports = Network;\r\n\r\n/* Import */\r\nvar multi = __webpack_require__(/*! ../multithreading/multi */ \"./node_modules/neataptic/src/multithreading/multi.js\");\r\nvar methods = __webpack_require__(/*! ../methods/methods */ \"./node_modules/neataptic/src/methods/methods.js\");\r\nvar Connection = __webpack_require__(/*! ./connection */ \"./node_modules/neataptic/src/architecture/connection.js\");\r\nvar config = __webpack_require__(/*! ../config */ \"./node_modules/neataptic/src/config.js\");\r\nvar Neat = __webpack_require__(/*! ../neat */ \"./node_modules/neataptic/src/neat.js\");\r\nvar Node = __webpack_require__(/*! ./node */ \"./node_modules/neataptic/src/architecture/node.js\");\r\n\r\n/* Easier variable naming */\r\nvar mutation = methods.mutation;\r\n\r\n/*******************************************************************************\r\n                                 NETWORK\r\n*******************************************************************************/\r\n\r\nfunction Network (input, output) {\r\n  if (typeof input === 'undefined' || typeof output === 'undefined') {\r\n    throw new Error('No input or output size given');\r\n  }\r\n\r\n  this.input = input;\r\n  this.output = output;\r\n\r\n  // Store all the node and connection genes\r\n  this.nodes = []; // Stored in activation order\r\n  this.connections = [];\r\n  this.gates = [];\r\n  this.selfconns = [];\r\n\r\n  // Regularization\r\n  this.dropout = 0;\r\n\r\n  // Create input and output nodes\r\n  var i;\r\n  for (i = 0; i < this.input + this.output; i++) {\r\n    var type = i < this.input ? 'input' : 'output';\r\n    this.nodes.push(new Node(type));\r\n  }\r\n\r\n  // Connect input nodes with output nodes directly\r\n  for (i = 0; i < this.input; i++) {\r\n    for (var j = this.input; j < this.output + this.input; j++) {\r\n      // https://stats.stackexchange.com/a/248040/147931\r\n      var weight = Math.random() * this.input * Math.sqrt(2 / this.input);\r\n      this.connect(this.nodes[i], this.nodes[j], weight);\r\n    }\r\n  }\r\n}\r\n\r\nNetwork.prototype = {\r\n  /**\r\n   * Activates the network\r\n   */\r\n  activate: function (input, training) {\r\n    var output = [];\r\n\r\n    // Activate nodes chronologically\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      if (this.nodes[i].type === 'input') {\r\n        this.nodes[i].activate(input[i]);\r\n      } else if (this.nodes[i].type === 'output') {\r\n        var activation = this.nodes[i].activate();\r\n        output.push(activation);\r\n      } else {\r\n        if (training) this.nodes[i].mask = Math.random() < this.dropout ? 0 : 1;\r\n        this.nodes[i].activate();\r\n      }\r\n    }\r\n\r\n    return output;\r\n  },\r\n\r\n  /**\r\n   * Activates the network without calculating elegibility traces and such\r\n   */\r\n  noTraceActivate: function (input) {\r\n    var output = [];\r\n\r\n    // Activate nodes chronologically\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      if (this.nodes[i].type === 'input') {\r\n        this.nodes[i].noTraceActivate(input[i]);\r\n      } else if (this.nodes[i].type === 'output') {\r\n        var activation = this.nodes[i].noTraceActivate();\r\n        output.push(activation);\r\n      } else {\r\n        this.nodes[i].noTraceActivate();\r\n      }\r\n    }\r\n\r\n    return output;\r\n  },\r\n\r\n  /**\r\n   * Backpropagate the network\r\n   */\r\n  propagate: function (rate, momentum, update, target) {\r\n    if (typeof target === 'undefined' || target.length !== this.output) {\r\n      throw new Error('Output target length should match network output length');\r\n    }\r\n\r\n    var targetIndex = target.length;\r\n\r\n    // Propagate output nodes\r\n    var i;\r\n    for (i = this.nodes.length - 1; i >= this.nodes.length - this.output; i--) {\r\n      this.nodes[i].propagate(rate, momentum, update, target[--targetIndex]);\r\n    }\r\n\r\n    // Propagate hidden and input nodes\r\n    for (i = this.nodes.length - this.output - 1; i >= this.input; i--) {\r\n      this.nodes[i].propagate(rate, momentum, update);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Clear the context of the network\r\n   */\r\n  clear: function () {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].clear();\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Connects the from node to the to node\r\n   */\r\n  connect: function (from, to, weight) {\r\n    var connections = from.connect(to, weight);\r\n\r\n    for (var i = 0; i < connections.length; i++) {\r\n      var connection = connections[i];\r\n      if (from !== to) {\r\n        this.connections.push(connection);\r\n      } else {\r\n        this.selfconns.push(connection);\r\n      }\r\n    }\r\n\r\n    return connections;\r\n  },\r\n\r\n  /**\r\n   * Disconnects the from node from the to node\r\n   */\r\n  disconnect: function (from, to) {\r\n    // Delete the connection in the network's connection array\r\n    var connections = from === to ? this.selfconns : this.connections;\r\n\r\n    for (var i = 0; i < connections.length; i++) {\r\n      var connection = connections[i];\r\n      if (connection.from === from && connection.to === to) {\r\n        if (connection.gater !== null) this.ungate(connection);\r\n        connections.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Delete the connection at the sending and receiving neuron\r\n    from.disconnect(to);\r\n  },\r\n\r\n  /**\r\n   * Gate a connection with a node\r\n   */\r\n  gate: function (node, connection) {\r\n    if (this.nodes.indexOf(node) === -1) {\r\n      throw new Error('This node is not part of the network!');\r\n    } else if (connection.gater != null) {\r\n      if (config.warnings) console.warn('This connection is already gated!');\r\n      return;\r\n    }\r\n    node.gate(connection);\r\n    this.gates.push(connection);\r\n  },\r\n\r\n  /**\r\n   *  Remove the gate of a connection\r\n   */\r\n  ungate: function (connection) {\r\n    var index = this.gates.indexOf(connection);\r\n    if (index === -1) {\r\n      throw new Error('This connection is not gated!');\r\n    }\r\n\r\n    this.gates.splice(index, 1);\r\n    connection.gater.ungate(connection);\r\n  },\r\n\r\n  /**\r\n   *  Removes a node from the network\r\n   */\r\n  remove: function (node) {\r\n    var index = this.nodes.indexOf(node);\r\n\r\n    if (index === -1) {\r\n      throw new Error('This node does not exist in the network!');\r\n    }\r\n\r\n    // Keep track of gaters\r\n    var gaters = [];\r\n\r\n    // Remove selfconnections from this.selfconns\r\n    this.disconnect(node, node);\r\n\r\n    // Get all its inputting nodes\r\n    var inputs = [];\r\n    for (var i = node.connections.in.length - 1; i >= 0; i--) {\r\n      let connection = node.connections.in[i];\r\n      if (mutation.SUB_NODE.keep_gates && connection.gater !== null && connection.gater !== node) {\r\n        gaters.push(connection.gater);\r\n      }\r\n      inputs.push(connection.from);\r\n      this.disconnect(connection.from, node);\r\n    }\r\n\r\n    // Get all its outputing nodes\r\n    var outputs = [];\r\n    for (i = node.connections.out.length - 1; i >= 0; i--) {\r\n      let connection = node.connections.out[i];\r\n      if (mutation.SUB_NODE.keep_gates && connection.gater !== null && connection.gater !== node) {\r\n        gaters.push(connection.gater);\r\n      }\r\n      outputs.push(connection.to);\r\n      this.disconnect(node, connection.to);\r\n    }\r\n\r\n    // Connect the input nodes to the output nodes (if not already connected)\r\n    var connections = [];\r\n    for (i = 0; i < inputs.length; i++) {\r\n      let input = inputs[i];\r\n      for (var j = 0; j < outputs.length; j++) {\r\n        let output = outputs[j];\r\n        if (!input.isProjectingTo(output)) {\r\n          var conn = this.connect(input, output);\r\n          connections.push(conn[0]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Gate random connections with gaters\r\n    for (i = 0; i < gaters.length; i++) {\r\n      if (connections.length === 0) break;\r\n\r\n      let gater = gaters[i];\r\n      let connIndex = Math.floor(Math.random() * connections.length);\r\n\r\n      this.gate(gater, connections[connIndex]);\r\n      connections.splice(connIndex, 1);\r\n    }\r\n\r\n    // Remove gated connections gated by this node\r\n    for (i = node.connections.gated.length - 1; i >= 0; i--) {\r\n      let conn = node.connections.gated[i];\r\n      this.ungate(conn);\r\n    }\r\n\r\n    // Remove selfconnection\r\n    this.disconnect(node, node);\r\n\r\n    // Remove the node from this.nodes\r\n    this.nodes.splice(index, 1);\r\n  },\r\n\r\n  /**\r\n   * Mutates the network with the given method\r\n   */\r\n  mutate: function (method) {\r\n    if (typeof method === 'undefined') {\r\n      throw new Error('No (correct) mutate method given!');\r\n    }\r\n\r\n    var i, j;\r\n    switch (method) {\r\n      case mutation.ADD_NODE:\r\n        // Look for an existing connection and place a node in between\r\n        var connection = this.connections[Math.floor(Math.random() * this.connections.length)];\r\n        var gater = connection.gater;\r\n        this.disconnect(connection.from, connection.to);\r\n\r\n        // Insert the new node right before the old connection.to\r\n        var toIndex = this.nodes.indexOf(connection.to);\r\n        var node = new Node('hidden');\r\n\r\n        // Random squash function\r\n        node.mutate(mutation.MOD_ACTIVATION);\r\n\r\n        // Place it in this.nodes\r\n        var minBound = Math.min(toIndex, this.nodes.length - this.output);\r\n        this.nodes.splice(minBound, 0, node);\r\n\r\n        // Now create two new connections\r\n        var newConn1 = this.connect(connection.from, node)[0];\r\n        var newConn2 = this.connect(node, connection.to)[0];\r\n\r\n        // Check if the original connection was gated\r\n        if (gater != null) {\r\n          this.gate(gater, Math.random() >= 0.5 ? newConn1 : newConn2);\r\n        }\r\n        break;\r\n      case mutation.SUB_NODE:\r\n        // Check if there are nodes left to remove\r\n        if (this.nodes.length === this.input + this.output) {\r\n          if (config.warnings) console.warn('No more nodes left to remove!');\r\n          break;\r\n        }\r\n\r\n        // Select a node which isn't an input or output node\r\n        var index = Math.floor(Math.random() * (this.nodes.length - this.output - this.input) + this.input);\r\n        this.remove(this.nodes[index]);\r\n        break;\r\n      case mutation.ADD_CONN:\r\n        // Create an array of all uncreated (feedforward) connections\r\n        var available = [];\r\n        for (i = 0; i < this.nodes.length - this.output; i++) {\r\n          let node1 = this.nodes[i];\r\n          for (j = Math.max(i + 1, this.input); j < this.nodes.length; j++) {\r\n            let node2 = this.nodes[j];\r\n            if (!node1.isProjectingTo(node2)) available.push([node1, node2]);\r\n          }\r\n        }\r\n\r\n        if (available.length === 0) {\r\n          if (config.warnings) console.warn('No more connections to be made!');\r\n          break;\r\n        }\r\n\r\n        var pair = available[Math.floor(Math.random() * available.length)];\r\n        this.connect(pair[0], pair[1]);\r\n        break;\r\n      case mutation.SUB_CONN:\r\n        // List of possible connections that can be removed\r\n        var possible = [];\r\n\r\n        for (i = 0; i < this.connections.length; i++) {\r\n          let conn = this.connections[i];\r\n          // Check if it is not disabling a node\r\n          if (conn.from.connections.out.length > 1 && conn.to.connections.in.length > 1 && this.nodes.indexOf(conn.to) > this.nodes.indexOf(conn.from)) {\r\n            possible.push(conn);\r\n          }\r\n        }\r\n\r\n        if (possible.length === 0) {\r\n          if (config.warnings) console.warn('No connections to remove!');\r\n          break;\r\n        }\r\n\r\n        var randomConn = possible[Math.floor(Math.random() * possible.length)];\r\n        this.disconnect(randomConn.from, randomConn.to);\r\n        break;\r\n      case mutation.MOD_WEIGHT:\r\n        var allconnections = this.connections.concat(this.selfconns);\r\n\r\n        var connection = allconnections[Math.floor(Math.random() * allconnections.length)];\r\n        var modification = Math.random() * (method.max - method.min) + method.min;\r\n        connection.weight += modification;\r\n        break;\r\n      case mutation.MOD_BIAS:\r\n        // Has no effect on input node, so they are excluded\r\n        var index = Math.floor(Math.random() * (this.nodes.length - this.input) + this.input);\r\n        var node = this.nodes[index];\r\n        node.mutate(method);\r\n        break;\r\n      case mutation.MOD_ACTIVATION:\r\n        // Has no effect on input node, so they are excluded\r\n        if (!method.mutateOutput && this.input + this.output === this.nodes.length) {\r\n          if (config.warnings) console.warn('No nodes that allow mutation of activation function');\r\n          break;\r\n        }\r\n\r\n        var index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);\r\n        var node = this.nodes[index];\r\n\r\n        node.mutate(method);\r\n        break;\r\n      case mutation.ADD_SELF_CONN:\r\n        // Check which nodes aren't selfconnected yet\r\n        var possible = [];\r\n        for (i = this.input; i < this.nodes.length; i++) {\r\n          let node = this.nodes[i];\r\n          if (node.connections.self.weight === 0) {\r\n            possible.push(node);\r\n          }\r\n        }\r\n\r\n        if (possible.length === 0) {\r\n          if (config.warnings) console.warn('No more self-connections to add!');\r\n          break;\r\n        }\r\n\r\n        // Select a random node\r\n        var node = possible[Math.floor(Math.random() * possible.length)];\r\n\r\n        // Connect it to himself\r\n        this.connect(node, node);\r\n        break;\r\n      case mutation.SUB_SELF_CONN:\r\n        if (this.selfconns.length === 0) {\r\n          if (config.warnings) console.warn('No more self-connections to remove!');\r\n          break;\r\n        }\r\n        var conn = this.selfconns[Math.floor(Math.random() * this.selfconns.length)];\r\n        this.disconnect(conn.from, conn.to);\r\n        break;\r\n      case mutation.ADD_GATE:\r\n        var allconnections = this.connections.concat(this.selfconns);\r\n\r\n        // Create a list of all non-gated connections\r\n        var possible = [];\r\n        for (i = 0; i < allconnections.length; i++) {\r\n          let conn = allconnections[i];\r\n          if (conn.gater === null) {\r\n            possible.push(conn);\r\n          }\r\n        }\r\n\r\n        if (possible.length === 0) {\r\n          if (config.warnings) console.warn('No more connections to gate!');\r\n          break;\r\n        }\r\n\r\n        // Select a random gater node and connection, can't be gated by input\r\n        var index = Math.floor(Math.random() * (this.nodes.length - this.input) + this.input);\r\n        var node = this.nodes[index];\r\n        var conn = possible[Math.floor(Math.random() * possible.length)];\r\n\r\n        // Gate the connection with the node\r\n        this.gate(node, conn);\r\n        break;\r\n      case mutation.SUB_GATE:\r\n        // Select a random gated connection\r\n        if (this.gates.length === 0) {\r\n          if (config.warnings) console.warn('No more connections to ungate!');\r\n          break;\r\n        }\r\n\r\n        var index = Math.floor(Math.random() * this.gates.length);\r\n        var gatedconn = this.gates[index];\r\n\r\n        this.ungate(gatedconn);\r\n        break;\r\n      case mutation.ADD_BACK_CONN:\r\n        // Create an array of all uncreated (backfed) connections\r\n        var available = [];\r\n        for (i = this.input; i < this.nodes.length; i++) {\r\n          let node1 = this.nodes[i];\r\n          for (j = this.input; j < i; j++) {\r\n            let node2 = this.nodes[j];\r\n            if (!node1.isProjectingTo(node2)) available.push([node1, node2]);\r\n          }\r\n        }\r\n\r\n        if (available.length === 0) {\r\n          if (config.warnings) console.warn('No more connections to be made!');\r\n          break;\r\n        }\r\n\r\n        var pair = available[Math.floor(Math.random() * available.length)];\r\n        this.connect(pair[0], pair[1]);\r\n        break;\r\n      case mutation.SUB_BACK_CONN:\r\n        // List of possible connections that can be removed\r\n        var possible = [];\r\n\r\n        for (i = 0; i < this.connections.length; i++) {\r\n          let conn = this.connections[i];\r\n          // Check if it is not disabling a node\r\n          if (conn.from.connections.out.length > 1 && conn.to.connections.in.length > 1 && this.nodes.indexOf(conn.from) > this.nodes.indexOf(conn.to)) {\r\n            possible.push(conn);\r\n          }\r\n        }\r\n\r\n        if (possible.length === 0) {\r\n          if (config.warnings) console.warn('No connections to remove!');\r\n          break;\r\n        }\r\n\r\n        var randomConn = possible[Math.floor(Math.random() * possible.length)];\r\n        this.disconnect(randomConn.from, randomConn.to);\r\n        break;\r\n      case mutation.SWAP_NODES:\r\n        // Has no effect on input node, so they are excluded\r\n        if ((method.mutateOutput && this.nodes.length - this.input < 2) ||\r\n          (!method.mutateOutput && this.nodes.length - this.input - this.output < 2)) {\r\n          if (config.warnings) console.warn('No nodes that allow swapping of bias and activation function');\r\n          break;\r\n        }\r\n\r\n        var index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);\r\n        var node1 = this.nodes[index];\r\n        index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);\r\n        var node2 = this.nodes[index];\r\n\r\n        var biasTemp = node1.bias;\r\n        var squashTemp = node1.squash;\r\n\r\n        node1.bias = node2.bias;\r\n        node1.squash = node2.squash;\r\n        node2.bias = biasTemp;\r\n        node2.squash = squashTemp;\r\n        break;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Train the given set to this network\r\n   */\r\n  train: function (set, options) {\r\n    if (set[0].input.length !== this.input || set[0].output.length !== this.output) {\r\n      throw new Error('Dataset input/output size should be same as network input/output size!');\r\n    }\r\n\r\n    options = options || {};\r\n\r\n    // Warning messages\r\n    if (typeof options.rate === 'undefined') {\r\n      if (config.warnings) console.warn('Using default learning rate, please define a rate!');\r\n    }\r\n    if (typeof options.iterations === 'undefined') {\r\n      if (config.warnings) console.warn('No target iterations given, running until error is reached!');\r\n    }\r\n\r\n    // Read the options\r\n    var targetError = options.error || 0.05;\r\n    var cost = options.cost || methods.cost.MSE;\r\n    var baseRate = options.rate || 0.3;\r\n    var dropout = options.dropout || 0;\r\n    var momentum = options.momentum || 0;\r\n    var batchSize = options.batchSize || 1; // online learning\r\n    var ratePolicy = options.ratePolicy || methods.rate.FIXED();\r\n\r\n    var start = Date.now();\r\n\r\n    if (batchSize > set.length) {\r\n      throw new Error('Batch size must be smaller or equal to dataset length!');\r\n    } else if (typeof options.iterations === 'undefined' && typeof options.error === 'undefined') {\r\n      throw new Error('At least one of the following options must be specified: error, iterations');\r\n    } else if (typeof options.error === 'undefined') {\r\n      targetError = -1; // run until iterations\r\n    } else if (typeof options.iterations === 'undefined') {\r\n      options.iterations = 0; // run until target error\r\n    }\r\n\r\n    // Save to network\r\n    this.dropout = dropout;\r\n\r\n    if (options.crossValidate) {\r\n      let numTrain = Math.ceil((1 - options.crossValidate.testSize) * set.length);\r\n      var trainSet = set.slice(0, numTrain);\r\n      var testSet = set.slice(numTrain);\r\n    }\r\n\r\n    // Loops the training process\r\n    var currentRate = baseRate;\r\n    var iteration = 0;\r\n    var error = 1;\r\n\r\n    var i, j, x;\r\n    while (error > targetError && (options.iterations === 0 || iteration < options.iterations)) {\r\n      if (options.crossValidate && error <= options.crossValidate.testError) break;\r\n\r\n      iteration++;\r\n\r\n      // Update the rate\r\n      currentRate = ratePolicy(baseRate, iteration);\r\n\r\n      // Checks if cross validation is enabled\r\n      if (options.crossValidate) {\r\n        this._trainSet(trainSet, batchSize, currentRate, momentum, cost);\r\n        if (options.clear) this.clear();\r\n        error = this.test(testSet, cost).error;\r\n        if (options.clear) this.clear();\r\n      } else {\r\n        error = this._trainSet(set, batchSize, currentRate, momentum, cost);\r\n        if (options.clear) this.clear();\r\n      }\r\n\r\n      // Checks for options such as scheduled logs and shuffling\r\n      if (options.shuffle) {\r\n        for (j, x, i = set.length; i; j = Math.floor(Math.random() * i), x = set[--i], set[i] = set[j], set[j] = x);\r\n      }\r\n\r\n      if (options.log && iteration % options.log === 0) {\r\n        console.log('iteration', iteration, 'error', error, 'rate', currentRate);\r\n      }\r\n\r\n      if (options.schedule && iteration % options.schedule.iterations === 0) {\r\n        options.schedule.function({ error: error, iteration: iteration });\r\n      }\r\n    }\r\n\r\n    if (options.clear) this.clear();\r\n\r\n    if (dropout) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        if (this.nodes[i].type === 'hidden' || this.nodes[i].type === 'constant') {\r\n          this.nodes[i].mask = 1 - this.dropout;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      error: error,\r\n      iterations: iteration,\r\n      time: Date.now() - start\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Performs one training epoch and returns the error\r\n   * private function used in this.train\r\n   */\r\n  _trainSet: function (set, batchSize, currentRate, momentum, costFunction) {\r\n    var errorSum = 0;\r\n    for (var i = 0; i < set.length; i++) {\r\n      var input = set[i].input;\r\n      var target = set[i].output;\r\n\r\n      var update = !!((i + 1) % batchSize === 0 || (i + 1) === set.length);\r\n\r\n      var output = this.activate(input, true);\r\n      this.propagate(currentRate, momentum, update, target);\r\n\r\n      errorSum += costFunction(target, output);\r\n    }\r\n    return errorSum / set.length;\r\n  },\r\n\r\n  /**\r\n   * Tests a set and returns the error and elapsed time\r\n   */\r\n  test: function (set, cost = methods.cost.MSE) {\r\n    // Check if dropout is enabled, set correct mask\r\n    var i;\r\n    if (this.dropout) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        if (this.nodes[i].type === 'hidden' || this.nodes[i].type === 'constant') {\r\n          this.nodes[i].mask = 1 - this.dropout;\r\n        }\r\n      }\r\n    }\r\n\r\n    var error = 0;\r\n    var start = Date.now();\r\n\r\n    for (i = 0; i < set.length; i++) {\r\n      let input = set[i].input;\r\n      let target = set[i].output;\r\n      let output = this.noTraceActivate(input);\r\n      error += cost(target, output);\r\n    }\r\n\r\n    error /= set.length;\r\n\r\n    var results = {\r\n      error: error,\r\n      time: Date.now() - start\r\n    };\r\n\r\n    return results;\r\n  },\r\n\r\n  /**\r\n   * Creates a json that can be used to create a graph with d3 and webcola\r\n   */\r\n  graph: function (width, height) {\r\n    var input = 0;\r\n    var output = 0;\r\n\r\n    var json = {\r\n      nodes: [],\r\n      links: [],\r\n      constraints: [{\r\n        type: 'alignment',\r\n        axis: 'x',\r\n        offsets: []\r\n      }, {\r\n        type: 'alignment',\r\n        axis: 'y',\r\n        offsets: []\r\n      }]\r\n    };\r\n\r\n    var i;\r\n    for (i = 0; i < this.nodes.length; i++) {\r\n      var node = this.nodes[i];\r\n\r\n      if (node.type === 'input') {\r\n        if (this.input === 1) {\r\n          json.constraints[0].offsets.push({\r\n            node: i,\r\n            offset: 0\r\n          });\r\n        } else {\r\n          json.constraints[0].offsets.push({\r\n            node: i,\r\n            offset: 0.8 * width / (this.input - 1) * input++\r\n          });\r\n        }\r\n        json.constraints[1].offsets.push({\r\n          node: i,\r\n          offset: 0\r\n        });\r\n      } else if (node.type === 'output') {\r\n        if (this.output === 1) {\r\n          json.constraints[0].offsets.push({\r\n            node: i,\r\n            offset: 0\r\n          });\r\n        } else {\r\n          json.constraints[0].offsets.push({\r\n            node: i,\r\n            offset: 0.8 * width / (this.output - 1) * output++\r\n          });\r\n        }\r\n        json.constraints[1].offsets.push({\r\n          node: i,\r\n          offset: -0.8 * height\r\n        });\r\n      }\r\n\r\n      json.nodes.push({\r\n        id: i,\r\n        name: node.type === 'hidden' ? node.squash.name : node.type.toUpperCase(),\r\n        activation: node.activation,\r\n        bias: node.bias\r\n      });\r\n    }\r\n\r\n    var connections = this.connections.concat(this.selfconns);\r\n    for (i = 0; i < connections.length; i++) {\r\n      var connection = connections[i];\r\n      if (connection.gater == null) {\r\n        json.links.push({\r\n          source: this.nodes.indexOf(connection.from),\r\n          target: this.nodes.indexOf(connection.to),\r\n          weight: connection.weight\r\n        });\r\n      } else {\r\n        // Add a gater 'node'\r\n        var index = json.nodes.length;\r\n        json.nodes.push({\r\n          id: index,\r\n          activation: connection.gater.activation,\r\n          name: 'GATE'\r\n        });\r\n        json.links.push({\r\n          source: this.nodes.indexOf(connection.from),\r\n          target: index,\r\n          weight: 1 / 2 * connection.weight\r\n        });\r\n        json.links.push({\r\n          source: index,\r\n          target: this.nodes.indexOf(connection.to),\r\n          weight: 1 / 2 * connection.weight\r\n        });\r\n        json.links.push({\r\n          source: this.nodes.indexOf(connection.gater),\r\n          target: index,\r\n          weight: connection.gater.activation,\r\n          gate: true\r\n        });\r\n      }\r\n    }\r\n\r\n    return json;\r\n  },\r\n\r\n  /**\r\n   * Convert the network to a json object\r\n   */\r\n  toJSON: function () {\r\n    var json = {\r\n      nodes: [],\r\n      connections: [],\r\n      input: this.input,\r\n      output: this.output,\r\n      dropout: this.dropout\r\n    };\r\n\r\n    // So we don't have to use expensive .indexOf()\r\n    var i;\r\n    for (i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].index = i;\r\n    }\r\n\r\n    for (i = 0; i < this.nodes.length; i++) {\r\n      let node = this.nodes[i];\r\n      let tojson = node.toJSON();\r\n      tojson.index = i;\r\n      json.nodes.push(tojson);\r\n\r\n      if (node.connections.self.weight !== 0) {\r\n        let tojson = node.connections.self.toJSON();\r\n        tojson.from = i;\r\n        tojson.to = i;\r\n\r\n        tojson.gater = node.connections.self.gater != null ? node.connections.self.gater.index : null;\r\n        json.connections.push(tojson);\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < this.connections.length; i++) {\r\n      let conn = this.connections[i];\r\n      let tojson = conn.toJSON();\r\n      tojson.from = conn.from.index;\r\n      tojson.to = conn.to.index;\r\n\r\n      tojson.gater = conn.gater != null ? conn.gater.index : null;\r\n\r\n      json.connections.push(tojson);\r\n    }\r\n\r\n    return json;\r\n  },\r\n\r\n  /**\r\n   * Sets the value of a property for every node in this network\r\n   */\r\n  set: function (values) {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].bias = values.bias || this.nodes[i].bias;\r\n      this.nodes[i].squash = values.squash || this.nodes[i].squash;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Evolves the network to reach a lower error on a dataset\r\n   */\r\n  evolve: async function (set, options) {\r\n    if (set[0].input.length !== this.input || set[0].output.length !== this.output) {\r\n      throw new Error('Dataset input/output size should be same as network input/output size!');\r\n    }\r\n\r\n    // Read the options\r\n    options = options || {};\r\n    var targetError = typeof options.error !== 'undefined' ? options.error : 0.05;\r\n    var growth = typeof options.growth !== 'undefined' ? options.growth : 0.0001;\r\n    var cost = options.cost || methods.cost.MSE;\r\n    var amount = options.amount || 1;\r\n\r\n    var threads = options.threads;\r\n    if (typeof threads === 'undefined') {\r\n      if (typeof window === 'undefined') { // Node.js\r\n        threads = __webpack_require__(/*! os */ \"./node_modules/os-browserify/browser.js\").cpus().length;\r\n      } else { // Browser\r\n        threads = navigator.hardwareConcurrency;\r\n      }\r\n    }\r\n\r\n    var start = Date.now();\r\n\r\n    if (typeof options.iterations === 'undefined' && typeof options.error === 'undefined') {\r\n      throw new Error('At least one of the following options must be specified: error, iterations');\r\n    } else if (typeof options.error === 'undefined') {\r\n      targetError = -1; // run until iterations\r\n    } else if (typeof options.iterations === 'undefined') {\r\n      options.iterations = 0; // run until target error\r\n    }\r\n\r\n    var fitnessFunction;\r\n    if (threads === 1) {\r\n      // Create the fitness function\r\n      fitnessFunction = function (genome) {\r\n        var score = 0;\r\n        for (var i = 0; i < amount; i++) {\r\n          score -= genome.test(set, cost).error;\r\n        }\r\n\r\n        score -= (genome.nodes.length - genome.input - genome.output + genome.connections.length + genome.gates.length) * growth;\r\n        score = isNaN(score) ? -Infinity : score; // this can cause problems with fitness proportionate selection\r\n\r\n        return score / amount;\r\n      };\r\n    } else {\r\n      // Serialize the dataset\r\n      var converted = multi.serializeDataSet(set);\r\n\r\n      // Create workers, send datasets\r\n      var workers = [];\r\n      if (typeof window === 'undefined') {\r\n        for (var i = 0; i < threads; i++) {\r\n          workers.push(new multi.workers.node.TestWorker(converted, cost));\r\n        }\r\n      } else {\r\n        for (var i = 0; i < threads; i++) {\r\n          workers.push(new multi.workers.browser.TestWorker(converted, cost));\r\n        }\r\n      }\r\n\r\n      fitnessFunction = function (population) {\r\n        return new Promise((resolve, reject) => {\r\n          // Create a queue\r\n          var queue = population.slice();\r\n          var done = 0;\r\n\r\n          // Start worker function\r\n          var startWorker = function (worker) {\r\n            if (!queue.length) {\r\n              if (++done === threads) resolve();\r\n              return;\r\n            }\r\n\r\n            var genome = queue.shift();\r\n\r\n            worker.evaluate(genome).then(function (result) {\r\n              genome.score = -result;\r\n              genome.score -= (genome.nodes.length - genome.input - genome.output +\r\n                genome.connections.length + genome.gates.length) * growth;\r\n              genome.score = isNaN(parseFloat(result)) ? -Infinity : genome.score;\r\n              startWorker(worker);\r\n            });\r\n          };\r\n\r\n          for (var i = 0; i < workers.length; i++) {\r\n            startWorker(workers[i]);\r\n          }\r\n        });\r\n      };\r\n\r\n      options.fitnessPopulation = true;\r\n    }\r\n\r\n    // Intialise the NEAT instance\r\n    options.network = this;\r\n    var neat = new Neat(this.input, this.output, fitnessFunction, options);\r\n\r\n    var error = -Infinity;\r\n    var bestFitness = -Infinity;\r\n    var bestGenome;\r\n\r\n    while (error < -targetError && (options.iterations === 0 || neat.generation < options.iterations)) {\r\n      let fittest = await neat.evolve();\r\n      let fitness = fittest.score;\r\n      error = fitness + (fittest.nodes.length - fittest.input - fittest.output + fittest.connections.length + fittest.gates.length) * growth;\r\n\r\n      if (fitness > bestFitness) {\r\n        bestFitness = fitness;\r\n        bestGenome = fittest;\r\n      }\r\n\r\n      if (options.log && neat.generation % options.log === 0) {\r\n        console.log('iteration', neat.generation, 'fitness', fitness, 'error', -error);\r\n      }\r\n\r\n      if (options.schedule && neat.generation % options.schedule.iterations === 0) {\r\n        options.schedule.function({ fitness: fitness, error: -error, iteration: neat.generation });\r\n      }\r\n    }\r\n\r\n    if (threads > 1) {\r\n      for (var i = 0; i < workers.length; i++) workers[i].terminate();\r\n    }\r\n\r\n    if (typeof bestGenome !== 'undefined') {\r\n      this.nodes = bestGenome.nodes;\r\n      this.connections = bestGenome.connections;\r\n      this.selfconns = bestGenome.selfconns;\r\n      this.gates = bestGenome.gates;\r\n\r\n      if (options.clear) this.clear();\r\n    }\r\n\r\n    return {\r\n      error: -error,\r\n      iterations: neat.generation,\r\n      time: Date.now() - start\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Creates a standalone function of the network which can be run without the\r\n   * need of a library\r\n   */\r\n  standalone: function () {\r\n    var present = [];\r\n    var activations = [];\r\n    var states = [];\r\n    var lines = [];\r\n    var functions = [];\r\n\r\n    var i;\r\n    for (i = 0; i < this.input; i++) {\r\n      var node = this.nodes[i];\r\n      activations.push(node.activation);\r\n      states.push(node.state);\r\n    }\r\n\r\n    lines.push('for(var i = 0; i < input.length; i++) A[i] = input[i];');\r\n\r\n    // So we don't have to use expensive .indexOf()\r\n    for (i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].index = i;\r\n    }\r\n\r\n    for (i = this.input; i < this.nodes.length; i++) {\r\n      let node = this.nodes[i];\r\n      activations.push(node.activation);\r\n      states.push(node.state);\r\n\r\n      var functionIndex = present.indexOf(node.squash.name);\r\n\r\n      if (functionIndex === -1) {\r\n        functionIndex = present.length;\r\n        present.push(node.squash.name);\r\n        functions.push(node.squash.toString());\r\n      }\r\n\r\n      var incoming = [];\r\n      for (var j = 0; j < node.connections.in.length; j++) {\r\n        var conn = node.connections.in[j];\r\n        var computation = `A[${conn.from.index}] * ${conn.weight}`;\r\n\r\n        if (conn.gater != null) {\r\n          computation += ` * A[${conn.gater.index}]`;\r\n        }\r\n\r\n        incoming.push(computation);\r\n      }\r\n\r\n      if (node.connections.self.weight) {\r\n        let conn = node.connections.self;\r\n        let computation = `S[${i}] * ${conn.weight}`;\r\n\r\n        if (conn.gater != null) {\r\n          computation += ` * A[${conn.gater.index}]`;\r\n        }\r\n\r\n        incoming.push(computation);\r\n      }\r\n\r\n      var line1 = `S[${i}] = ${incoming.join(' + ')} + ${node.bias};`;\r\n      var line2 = `A[${i}] = F[${functionIndex}](S[${i}])${!node.mask ? ' * ' + node.mask : ''};`;\r\n      lines.push(line1);\r\n      lines.push(line2);\r\n    }\r\n\r\n    var output = [];\r\n    for (i = this.nodes.length - this.output; i < this.nodes.length; i++) {\r\n      output.push(`A[${i}]`);\r\n    }\r\n\r\n    output = `return [${output.join(',')}];`;\r\n    lines.push(output);\r\n\r\n    var total = '';\r\n    total += `var F = [${functions.toString()}];\\r\\n`;\r\n    total += `var A = [${activations.toString()}];\\r\\n`;\r\n    total += `var S = [${states.toString()}];\\r\\n`;\r\n    total += `function activate(input){\\r\\n${lines.join('\\r\\n')}\\r\\n}`;\r\n\r\n    return total;\r\n  },\r\n\r\n  /**\r\n   * Serialize to send to workers efficiently\r\n   */\r\n  serialize: function () {\r\n    var activations = [];\r\n    var states = [];\r\n    var conns = [];\r\n    var squashes = [\r\n      'LOGISTIC', 'TANH', 'IDENTITY', 'STEP', 'RELU', 'SOFTSIGN', 'SINUSOID',\r\n      'GAUSSIAN', 'BENT_IDENTITY', 'BIPOLAR', 'BIPOLAR_SIGMOID', 'HARD_TANH',\r\n      'ABSOLUTE', 'INVERSE', 'SELU'\r\n    ];\r\n\r\n    conns.push(this.input);\r\n    conns.push(this.output);\r\n\r\n    var i;\r\n    for (i = 0; i < this.nodes.length; i++) {\r\n      let node = this.nodes[i];\r\n      node.index = i;\r\n      activations.push(node.activation);\r\n      states.push(node.state);\r\n    }\r\n\r\n    for (i = this.input; i < this.nodes.length; i++) {\r\n      let node = this.nodes[i];\r\n      conns.push(node.index);\r\n      conns.push(node.bias);\r\n      conns.push(squashes.indexOf(node.squash.name));\r\n\r\n      conns.push(node.connections.self.weight);\r\n      conns.push(node.connections.self.gater == null ? -1 : node.connections.self.gater.index);\r\n\r\n      for (var j = 0; j < node.connections.in.length; j++) {\r\n        let conn = node.connections.in[j];\r\n\r\n        conns.push(conn.from.index);\r\n        conns.push(conn.weight);\r\n        conns.push(conn.gater == null ? -1 : conn.gater.index);\r\n      }\r\n\r\n      conns.push(-2); // stop token -> next node\r\n    }\r\n\r\n    return [activations, states, conns];\r\n  }\r\n};\r\n\r\n/**\r\n * Convert a json object to a network\r\n */\r\nNetwork.fromJSON = function (json) {\r\n  var network = new Network(json.input, json.output);\r\n  network.dropout = json.dropout;\r\n  network.nodes = [];\r\n  network.connections = [];\r\n\r\n  var i;\r\n  for (i = 0; i < json.nodes.length; i++) {\r\n    network.nodes.push(Node.fromJSON(json.nodes[i]));\r\n  }\r\n\r\n  for (i = 0; i < json.connections.length; i++) {\r\n    var conn = json.connections[i];\r\n\r\n    var connection = network.connect(network.nodes[conn.from], network.nodes[conn.to])[0];\r\n    connection.weight = conn.weight;\r\n\r\n    if (conn.gater != null) {\r\n      network.gate(network.nodes[conn.gater], connection);\r\n    }\r\n  }\r\n\r\n  return network;\r\n};\r\n\r\n/**\r\n * Merge two networks into one\r\n */\r\nNetwork.merge = function (network1, network2) {\r\n  // Create a copy of the networks\r\n  network1 = Network.fromJSON(network1.toJSON());\r\n  network2 = Network.fromJSON(network2.toJSON());\r\n\r\n  // Check if output and input size are the same\r\n  if (network1.output !== network2.input) {\r\n    throw new Error('Output size of network1 should be the same as the input size of network2!');\r\n  }\r\n\r\n  // Redirect all connections from network2 input from network1 output\r\n  var i;\r\n  for (i = 0; i < network2.connections.length; i++) {\r\n    let conn = network2.connections[i];\r\n    if (conn.from.type === 'input') {\r\n      let index = network2.nodes.indexOf(conn.from);\r\n\r\n      // redirect\r\n      conn.from = network1.nodes[network1.nodes.length - 1 - index];\r\n    }\r\n  }\r\n\r\n  // Delete input nodes of network2\r\n  for (i = network2.input - 1; i >= 0; i--) {\r\n    network2.nodes.splice(i, 1);\r\n  }\r\n\r\n  // Change the node type of network1's output nodes (now hidden)\r\n  for (i = network1.nodes.length - network1.output; i < network1.nodes.length; i++) {\r\n    network1.nodes[i].type = 'hidden';\r\n  }\r\n\r\n  // Create one network from both networks\r\n  network1.connections = network1.connections.concat(network2.connections);\r\n  network1.nodes = network1.nodes.concat(network2.nodes);\r\n\r\n  return network1;\r\n};\r\n\r\n/**\r\n * Create an offspring from two parent networks\r\n */\r\nNetwork.crossOver = function (network1, network2, equal) {\r\n  if (network1.input !== network2.input || network1.output !== network2.output) {\r\n    throw new Error(\"Networks don't have the same input/output size!\");\r\n  }\r\n\r\n  // Initialise offspring\r\n  var offspring = new Network(network1.input, network1.output);\r\n  offspring.connections = [];\r\n  offspring.nodes = [];\r\n\r\n  // Save scores and create a copy\r\n  var score1 = network1.score || 0;\r\n  var score2 = network2.score || 0;\r\n\r\n  // Determine offspring node size\r\n  var size;\r\n  if (equal || score1 === score2) {\r\n    let max = Math.max(network1.nodes.length, network2.nodes.length);\r\n    let min = Math.min(network1.nodes.length, network2.nodes.length);\r\n    size = Math.floor(Math.random() * (max - min + 1) + min);\r\n  } else if (score1 > score2) {\r\n    size = network1.nodes.length;\r\n  } else {\r\n    size = network2.nodes.length;\r\n  }\r\n\r\n  // Rename some variables for easier reading\r\n  var outputSize = network1.output;\r\n\r\n  // Set indexes so we don't need indexOf\r\n  var i;\r\n  for (i = 0; i < network1.nodes.length; i++) {\r\n    network1.nodes[i].index = i;\r\n  }\r\n\r\n  for (i = 0; i < network2.nodes.length; i++) {\r\n    network2.nodes[i].index = i;\r\n  }\r\n\r\n  // Assign nodes from parents to offspring\r\n  for (i = 0; i < size; i++) {\r\n    // Determine if an output node is needed\r\n    var node;\r\n    if (i < size - outputSize) {\r\n      let random = Math.random();\r\n      node = random >= 0.5 ? network1.nodes[i] : network2.nodes[i];\r\n      let other = random < 0.5 ? network1.nodes[i] : network2.nodes[i];\r\n\r\n      if (typeof node === 'undefined' || node.type === 'output') {\r\n        node = other;\r\n      }\r\n    } else {\r\n      if (Math.random() >= 0.5) {\r\n        node = network1.nodes[network1.nodes.length + i - size];\r\n      } else {\r\n        node = network2.nodes[network2.nodes.length + i - size];\r\n      }\r\n    }\r\n\r\n    var newNode = new Node();\r\n    newNode.bias = node.bias;\r\n    newNode.squash = node.squash;\r\n    newNode.type = node.type;\r\n\r\n    offspring.nodes.push(newNode);\r\n  }\r\n\r\n  // Create arrays of connection genes\r\n  var n1conns = {};\r\n  var n2conns = {};\r\n\r\n  // Normal connections\r\n  for (i = 0; i < network1.connections.length; i++) {\r\n    let conn = network1.connections[i];\r\n    let data = {\r\n      weight: conn.weight,\r\n      from: conn.from.index,\r\n      to: conn.to.index,\r\n      gater: conn.gater != null ? conn.gater.index : -1\r\n    };\r\n    n1conns[Connection.innovationID(data.from, data.to)] = data;\r\n  }\r\n\r\n  // Selfconnections\r\n  for (i = 0; i < network1.selfconns.length; i++) {\r\n    let conn = network1.selfconns[i];\r\n    let data = {\r\n      weight: conn.weight,\r\n      from: conn.from.index,\r\n      to: conn.to.index,\r\n      gater: conn.gater != null ? conn.gater.index : -1\r\n    };\r\n    n1conns[Connection.innovationID(data.from, data.to)] = data;\r\n  }\r\n\r\n  // Normal connections\r\n  for (i = 0; i < network2.connections.length; i++) {\r\n    let conn = network2.connections[i];\r\n    let data = {\r\n      weight: conn.weight,\r\n      from: conn.from.index,\r\n      to: conn.to.index,\r\n      gater: conn.gater != null ? conn.gater.index : -1\r\n    };\r\n    n2conns[Connection.innovationID(data.from, data.to)] = data;\r\n  }\r\n\r\n  // Selfconnections\r\n  for (i = 0; i < network2.selfconns.length; i++) {\r\n    let conn = network2.selfconns[i];\r\n    let data = {\r\n      weight: conn.weight,\r\n      from: conn.from.index,\r\n      to: conn.to.index,\r\n      gater: conn.gater != null ? conn.gater.index : -1\r\n    };\r\n    n2conns[Connection.innovationID(data.from, data.to)] = data;\r\n  }\r\n\r\n  // Split common conn genes from disjoint or excess conn genes\r\n  var connections = [];\r\n  var keys1 = Object.keys(n1conns);\r\n  var keys2 = Object.keys(n2conns);\r\n  for (i = keys1.length - 1; i >= 0; i--) {\r\n    // Common gene\r\n    if (typeof n2conns[keys1[i]] !== 'undefined') {\r\n      let conn = Math.random() >= 0.5 ? n1conns[keys1[i]] : n2conns[keys1[i]];\r\n      connections.push(conn);\r\n\r\n      // Because deleting is expensive, just set it to some value\r\n      n2conns[keys1[i]] = undefined;\r\n    } else if (score1 >= score2 || equal) {\r\n      connections.push(n1conns[keys1[i]]);\r\n    }\r\n  }\r\n\r\n  // Excess/disjoint gene\r\n  if (score2 >= score1 || equal) {\r\n    for (i = 0; i < keys2.length; i++) {\r\n      if (typeof n2conns[keys2[i]] !== 'undefined') {\r\n        connections.push(n2conns[keys2[i]]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Add common conn genes uniformly\r\n  for (i = 0; i < connections.length; i++) {\r\n    let connData = connections[i];\r\n    if (connData.to < size && connData.from < size) {\r\n      let from = offspring.nodes[connData.from];\r\n      let to = offspring.nodes[connData.to];\r\n      let conn = offspring.connect(from, to)[0];\r\n\r\n      conn.weight = connData.weight;\r\n\r\n      if (connData.gater !== -1 && connData.gater < size) {\r\n        offspring.gate(offspring.nodes[connData.gater], conn);\r\n      }\r\n    }\r\n  }\r\n\r\n  return offspring;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/architecture/network.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/architecture/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/neataptic/src/architecture/node.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\r\nmodule.exports = Node;\r\n\r\n/* Import */\r\nvar methods = __webpack_require__(/*! ../methods/methods */ \"./node_modules/neataptic/src/methods/methods.js\");\r\nvar Connection = __webpack_require__(/*! ./connection */ \"./node_modules/neataptic/src/architecture/connection.js\");\r\nvar config = __webpack_require__(/*! ../config */ \"./node_modules/neataptic/src/config.js\");\r\n\r\n/*******************************************************************************\r\n                                         NODE\r\n*******************************************************************************/\r\n\r\nfunction Node (type) {\r\n  this.bias = (type === 'input') ? 0 : Math.random() * 0.2 - 0.1;\r\n  this.squash = methods.activation.LOGISTIC;\r\n  this.type = type || 'hidden';\r\n\r\n  this.activation = 0;\r\n  this.state = 0;\r\n  this.old = 0;\r\n\r\n  // For dropout\r\n  this.mask = 1;\r\n\r\n  // For tracking momentum\r\n  this.previousDeltaBias = 0;\r\n\r\n  // Batch training\r\n  this.totalDeltaBias = 0;\r\n\r\n  this.connections = {\r\n    in: [],\r\n    out: [],\r\n    gated: [],\r\n    self: new Connection(this, this, 0)\r\n  };\r\n\r\n  // Data for backpropagation\r\n  this.error = {\r\n    responsibility: 0,\r\n    projected: 0,\r\n    gated: 0\r\n  };\r\n}\r\n\r\nNode.prototype = {\r\n  /**\r\n   * Activates the node\r\n   */\r\n  activate: function (input) {\r\n    // Check if an input is given\r\n    if (typeof input !== 'undefined') {\r\n      this.activation = input;\r\n      return this.activation;\r\n    }\r\n\r\n    this.old = this.state;\r\n\r\n    // All activation sources coming from the node itself\r\n    this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;\r\n\r\n    // Activation sources coming from connections\r\n    var i;\r\n    for (i = 0; i < this.connections.in.length; i++) {\r\n      var connection = this.connections.in[i];\r\n      this.state += connection.from.activation * connection.weight * connection.gain;\r\n    }\r\n\r\n    // Squash the values received\r\n    this.activation = this.squash(this.state) * this.mask;\r\n    this.derivative = this.squash(this.state, true);\r\n\r\n    // Update traces\r\n    var nodes = [];\r\n    var influences = [];\r\n\r\n    for (i = 0; i < this.connections.gated.length; i++) {\r\n      let conn = this.connections.gated[i];\r\n      let node = conn.to;\r\n\r\n      let index = nodes.indexOf(node);\r\n      if (index > -1) {\r\n        influences[index] += conn.weight * conn.from.activation;\r\n      } else {\r\n        nodes.push(node);\r\n        influences.push(conn.weight * conn.from.activation +\r\n          (node.connections.self.gater === this ? node.old : 0));\r\n      }\r\n\r\n      // Adjust the gain to this nodes' activation\r\n      conn.gain = this.activation;\r\n    }\r\n\r\n    for (i = 0; i < this.connections.in.length; i++) {\r\n      let connection = this.connections.in[i];\r\n\r\n      // Elegibility trace\r\n      connection.elegibility = this.connections.self.gain * this.connections.self.weight *\r\n        connection.elegibility + connection.from.activation * connection.gain;\r\n\r\n      // Extended trace\r\n      for (var j = 0; j < nodes.length; j++) {\r\n        let node = nodes[j];\r\n        let influence = influences[j];\r\n\r\n        let index = connection.xtrace.nodes.indexOf(node);\r\n\r\n        if (index > -1) {\r\n          connection.xtrace.values[index] = node.connections.self.gain * node.connections.self.weight *\r\n            connection.xtrace.values[index] + this.derivative * connection.elegibility * influence;\r\n        } else {\r\n          // Does not exist there yet, might be through mutation\r\n          connection.xtrace.nodes.push(node);\r\n          connection.xtrace.values.push(this.derivative * connection.elegibility * influence);\r\n        }\r\n      }\r\n    }\r\n\r\n    return this.activation;\r\n  },\r\n\r\n  /**\r\n   * Activates the node without calculating elegibility traces and such\r\n   */\r\n  noTraceActivate: function (input) {\r\n    // Check if an input is given\r\n    if (typeof input !== 'undefined') {\r\n      this.activation = input;\r\n      return this.activation;\r\n    }\r\n\r\n    // All activation sources coming from the node itself\r\n    this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;\r\n\r\n    // Activation sources coming from connections\r\n    var i;\r\n    for (i = 0; i < this.connections.in.length; i++) {\r\n      var connection = this.connections.in[i];\r\n      this.state += connection.from.activation * connection.weight * connection.gain;\r\n    }\r\n\r\n    // Squash the values received\r\n    this.activation = this.squash(this.state);\r\n\r\n    for (i = 0; i < this.connections.gated.length; i++) {\r\n      this.connections.gated[i].gain = this.activation;\r\n    }\r\n\r\n    return this.activation;\r\n  },\r\n\r\n  /**\r\n   * Back-propagate the error, aka learn\r\n   */\r\n  propagate: function (rate, momentum, update, target) {\r\n    momentum = momentum || 0;\r\n    rate = rate || 0.3;\r\n\r\n    // Error accumulator\r\n    var error = 0;\r\n\r\n    // Output nodes get their error from the enviroment\r\n    if (this.type === 'output') {\r\n      this.error.responsibility = this.error.projected = target - this.activation;\r\n    } else { // the rest of the nodes compute their error responsibilities by backpropagation\r\n      // error responsibilities from all the connections projected from this node\r\n      var i;\r\n      for (i = 0; i < this.connections.out.length; i++) {\r\n        let connection = this.connections.out[i];\r\n        let node = connection.to;\r\n        // Eq. 21\r\n        error += node.error.responsibility * connection.weight * connection.gain;\r\n      }\r\n\r\n      // Projected error responsibility\r\n      this.error.projected = this.derivative * error;\r\n\r\n      // Error responsibilities from all connections gated by this neuron\r\n      error = 0;\r\n\r\n      for (i = 0; i < this.connections.gated.length; i++) {\r\n        let conn = this.connections.gated[i];\r\n        let node = conn.to;\r\n        let influence = node.connections.self.gater === this ? node.old : 0;\r\n\r\n        influence += conn.weight * conn.from.activation;\r\n        error += node.error.responsibility * influence;\r\n      }\r\n\r\n      // Gated error responsibility\r\n      this.error.gated = this.derivative * error;\r\n\r\n      // Error responsibility\r\n      this.error.responsibility = this.error.projected + this.error.gated;\r\n    }\r\n\r\n    if (this.type === 'constant') return;\r\n\r\n    // Adjust all the node's incoming connections\r\n    for (i = 0; i < this.connections.in.length; i++) {\r\n      let connection = this.connections.in[i];\r\n\r\n      let gradient = this.error.projected * connection.elegibility;\r\n\r\n      for (var j = 0; j < connection.xtrace.nodes.length; j++) {\r\n        let node = connection.xtrace.nodes[j];\r\n        let value = connection.xtrace.values[j];\r\n        gradient += node.error.responsibility * value;\r\n      }\r\n\r\n      // Adjust weight\r\n      let deltaWeight = rate * gradient * this.mask;\r\n      connection.totalDeltaWeight += deltaWeight;\r\n      if (update) {\r\n        connection.totalDeltaWeight += momentum * connection.previousDeltaWeight;\r\n        connection.weight += connection.totalDeltaWeight;\r\n        connection.previousDeltaWeight = connection.totalDeltaWeight;\r\n        connection.totalDeltaWeight = 0;\r\n      }\r\n    }\r\n\r\n    // Adjust bias\r\n    var deltaBias = rate * this.error.responsibility;\r\n    this.totalDeltaBias += deltaBias;\r\n    if (update) {\r\n      this.totalDeltaBias += momentum * this.previousDeltaBias;\r\n      this.bias += this.totalDeltaBias;\r\n      this.previousDeltaBias = this.totalDeltaBias;\r\n      this.totalDeltaBias = 0;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Creates a connection from this node to the given node\r\n   */\r\n  connect: function (target, weight) {\r\n    var connections = [];\r\n    if (typeof target.bias !== 'undefined') { // must be a node!\r\n      if (target === this) {\r\n        // Turn on the self connection by setting the weight\r\n        if (this.connections.self.weight !== 0) {\r\n          if (config.warnings) console.warn('This connection already exists!');\r\n        } else {\r\n          this.connections.self.weight = weight || 1;\r\n        }\r\n        connections.push(this.connections.self);\r\n      } else if (this.isProjectingTo(target)) {\r\n        throw new Error('Already projecting a connection to this node!');\r\n      } else {\r\n        let connection = new Connection(this, target, weight);\r\n        target.connections.in.push(connection);\r\n        this.connections.out.push(connection);\r\n\r\n        connections.push(connection);\r\n      }\r\n    } else { // should be a group\r\n      for (var i = 0; i < target.nodes.length; i++) {\r\n        let connection = new Connection(this, target.nodes[i], weight);\r\n        target.nodes[i].connections.in.push(connection);\r\n        this.connections.out.push(connection);\r\n        target.connections.in.push(connection);\r\n\r\n        connections.push(connection);\r\n      }\r\n    }\r\n    return connections;\r\n  },\r\n\r\n  /**\r\n   * Disconnects this node from the other node\r\n   */\r\n  disconnect: function (node, twosided) {\r\n    if (this === node) {\r\n      this.connections.self.weight = 0;\r\n      return;\r\n    }\r\n\r\n    for (var i = 0; i < this.connections.out.length; i++) {\r\n      let conn = this.connections.out[i];\r\n      if (conn.to === node) {\r\n        this.connections.out.splice(i, 1);\r\n        let j = conn.to.connections.in.indexOf(conn);\r\n        conn.to.connections.in.splice(j, 1);\r\n        if (conn.gater !== null) conn.gater.ungate(conn);\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (twosided) {\r\n      node.disconnect(this);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Make this node gate a connection\r\n   */\r\n  gate: function (connections) {\r\n    if (!Array.isArray(connections)) {\r\n      connections = [connections];\r\n    }\r\n\r\n    for (var i = 0; i < connections.length; i++) {\r\n      var connection = connections[i];\r\n\r\n      this.connections.gated.push(connection);\r\n      connection.gater = this;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Removes the gates from this node from the given connection(s)\r\n   */\r\n  ungate: function (connections) {\r\n    if (!Array.isArray(connections)) {\r\n      connections = [connections];\r\n    }\r\n\r\n    for (var i = connections.length - 1; i >= 0; i--) {\r\n      var connection = connections[i];\r\n\r\n      var index = this.connections.gated.indexOf(connection);\r\n      this.connections.gated.splice(index, 1);\r\n      connection.gater = null;\r\n      connection.gain = 1;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Clear the context of the node\r\n   */\r\n  clear: function () {\r\n    for (var i = 0; i < this.connections.in.length; i++) {\r\n      var connection = this.connections.in[i];\r\n\r\n      connection.elegibility = 0;\r\n      connection.xtrace = {\r\n        nodes: [],\r\n        values: []\r\n      };\r\n    }\r\n\r\n    for (i = 0; i < this.connections.gated.length; i++) {\r\n      let conn = this.connections.gated[i];\r\n      conn.gain = 0;\r\n    }\r\n\r\n    this.error.responsibility = this.error.projected = this.error.gated = 0;\r\n    this.old = this.state = this.activation = 0;\r\n  },\r\n\r\n  /**\r\n   * Mutates the node with the given method\r\n   */\r\n  mutate: function (method) {\r\n    if (typeof method === 'undefined') {\r\n      throw new Error('No mutate method given!');\r\n    } else if (!(method.name in methods.mutation)) {\r\n      throw new Error('This method does not exist!');\r\n    }\r\n\r\n    switch (method) {\r\n      case methods.mutation.MOD_ACTIVATION:\r\n        // Can't be the same squash\r\n        var squash = method.allowed[(method.allowed.indexOf(this.squash) + Math.floor(Math.random() * (method.allowed.length - 1)) + 1) % method.allowed.length];\r\n        this.squash = squash;\r\n        break;\r\n      case methods.mutation.MOD_BIAS:\r\n        var modification = Math.random() * (method.max - method.min) + method.min;\r\n        this.bias += modification;\r\n        break;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Checks if this node is projecting to the given node\r\n   */\r\n  isProjectingTo: function (node) {\r\n    if (node === this && this.connections.self.weight !== 0) return true;\r\n\r\n    for (var i = 0; i < this.connections.out.length; i++) {\r\n      var conn = this.connections.out[i];\r\n      if (conn.to === node) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  },\r\n\r\n  /**\r\n   * Checks if the given node is projecting to this node\r\n   */\r\n  isProjectedBy: function (node) {\r\n    if (node === this && this.connections.self.weight !== 0) return true;\r\n\r\n    for (var i = 0; i < this.connections.in.length; i++) {\r\n      var conn = this.connections.in[i];\r\n      if (conn.from === node) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  },\r\n\r\n  /**\r\n   * Converts the node to a json object\r\n   */\r\n  toJSON: function () {\r\n    var json = {\r\n      bias: this.bias,\r\n      type: this.type,\r\n      squash: this.squash.name,\r\n      mask: this.mask\r\n    };\r\n\r\n    return json;\r\n  }\r\n};\r\n\r\n/**\r\n * Convert a json object to a node\r\n */\r\nNode.fromJSON = function (json) {\r\n  var node = new Node();\r\n  node.bias = json.bias;\r\n  node.type = json.type;\r\n  node.mask = json.mask;\r\n  node.squash = methods.activation[json.squash];\r\n\r\n  return node;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/architecture/node.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/config.js":
/*!**********************************************!*\
  !*** ./node_modules/neataptic/src/config.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                      CONFIG\r\n*******************************************************************************/\r\n\r\n// Config\r\nvar config = {\r\n  warnings: false\r\n};\r\n\r\n/* Export */\r\nmodule.exports = config;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/config.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/activation.js":
/*!**********************************************************!*\
  !*** ./node_modules/neataptic/src/methods/activation.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                  ACTIVATION FUNCTIONS\r\n*******************************************************************************/\r\n\r\n// https://en.wikipedia.org/wiki/Activation_function\r\n// https://stats.stackexchange.com/questions/115258/comprehensive-list-of-activation-functions-in-neural-networks-with-pros-cons\r\nvar activation = {\r\n  LOGISTIC: function (x, derivate) {\r\n    var fx = 1 / (1 + Math.exp(-x));\r\n    if (!derivate) return fx;\r\n    return fx * (1 - fx);\r\n  },\r\n  TANH: function (x, derivate) {\r\n    if (derivate) return 1 - Math.pow(Math.tanh(x), 2);\r\n    return Math.tanh(x);\r\n  },\r\n  IDENTITY: function (x, derivate) {\r\n    return derivate ? 1 : x;\r\n  },\r\n  STEP: function (x, derivate) {\r\n    return derivate ? 0 : x > 0 ? 1 : 0;\r\n  },\r\n  RELU: function (x, derivate) {\r\n    if (derivate) return x > 0 ? 1 : 0;\r\n    return x > 0 ? x : 0;\r\n  },\r\n  SOFTSIGN: function (x, derivate) {\r\n    var d = 1 + Math.abs(x);\r\n    if (derivate) return x / Math.pow(d, 2);\r\n    return x / d;\r\n  },\r\n  SINUSOID: function (x, derivate) {\r\n    if (derivate) return Math.cos(x);\r\n    return Math.sin(x);\r\n  },\r\n  GAUSSIAN: function (x, derivate) {\r\n    var d = Math.exp(-Math.pow(x, 2));\r\n    if (derivate) return -2 * x * d;\r\n    return d;\r\n  },\r\n  BENT_IDENTITY: function (x, derivate) {\r\n    var d = Math.sqrt(Math.pow(x, 2) + 1);\r\n    if (derivate) return x / (2 * d) + 1;\r\n    return (d - 1) / 2 + x;\r\n  },\r\n  BIPOLAR: function (x, derivate) {\r\n    return derivate ? 0 : x > 0 ? 1 : -1;\r\n  },\r\n  BIPOLAR_SIGMOID: function (x, derivate) {\r\n    var d = 2 / (1 + Math.exp(-x)) - 1;\r\n    if (derivate) return 1 / 2 * (1 + d) * (1 - d);\r\n    return d;\r\n  },\r\n  HARD_TANH: function (x, derivate) {\r\n    if (derivate) return x > -1 && x < 1 ? 1 : 0;\r\n    return Math.max(-1, Math.min(1, x));\r\n  },\r\n  ABSOLUTE: function (x, derivate) {\r\n    if (derivate) return x < 0 ? -1 : 1;\r\n    return Math.abs(x);\r\n  },\r\n  INVERSE: function (x, derivate) {\r\n    if (derivate) return -1;\r\n    return 1 - x;\r\n  },\r\n  // https://arxiv.org/pdf/1706.02515.pdf\r\n  SELU: function (x, derivate) {\r\n    var alpha = 1.6732632423543772848170429916717;\r\n    var scale = 1.0507009873554804934193349852946;\r\n    var fx = x > 0 ? x : alpha * Math.exp(x) - alpha;\r\n    if (derivate) { return x > 0 ? scale : (fx + alpha) * scale; }\r\n    return fx * scale;\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = activation;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/activation.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/connection.js":
/*!**********************************************************!*\
  !*** ./node_modules/neataptic/src/methods/connection.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                    CONNECTION\r\n*******************************************************************************/\r\n\r\n// Specifies in what manner two groups are connected\r\nvar connection = {\r\n  ALL_TO_ALL: {\r\n    name: 'OUTPUT'\r\n  },\r\n  ALL_TO_ELSE: {\r\n    name: 'INPUT'\r\n  },\r\n  ONE_TO_ONE: {\r\n    name: 'SELF'\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = connection;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/connection.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/cost.js":
/*!****************************************************!*\
  !*** ./node_modules/neataptic/src/methods/cost.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                    COST FUNCTIONS\r\n*******************************************************************************/\r\n\r\n// https://en.wikipedia.org/wiki/Loss_function\r\nvar cost = {\r\n  // Cross entropy error\r\n  CROSS_ENTROPY: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      // Avoid negative and zero numbers, use 1e-15 http://bit.ly/2p5W29A\r\n      error -= target[i] * Math.log(Math.max(output[i], 1e-15)) + (1 - target[i]) * Math.log(1 - Math.max(output[i], 1e-15));\r\n    }\r\n    return error / output.length;\r\n  },\r\n  // Mean Squared Error\r\n  MSE: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      error += Math.pow(target[i] - output[i], 2);\r\n    }\r\n\r\n    return error / output.length;\r\n  },\r\n  // Binary error\r\n  BINARY: function (target, output) {\r\n    var misses = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      misses += Math.round(target[i] * 2) !== Math.round(output[i] * 2);\r\n    }\r\n\r\n    return misses;\r\n  },\r\n  // Mean Absolute Error\r\n  MAE: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      error += Math.abs(target[i] - output[i]);\r\n    }\r\n\r\n    return error / output.length;\r\n  },\r\n  // Mean Absolute Percentage Error\r\n  MAPE: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      error += Math.abs((output[i] - target[i]) / Math.max(target[i], 1e-15));\r\n    }\r\n\r\n    return error / output.length;\r\n  },\r\n  // Mean Squared Logarithmic Error\r\n  MSLE: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      error += Math.log(Math.max(target[i], 1e-15)) - Math.log(Math.max(output[i], 1e-15));\r\n    }\r\n\r\n    return error;\r\n  },\r\n  // Hinge loss, for classifiers\r\n  HINGE: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      error += Math.max(0, 1 - target[i] * output[i]);\r\n    }\r\n\r\n    return error;\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = cost;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/cost.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/crossover.js":
/*!*********************************************************!*\
  !*** ./node_modules/neataptic/src/methods/crossover.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                      CROSSOVER\r\n*******************************************************************************/\r\n\r\n// https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)\r\nvar crossover = {\r\n  SINGLE_POINT: {\r\n    name: 'SINGLE_POINT',\r\n    config: [0.4]\r\n  },\r\n  TWO_POINT: {\r\n    name: 'TWO_POINT',\r\n    config: [0.4, 0.9]\r\n  },\r\n  UNIFORM: {\r\n    name: 'UNIFORM'\r\n  },\r\n  AVERAGE: {\r\n    name: 'AVERAGE'\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = crossover;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/crossover.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/gating.js":
/*!******************************************************!*\
  !*** ./node_modules/neataptic/src/methods/gating.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                    GATING\r\n*******************************************************************************/\r\n\r\n// Specifies how to gate a connection between two groups of multiple neurons\r\nvar gating = {\r\n  OUTPUT: {\r\n    name: 'OUTPUT'\r\n  },\r\n  INPUT: {\r\n    name: 'INPUT'\r\n  },\r\n  SELF: {\r\n    name: 'SELF'\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = gating;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/gating.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/methods.js":
/*!*******************************************************!*\
  !*** ./node_modules/neataptic/src/methods/methods.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*******************************************************************************\r\n                                  METHODS\r\n*******************************************************************************/\r\n\r\nvar methods = {\r\n  activation: __webpack_require__(/*! ./activation */ \"./node_modules/neataptic/src/methods/activation.js\"),\r\n  mutation: __webpack_require__(/*! ./mutation */ \"./node_modules/neataptic/src/methods/mutation.js\"),\r\n  selection: __webpack_require__(/*! ./selection */ \"./node_modules/neataptic/src/methods/selection.js\"),\r\n  crossover: __webpack_require__(/*! ./crossover */ \"./node_modules/neataptic/src/methods/crossover.js\"),\r\n  cost: __webpack_require__(/*! ./cost */ \"./node_modules/neataptic/src/methods/cost.js\"),\r\n  gating: __webpack_require__(/*! ./gating */ \"./node_modules/neataptic/src/methods/gating.js\"),\r\n  connection: __webpack_require__(/*! ./connection */ \"./node_modules/neataptic/src/methods/connection.js\"),\r\n  rate: __webpack_require__(/*! ./rate */ \"./node_modules/neataptic/src/methods/rate.js\")\r\n};\r\n\r\n/** Export */\r\nmodule.exports = methods;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/methods.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/mutation.js":
/*!********************************************************!*\
  !*** ./node_modules/neataptic/src/methods/mutation.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Import */\r\nvar activation = __webpack_require__(/*! ./activation */ \"./node_modules/neataptic/src/methods/activation.js\");\r\n\r\n/*******************************************************************************\r\n                                      MUTATION\r\n*******************************************************************************/\r\n\r\n// https://en.wikipedia.org/wiki/mutation_(genetic_algorithm)\r\nvar mutation = {\r\n  ADD_NODE: {\r\n    name: 'ADD_NODE'\r\n  },\r\n  SUB_NODE: {\r\n    name: 'SUB_NODE',\r\n    keep_gates: true\r\n  },\r\n  ADD_CONN: {\r\n    name: 'ADD_CONN'\r\n  },\r\n  SUB_CONN: {\r\n    name: 'REMOVE_CONN'\r\n  },\r\n  MOD_WEIGHT: {\r\n    name: 'MOD_WEIGHT',\r\n    min: -1,\r\n    max: 1\r\n  },\r\n  MOD_BIAS: {\r\n    name: 'MOD_BIAS',\r\n    min: -1,\r\n    max: 1\r\n  },\r\n  MOD_ACTIVATION: {\r\n    name: 'MOD_ACTIVATION',\r\n    mutateOutput: true,\r\n    allowed: [\r\n      activation.LOGISTIC,\r\n      activation.TANH,\r\n      activation.RELU,\r\n      activation.IDENTITY,\r\n      activation.STEP,\r\n      activation.SOFTSIGN,\r\n      activation.SINUSOID,\r\n      activation.GAUSSIAN,\r\n      activation.BENT_IDENTITY,\r\n      activation.BIPOLAR,\r\n      activation.BIPOLAR_SIGMOID,\r\n      activation.HARD_TANH,\r\n      activation.ABSOLUTE,\r\n      activation.INVERSE,\r\n      activation.SELU\r\n    ]\r\n  },\r\n  ADD_SELF_CONN: {\r\n    name: 'ADD_SELF_CONN'\r\n  },\r\n  SUB_SELF_CONN: {\r\n    name: 'SUB_SELF_CONN'\r\n  },\r\n  ADD_GATE: {\r\n    name: 'ADD_GATE'\r\n  },\r\n  SUB_GATE: {\r\n    name: 'SUB_GATE'\r\n  },\r\n  ADD_BACK_CONN: {\r\n    name: 'ADD_BACK_CONN'\r\n  },\r\n  SUB_BACK_CONN: {\r\n    name: 'SUB_BACK_CONN'\r\n  },\r\n  SWAP_NODES: {\r\n    name: 'SWAP_NODES',\r\n    mutateOutput: true\r\n  }\r\n};\r\n\r\nmutation.ALL = [\r\n  mutation.ADD_NODE,\r\n  mutation.SUB_NODE,\r\n  mutation.ADD_CONN,\r\n  mutation.SUB_CONN,\r\n  mutation.MOD_WEIGHT,\r\n  mutation.MOD_BIAS,\r\n  mutation.MOD_ACTIVATION,\r\n  mutation.ADD_GATE,\r\n  mutation.SUB_GATE,\r\n  mutation.ADD_SELF_CONN,\r\n  mutation.SUB_SELF_CONN,\r\n  mutation.ADD_BACK_CONN,\r\n  mutation.SUB_BACK_CONN,\r\n  mutation.SWAP_NODES\r\n];\r\n\r\nmutation.FFW = [\r\n  mutation.ADD_NODE,\r\n  mutation.SUB_NODE,\r\n  mutation.ADD_CONN,\r\n  mutation.SUB_CONN,\r\n  mutation.MOD_WEIGHT,\r\n  mutation.MOD_BIAS,\r\n  mutation.MOD_ACTIVATION,\r\n  mutation.SWAP_NODES\r\n];\r\n\r\n/* Export */\r\nmodule.exports = mutation;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/mutation.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/rate.js":
/*!****************************************************!*\
  !*** ./node_modules/neataptic/src/methods/rate.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                      RATE\r\n*******************************************************************************/\r\n\r\n// https://stackoverflow.com/questions/30033096/what-is-lr-policy-in-caffe/30045244\r\nvar rate = {\r\n  FIXED: function () {\r\n    var func = function (baseRate, iteration) { return baseRate; };\r\n    return func;\r\n  },\r\n  STEP: function (gamma, stepSize) {\r\n    gamma = gamma || 0.9;\r\n    stepSize = stepSize || 100;\r\n\r\n    var func = function (baseRate, iteration) {\r\n      return baseRate * Math.pow(gamma, Math.floor(iteration / stepSize));\r\n    };\r\n\r\n    return func;\r\n  },\r\n  EXP: function (gamma) {\r\n    gamma = gamma || 0.999;\r\n\r\n    var func = function (baseRate, iteration) {\r\n      return baseRate * Math.pow(gamma, iteration);\r\n    };\r\n\r\n    return func;\r\n  },\r\n  INV: function (gamma, power) {\r\n    gamma = gamma || 0.001;\r\n    power = power || 2;\r\n\r\n    var func = function (baseRate, iteration) {\r\n      return baseRate * Math.pow(1 + gamma * iteration, -power);\r\n    };\r\n\r\n    return func;\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = rate;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/rate.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/selection.js":
/*!*********************************************************!*\
  !*** ./node_modules/neataptic/src/methods/selection.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                      SELECTION\r\n*******************************************************************************/\r\n\r\n// https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)\r\n\r\nvar selection = {\r\n  FITNESS_PROPORTIONATE: {\r\n    name: 'FITNESS_PROPORTIONATE'\r\n  },\r\n  POWER: {\r\n    name: 'POWER',\r\n    power: 4\r\n  },\r\n  TOURNAMENT: {\r\n    name: 'TOURNAMENT',\r\n    size: 5,\r\n    probability: 0.5\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = selection;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/selection.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/multithreading/multi.js":
/*!************************************************************!*\
  !*** ./node_modules/neataptic/src/multithreading/multi.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*******************************************************************************\r\n                                MULTITHREADING\r\n*******************************************************************************/\r\n\r\nvar multi = {\r\n  /** Workers */\r\n  workers: __webpack_require__(/*! ./workers/workers */ \"./node_modules/neataptic/src/multithreading/workers/workers.js\"),\r\n\r\n  /** Serializes a dataset */\r\n  serializeDataSet: function (dataSet) {\r\n    var serialized = [dataSet[0].input.length, dataSet[0].output.length];\r\n\r\n    for (var i = 0; i < dataSet.length; i++) {\r\n      var j;\r\n      for (j = 0; j < serialized[0]; j++) {\r\n        serialized.push(dataSet[i].input[j]);\r\n      }\r\n      for (j = 0; j < serialized[1]; j++) {\r\n        serialized.push(dataSet[i].output[j]);\r\n      }\r\n    }\r\n\r\n    return serialized;\r\n  },\r\n\r\n  /** Activate a serialized network */\r\n  activateSerializedNetwork: function (input, A, S, data, F) {\r\n    for (var i = 0; i < data[0]; i++) A[i] = input[i];\r\n    for (i = 2; i < data.length; i++) {\r\n      let index = data[i++];\r\n      let bias = data[i++];\r\n      let squash = data[i++];\r\n      let selfweight = data[i++];\r\n      let selfgater = data[i++];\r\n\r\n      S[index] = (selfgater === -1 ? 1 : A[selfgater]) * selfweight * S[index] + bias;\r\n\r\n      while (data[i] !== -2) {\r\n        S[index] += A[data[i++]] * data[i++] * (data[i++] === -1 ? 1 : A[data[i - 1]]);\r\n      }\r\n      A[index] = F[squash](S[index]);\r\n    }\r\n\r\n    var output = [];\r\n    for (i = A.length - data[1]; i < A.length; i++) output.push(A[i]);\r\n    return output;\r\n  },\r\n\r\n  /** Deserializes a dataset to an array of arrays */\r\n  deserializeDataSet: function (serializedSet) {\r\n    var set = [];\r\n\r\n    var sampleSize = serializedSet[0] + serializedSet[1];\r\n    for (var i = 0; i < (serializedSet.length - 2) / sampleSize; i++) {\r\n      let input = [];\r\n      for (var j = 2 + i * sampleSize; j < 2 + i * sampleSize + serializedSet[0]; j++) {\r\n        input.push(serializedSet[j]);\r\n      }\r\n      let output = [];\r\n      for (j = 2 + i * sampleSize + serializedSet[0]; j < 2 + i * sampleSize + sampleSize; j++) {\r\n        output.push(serializedSet[j]);\r\n      }\r\n      set.push(input);\r\n      set.push(output);\r\n    }\r\n\r\n    return set;\r\n  },\r\n\r\n  /** A list of compiled activation functions in a certain order */\r\n  activations: [\r\n    function (x) { return 1 / (1 + Math.exp(-x)); },\r\n    function (x) { return Math.tanh(x); },\r\n    function (x) { return x; },\r\n    function (x) { return x > 0 ? 1 : 0; },\r\n    function (x) { return x > 0 ? x : 0; },\r\n    function (x) { return x / (1 + Math.abs(x)); },\r\n    function (x) { return Math.sin(x); },\r\n    function (x) { return Math.exp(-Math.pow(x, 2)); },\r\n    function (x) { return (Math.sqrt(Math.pow(x, 2) + 1) - 1) / 2 + x; },\r\n    function (x) { return x > 0 ? 1 : -1; },\r\n    function (x) { return 2 / (1 + Math.exp(-x)) - 1; },\r\n    function (x) { return Math.max(-1, Math.min(1, x)); },\r\n    function (x) { return Math.abs(x); },\r\n    function (x) { return 1 - x; },\r\n    function (x) {\r\n      var a = 1.6732632423543772848170429916717;\r\n      return (x > 0 ? x : a * Math.exp(x) - a) * 1.0507009873554804934193349852946;\r\n    }\r\n  ]\r\n};\r\n\r\nmulti.testSerializedSet = function (set, cost, A, S, data, F) {\r\n  // Calculate how much samples are in the set\r\n  var error = 0;\r\n  for (var i = 0; i < set.length; i += 2) {\r\n    let output = multi.activateSerializedNetwork(set[i], A, S, data, F);\r\n    error += cost(set[i + 1], output);\r\n  }\r\n\r\n  return error / (set.length / 2);\r\n};\r\n\r\n/* Export */\r\nfor (var i in multi) {\r\n  module.exports[i] = multi[i];\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/multithreading/multi.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/multithreading/workers/browser/testworker.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/neataptic/src/multithreading/workers/browser/testworker.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\r\nmodule.exports = TestWorker;\r\n\r\n/* Import */\r\nvar multi = __webpack_require__(/*! ../../multi */ \"./node_modules/neataptic/src/multithreading/multi.js\");\r\n\r\n/*******************************************************************************\r\n                                WEBWORKER\r\n*******************************************************************************/\r\n\r\nfunction TestWorker (dataSet, cost) {\r\n  var blob = new Blob([this._createBlobString(cost)]);\r\n  this.url = window.URL.createObjectURL(blob);\r\n  this.worker = new Worker(this.url);\r\n\r\n  var data = { set: new Float64Array(dataSet).buffer };\r\n  this.worker.postMessage(data, [data.set]);\r\n}\r\n\r\nTestWorker.prototype = {\r\n  evaluate: function (network) {\r\n    return new Promise((resolve, reject) => {\r\n      var serialized = network.serialize();\r\n\r\n      var data = {\r\n        activations: new Float64Array(serialized[0]).buffer,\r\n        states: new Float64Array(serialized[1]).buffer,\r\n        conns: new Float64Array(serialized[2]).buffer\r\n      };\r\n\r\n      this.worker.onmessage = function (e) {\r\n        var error = new Float64Array(e.data.buffer)[0];\r\n        resolve(error);\r\n      };\r\n\r\n      this.worker.postMessage(data, [data.activations, data.states, data.conns]);\r\n    });\r\n  },\r\n\r\n  terminate: function () {\r\n    this.worker.terminate();\r\n    window.URL.revokeObjectURL(this.url);\r\n  },\r\n\r\n  _createBlobString: function (cost) {\r\n    var source = `\r\n      var F = [${multi.activations.toString()}];\r\n      var cost = ${cost.toString()};\r\n      var multi = {\r\n        deserializeDataSet: ${multi.deserializeDataSet.toString()},\r\n        testSerializedSet: ${multi.testSerializedSet.toString()},\r\n        activateSerializedNetwork: ${multi.activateSerializedNetwork.toString()}\r\n      };\r\n\r\n      this.onmessage = function (e) {\r\n        if(typeof e.data.set === 'undefined'){\r\n          var A = new Float64Array(e.data.activations);\r\n          var S = new Float64Array(e.data.states);\r\n          var data = new Float64Array(e.data.conns);\r\n\r\n          var error = multi.testSerializedSet(set, cost, A, S, data, F);\r\n\r\n          var answer = { buffer: new Float64Array([error ]).buffer };\r\n          postMessage(answer, [answer.buffer]);\r\n        } else {\r\n          set = multi.deserializeDataSet(new Float64Array(e.data.set));\r\n        }\r\n      };`;\r\n\r\n    return source;\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/multithreading/workers/browser/testworker.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/multithreading/workers/node/testworker.js":
/*!******************************************************************************!*\
  !*** ./node_modules/neataptic/src/multithreading/workers/node/testworker.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__dirname) {/* Export */\r\nmodule.exports = TestWorker;\r\n\r\n/* Import */\r\nvar cp = __webpack_require__(/*! child_process */ 0);\r\nvar path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\r\n\r\n/*******************************************************************************\r\n                                WEBWORKER\r\n*******************************************************************************/\r\n\r\nfunction TestWorker (dataSet, cost) {\r\n  this.worker = cp.fork(path.join(__dirname, '/worker'));\r\n\r\n  this.worker.send({ set: dataSet, cost: cost.name });\r\n}\r\n\r\nTestWorker.prototype = {\r\n  evaluate: function (network) {\r\n    return new Promise((resolve, reject) => {\r\n      var serialized = network.serialize();\r\n\r\n      var data = {\r\n        activations: serialized[0],\r\n        states: serialized[1],\r\n        conns: serialized[2]\r\n      };\r\n\r\n      var _that = this.worker;\r\n      this.worker.on('message', function callback (e) {\r\n        _that.removeListener('message', callback);\r\n        resolve(e);\r\n      });\r\n\r\n      this.worker.send(data);\r\n    });\r\n  },\r\n\r\n  terminate: function () {\r\n    this.worker.kill();\r\n  }\r\n};\r\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/multithreading/workers/node/testworker.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/multithreading/workers/workers.js":
/*!**********************************************************************!*\
  !*** ./node_modules/neataptic/src/multithreading/workers/workers.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*******************************************************************************\r\n                                  WORKERS\r\n*******************************************************************************/\r\n\r\nvar workers = {\r\n  node: {\r\n    TestWorker: __webpack_require__(/*! ./node/testworker */ \"./node_modules/neataptic/src/multithreading/workers/node/testworker.js\")\r\n  },\r\n  browser: {\r\n    TestWorker: __webpack_require__(/*! ./browser/testworker */ \"./node_modules/neataptic/src/multithreading/workers/browser/testworker.js\")\r\n  }\r\n};\r\n\r\n/** Export */\r\nmodule.exports = workers;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/multithreading/workers/workers.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/neat.js":
/*!********************************************!*\
  !*** ./node_modules/neataptic/src/neat.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\r\nmodule.exports = Neat;\r\n\r\n/* Import */\r\nvar Network = __webpack_require__(/*! ./architecture/network */ \"./node_modules/neataptic/src/architecture/network.js\");\r\nvar methods = __webpack_require__(/*! ./methods/methods */ \"./node_modules/neataptic/src/methods/methods.js\");\r\nvar config = __webpack_require__(/*! ./config */ \"./node_modules/neataptic/src/config.js\");\r\n\r\n/* Easier variable naming */\r\nvar selection = methods.selection;\r\n\r\n/*******************************************************************************\r\n                                         NEAT\r\n*******************************************************************************/\r\n\r\nfunction Neat (input, output, fitness, options) {\r\n  this.input = input; // The input size of the networks\r\n  this.output = output; // The output size of the networks\r\n  this.fitness = fitness; // The fitness function to evaluate the networks\r\n\r\n  // Configure options\r\n  options = options || {};\r\n  this.equal = options.equal || false;\r\n  this.clear = options.clear || false;\r\n  this.popsize = options.popsize || 50;\r\n  this.elitism = options.elitism || 0;\r\n  this.provenance = options.provenance || 0;\r\n  this.mutationRate = options.mutationRate || 0.3;\r\n  this.mutationAmount = options.mutationAmount || 1;\r\n\r\n  this.fitnessPopulation = options.fitnessPopulation || false;\r\n\r\n  this.selection = options.selection || methods.selection.POWER;\r\n  this.crossover = options.crossover || [\r\n    methods.crossover.SINGLE_POINT,\r\n    methods.crossover.TWO_POINT,\r\n    methods.crossover.UNIFORM,\r\n    methods.crossover.AVERAGE\r\n  ];\r\n  this.mutation = options.mutation || methods.mutation.FFW;\r\n\r\n  this.template = options.network || false;\r\n\r\n  this.maxNodes = options.maxNodes || Infinity;\r\n  this.maxConns = options.maxConns || Infinity;\r\n  this.maxGates = options.maxGates || Infinity;\r\n\r\n  // Custom mutation selection function if given\r\n  this.selectMutationMethod = typeof options.mutationSelection === 'function' ? options.mutationSelection.bind(this) : this.selectMutationMethod;\r\n\r\n  // Generation counter\r\n  this.generation = 0;\r\n\r\n  // Initialise the genomes\r\n  this.createPool(this.template);\r\n}\r\n\r\nNeat.prototype = {\r\n  /**\r\n   * Create the initial pool of genomes\r\n   */\r\n  createPool: function (network) {\r\n    this.population = [];\r\n\r\n    for (var i = 0; i < this.popsize; i++) {\r\n      var copy;\r\n      if (this.template) {\r\n        copy = Network.fromJSON(network.toJSON());\r\n      } else {\r\n        copy = new Network(this.input, this.output);\r\n      }\r\n      copy.score = undefined;\r\n      this.population.push(copy);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Evaluates, selects, breeds and mutates population\r\n   */\r\n  evolve: async function () {\r\n    // Check if evaluated, sort the population\r\n    if (typeof this.population[this.population.length - 1].score === 'undefined') {\r\n      await this.evaluate();\r\n    }\r\n    this.sort();\r\n\r\n    var fittest = Network.fromJSON(this.population[0].toJSON());\r\n    fittest.score = this.population[0].score;\r\n\r\n    var newPopulation = [];\r\n\r\n    // Elitism\r\n    var elitists = [];\r\n    for (var i = 0; i < this.elitism; i++) {\r\n      elitists.push(this.population[i]);\r\n    }\r\n\r\n    // Provenance\r\n    for (i = 0; i < this.provenance; i++) {\r\n      newPopulation.push(Network.fromJSON(this.template.toJSON()));\r\n    }\r\n\r\n    // Breed the next individuals\r\n    for (i = 0; i < this.popsize - this.elitism - this.provenance; i++) {\r\n      newPopulation.push(this.getOffspring());\r\n    }\r\n\r\n    // Replace the old population with the new population\r\n    this.population = newPopulation;\r\n    this.mutate();\r\n\r\n    this.population.push(...elitists);\r\n\r\n    // Reset the scores\r\n    for (i = 0; i < this.population.length; i++) {\r\n      this.population[i].score = undefined;\r\n    }\r\n\r\n    this.generation++;\r\n\r\n    return fittest;\r\n  },\r\n\r\n  /**\r\n   * Breeds two parents into an offspring, population MUST be surted\r\n   */\r\n  getOffspring: function () {\r\n    var parent1 = this.getParent();\r\n    var parent2 = this.getParent();\r\n\r\n    return Network.crossOver(parent1, parent2, this.equal);\r\n  },\r\n\r\n  /**\r\n   * Selects a random mutation method for a genome according to the parameters\r\n   */\r\n  selectMutationMethod: function (genome) {\r\n    var mutationMethod = this.mutation[Math.floor(Math.random() * this.mutation.length)];\r\n\r\n    if (mutationMethod === methods.mutation.ADD_NODE && genome.nodes.length >= this.maxNodes) {\r\n      if (config.warnings) console.warn('maxNodes exceeded!');\r\n      return;\r\n    }\r\n\r\n    if (mutationMethod === methods.mutation.ADD_CONN && genome.connections.length >= this.maxConns) {\r\n      if (config.warnings) console.warn('maxConns exceeded!');\r\n      return;\r\n    }\r\n\r\n    if (mutationMethod === methods.mutation.ADD_GATE && genome.gates.length >= this.maxGates) {\r\n      if (config.warnings) console.warn('maxGates exceeded!');\r\n      return;\r\n    }\r\n\r\n    return mutationMethod;\r\n  },\r\n\r\n  /**\r\n   * Mutates the given (or current) population\r\n   */\r\n  mutate: function () {\r\n    // Elitist genomes should not be included\r\n    for (var i = 0; i < this.population.length; i++) {\r\n      if (Math.random() <= this.mutationRate) {\r\n        for (var j = 0; j < this.mutationAmount; j++) {\r\n          var mutationMethod = this.selectMutationMethod(this.population[i]);\r\n          this.population[i].mutate(mutationMethod);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Evaluates the current population\r\n   */\r\n  evaluate: async function () {\r\n    var i;\r\n    if (this.fitnessPopulation) {\r\n      if (this.clear) {\r\n        for (i = 0; i < this.population.length; i++) {\r\n          this.population[i].clear();\r\n        }\r\n      }\r\n      await this.fitness(this.population);\r\n    } else {\r\n      for (i = 0; i < this.population.length; i++) {\r\n        var genome = this.population[i];\r\n        if (this.clear) genome.clear();\r\n        genome.score = await this.fitness(genome);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sorts the population by score\r\n   */\r\n  sort: function () {\r\n    this.population.sort(function (a, b) {\r\n      return b.score - a.score;\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Returns the fittest genome of the current population\r\n   */\r\n  getFittest: function () {\r\n    // Check if evaluated\r\n    if (typeof this.population[this.population.length - 1].score === 'undefined') {\r\n      this.evaluate();\r\n    }\r\n    if (this.population[0].score < this.population[1].score) {\r\n      this.sort();\r\n    }\r\n\r\n    return this.population[0];\r\n  },\r\n\r\n  /**\r\n   * Returns the average fitness of the current population\r\n   */\r\n  getAverage: function () {\r\n    if (typeof this.population[this.population.length - 1].score === 'undefined') {\r\n      this.evaluate();\r\n    }\r\n\r\n    var score = 0;\r\n    for (var i = 0; i < this.population.length; i++) {\r\n      score += this.population[i].score;\r\n    }\r\n\r\n    return score / this.population.length;\r\n  },\r\n\r\n  /**\r\n   * Gets a genome based on the selection function\r\n   * @return {Network} genome\r\n   */\r\n  getParent: function () {\r\n    var i;\r\n    switch (this.selection) {\r\n      case selection.POWER:\r\n        if (this.population[0].score < this.population[1].score) this.sort();\r\n\r\n        var index = Math.floor(Math.pow(Math.random(), this.selection.power) * this.population.length);\r\n        return this.population[index];\r\n      case selection.FITNESS_PROPORTIONATE:\r\n        // As negative fitnesses are possible\r\n        // https://stackoverflow.com/questions/16186686/genetic-algorithm-handling-negative-fitness-values\r\n        // this is unnecessarily run for every individual, should be changed\r\n\r\n        var totalFitness = 0;\r\n        var minimalFitness = 0;\r\n        for (i = 0; i < this.population.length; i++) {\r\n          var score = this.population[i].score;\r\n          minimalFitness = score < minimalFitness ? score : minimalFitness;\r\n          totalFitness += score;\r\n        }\r\n\r\n        minimalFitness = Math.abs(minimalFitness);\r\n        totalFitness += minimalFitness * this.population.length;\r\n\r\n        var random = Math.random() * totalFitness;\r\n        var value = 0;\r\n\r\n        for (i = 0; i < this.population.length; i++) {\r\n          let genome = this.population[i];\r\n          value += genome.score + minimalFitness;\r\n          if (random < value) return genome;\r\n        }\r\n\r\n        // if all scores equal, return random genome\r\n        return this.population[Math.floor(Math.random() * this.population.length)];\r\n      case selection.TOURNAMENT:\r\n        if (this.selection.size > this.popsize) {\r\n          throw new Error('Your tournament size should be lower than the population size, please change methods.selection.TOURNAMENT.size');\r\n        }\r\n\r\n        // Create a tournament\r\n        var individuals = [];\r\n        for (i = 0; i < this.selection.size; i++) {\r\n          let random = this.population[Math.floor(Math.random() * this.population.length)];\r\n          individuals.push(random);\r\n        }\r\n\r\n        // Sort the tournament individuals by score\r\n        individuals.sort(function (a, b) {\r\n          return b.score - a.score;\r\n        });\r\n\r\n        // Select an individual\r\n        for (i = 0; i < this.selection.size; i++) {\r\n          if (Math.random() < this.selection.probability || i === this.selection.size - 1) {\r\n            return individuals[i];\r\n          }\r\n        }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Export the current population to a json object\r\n   */\r\n  export: function () {\r\n    var json = [];\r\n    for (var i = 0; i < this.population.length; i++) {\r\n      var genome = this.population[i];\r\n      json.push(genome.toJSON());\r\n    }\r\n\r\n    return json;\r\n  },\r\n\r\n  /**\r\n   * Import population from a json object\r\n   */\r\n  import: function (json) {\r\n    var population = [];\r\n    for (var i = 0; i < json.length; i++) {\r\n      var genome = json[i];\r\n      population.push(Network.fromJSON(genome));\r\n    }\r\n    this.population = population;\r\n    this.popsize = population.length;\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/neat.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/neataptic.js":
/*!*************************************************!*\
  !*** ./node_modules/neataptic/src/neataptic.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var Neataptic = {\r\n  methods: __webpack_require__(/*! ./methods/methods */ \"./node_modules/neataptic/src/methods/methods.js\"),\r\n  Connection: __webpack_require__(/*! ./architecture/connection */ \"./node_modules/neataptic/src/architecture/connection.js\"),\r\n  architect: __webpack_require__(/*! ./architecture/architect */ \"./node_modules/neataptic/src/architecture/architect.js\"),\r\n  Network: __webpack_require__(/*! ./architecture/network */ \"./node_modules/neataptic/src/architecture/network.js\"),\r\n  config: __webpack_require__(/*! ./config */ \"./node_modules/neataptic/src/config.js\"),\r\n  Group: __webpack_require__(/*! ./architecture/group */ \"./node_modules/neataptic/src/architecture/group.js\"),\r\n  Layer: __webpack_require__(/*! ./architecture/layer */ \"./node_modules/neataptic/src/architecture/layer.js\"),\r\n  Node: __webpack_require__(/*! ./architecture/node */ \"./node_modules/neataptic/src/architecture/node.js\"),\r\n  Neat: __webpack_require__(/*! ./neat */ \"./node_modules/neataptic/src/neat.js\"),\r\n  multi: __webpack_require__(/*! ./multithreading/multi */ \"./node_modules/neataptic/src/multithreading/multi.js\")\r\n};\r\n\r\n// CommonJS & AMD\r\nif (true) {\r\n  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () { return Neataptic; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n}\r\n\r\n// Node.js\r\nif (true && module.exports) {\r\n  module.exports = Neataptic;\r\n}\r\n\r\n// Browser\r\nif (typeof window === 'object') {\r\n  (function () {\r\n    var old = window['neataptic'];\r\n    Neataptic.ninja = function () {\r\n      window['neataptic'] = old;\r\n      return Neataptic;\r\n    };\r\n  })();\r\n\r\n  window['neataptic'] = Neataptic;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/neataptic.js?");

/***/ }),

/***/ "./node_modules/os-browserify/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/os-browserify/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\nexports.homedir = function () {\n\treturn '/'\n};\n\n\n//# sourceURL=webpack:///./node_modules/os-browserify/browser.js?");

/***/ }),

/***/ "./node_modules/particle-filter/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/particle-filter/lib/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = particleFilter;\r\n\r\nfunction nextDouble(maxValue, minValue) {\r\n    var max = maxValue || 1,\r\n        min = minValue || 0,\r\n        randomValue = Math.random();\r\n    if (!min) {\r\n        return randomValue * max;\r\n    }\r\n    return (0.5 - randomValue) * (max - min);\r\n}\r\n\r\nfunction uniformDistribution(maxValue) {\r\n    this.maxValue = maxValue;\r\n}\r\n\r\nuniformDistribution.prototype.generate = function () {\r\n    return nextDouble(this.maxValue);\r\n}\r\n\r\nfunction featureParticle(state, weight, variance) {\r\n    var defaultVariance = 50;\r\n\r\n    this.variance = variance || defaultVariance;\r\n    this.weight = weight || 0;\r\n    this.state = state.slice();\r\n};\r\n\r\nfeatureParticle.prototype.diffuse = function () {\r\n    var state = this.state,\r\n        variance = this.variance;\r\n\r\n    for (var i = 0, l = state.length; i < l; i++) {\r\n        state[i] += nextDouble(variance, -variance);\r\n    }\r\n};\r\n\r\nfeatureParticle.prototype.clone = function () {\r\n    return new featureParticle(this.state.slice(), this.weight);\r\n};\r\n\r\nfunction particleFilter(particlesNumber, variablesNumber, distributionSize) {\r\n\r\n    var particlesNumber = particlesNumber || 100,\r\n        variablesNumber = variablesNumber || 1,\r\n        distributionSize = distributionSize || 10;\r\n\r\n    this.particles = [];\r\n    this.epsilon = Number.MIN_VALUE;\r\n    this.variance = 0;\r\n    this.distributions = [];\r\n\r\n    for (var i = 0; i < variablesNumber; i++) {\r\n        this.distributions.push(new uniformDistribution(distributionSize));\r\n    }\r\n\r\n    this.generateParticles(particlesNumber, this.distributions);\r\n};\r\n\r\nparticleFilter.prototype.generateParticles = function (numberOfParticles, distributions) {\r\n    var nDim = distributions.length,\r\n        particles = this.particles;\r\n    for (var i = 0; i < numberOfParticles; i++) {\r\n        var randomParam = [];\r\n        for (var dim = 0; dim < nDim; dim++) {\r\n            randomParam[dim] = distributions[dim].generate();\r\n        }\r\n        particles.push(new featureParticle(randomParam, 1 / numberOfParticles));\r\n    }\r\n};\r\n\r\nparticleFilter.prototype.resample = function (sampleCount) {\r\n    var resampledParticles = [],\r\n        filteredParticles = this.filter(this.particles.length);\r\n\r\n    for (var i = 0, l = filteredParticles.length; i < l; i++) {\r\n        var newPart = filteredParticles[i].clone();\r\n        newPart.weight = 1 / this.particles.length;\r\n        resampledParticles.push(newPart);\r\n    }\r\n\r\n    return resampledParticles;\r\n};\r\n\r\nparticleFilter.prototype.filter = function (sampleCount) {\r\n    var cumulativeWeights = [],\r\n        cumSumInd = 0,\r\n        cumSum = 0,\r\n        particles = this.particles;\r\n\r\n    for (var i = 0, l = particles.length; i < l; i++) {\r\n        var p = particles[i];\r\n        cumSum += p.weight;\r\n        cumulativeWeights[cumSumInd++] = cumSum;\r\n    }\r\n\r\n    var maxCumWeight = cumulativeWeights[particles.length - 1],\r\n        minCumWeight = cumulativeWeights[0];\r\n\r\n    var filteredParticles = [];\r\n\r\n    for (var i = 0; i < sampleCount; i++) {\r\n        var randWeight = minCumWeight + nextDouble(1) * (maxCumWeight - minCumWeight),\r\n            particleInd = 0;\r\n        while (cumulativeWeights[particleInd] < randWeight) {\r\n            particleInd++;\r\n        }\r\n\r\n        var p = particles[particleInd];\r\n        filteredParticles.push(p);\r\n    }\r\n\r\n    return filteredParticles;\r\n};\r\n\r\nparticleFilter.prototype.predict = function (effectiveMinRatio) {\r\n    var newParticles,\r\n        particles = this.particles,\r\n        effectiveRatio = this.effectiveLength(this.normalWeights()) / this.particles.length;\r\n    if (effectiveRatio > this.epsilon &&\r\n        effectiveRatio < effectiveMinRatio) {\r\n        newParticles = this.resample(particles.length);\r\n    }\r\n    else {\r\n        newParticles = [];\r\n        for (var i = 0, l = particles.length; i < l; i++) {\r\n            var cloned = particles[i].clone();\r\n            cloned.diffuse();\r\n            newParticles.push(cloned);\r\n        }\r\n    }\r\n\r\n    this.particles = newParticles;\r\n};\r\n\r\nparticleFilter.prototype.effectiveLength = function (weights) {\r\n    var sumSqr = this.epsilon,\r\n        sum = 0;\r\n    for (var i = 0, l = weights.length; i < l; i++) {\r\n        var w = weights[i];\r\n        sumSqr += w * w;\r\n        sum += w;\r\n    }\r\n\r\n    return sum / sumSqr;\r\n};\r\n\r\nparticleFilter.prototype.normalWeights = function () {\r\n    var particles = this.particles,\r\n        normalizedWeights = [],\r\n        weightSum = this.epsilon;\r\n    for (var i = 0, l = particles.length; i < l; i++) {\r\n        weightSum += particles[i].weight;\r\n    }\r\n\r\n    for (var i = 0, l = particles.length; i < l; i++) {\r\n        normalizedWeights.push(particles[i].weight / weightSum);\r\n    }\r\n\r\n    return normalizedWeights;\r\n};\r\n\r\nparticleFilter.prototype.update = function (measure, effectiveMinRatio) {\r\n\r\n    this.predict(effectiveMinRatio || 0.9);\r\n\r\n    var particles = this.particles,\r\n        maxWeightParticle;\r\n\r\n    for (var i = 0, l = particles.length; i < l; i++) {\r\n        var particle = particles[i],\r\n            state = particle.state,\r\n            sumSqr = 0;\r\n\r\n        for (var j = 0, sl = state.length; j < sl; j++) {\r\n            var diff = measure[j] - state[j];\r\n            sumSqr += diff * diff;\r\n        }\r\n\r\n        var weight = 1 / Math.sqrt(sumSqr);\r\n        particle.weight = weight;\r\n\r\n        if (!maxWeightParticle || maxWeightParticle.weight < weight) {\r\n            maxWeightParticle = particle;\r\n        }\r\n    }\r\n\r\n    this.result = maxWeightParticle;\r\n    return maxWeightParticle;\r\n};\r\n\r\n\n\n//# sourceURL=webpack:///./node_modules/particle-filter/lib/index.js?");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./predictor/predictAction.js":
/*!************************************!*\
  !*** ./predictor/predictAction.js ***!
  \************************************/
/*! exports provided: predictAction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"predictAction\", function() { return predictAction; });\n/* harmony import */ var neataptic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neataptic */ \"./node_modules/neataptic/src/neataptic.js\");\n/* harmony import */ var neataptic__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(neataptic__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nconst network = neataptic__WEBPACK_IMPORTED_MODULE_0__[\"Network\"].fromJSON({\"nodes\":[{\"bias\":-0.00922889326123806,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":0},{\"bias\":-0.005620919455469095,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":1},{\"bias\":0.032504915091412345,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":2},{\"bias\":-0.09100792285891313,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":3},{\"bias\":-0.038323137212522784,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":4},{\"bias\":-0.05828544577253365,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":5},{\"bias\":-0.04675652397034971,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":6},{\"bias\":-0.043037660549714876,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":7},{\"bias\":-0.053722483609238175,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":8},{\"bias\":0.04548199173245138,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":9},{\"bias\":0.9996088193838739,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":10},{\"bias\":1.00209169789,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":11},{\"bias\":1.0798538029632125,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":12},{\"bias\":1.0579061102896994,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":13},{\"bias\":1.022041012696968,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":14},{\"bias\":1.053722366091309,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":15},{\"bias\":1.0732285819768341,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":16},{\"bias\":1.0001229325578052,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":17},{\"bias\":1.0003445118914422,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":18},{\"bias\":0.9580603620593698,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":19},{\"bias\":1.0000529441760921,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":20},{\"bias\":1.0006029596435764,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":21},{\"bias\":1.0138297643052774,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":22},{\"bias\":1.1317611223198758,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":23},{\"bias\":0.996503722689759,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":24},{\"bias\":1.0103377585472684,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":25},{\"bias\":1.007170491622635,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":26},{\"bias\":1.0012326009167605,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":27},{\"bias\":0.9999973144281539,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":28},{\"bias\":1.0631806618121844,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":29},{\"bias\":-0.06801228885132349,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":30},{\"bias\":0.0773859194661859,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":31},{\"bias\":-0.0021063866360795536,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":32},{\"bias\":-0.5634261801073294,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":33},{\"bias\":0.04049372187942344,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":34},{\"bias\":-0.48002146570450854,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":35},{\"bias\":-0.4315617864556963,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":36},{\"bias\":-0.019865394134102304,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":37},{\"bias\":0.08412454074998339,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":38},{\"bias\":-0.06215435824372412,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":39},{\"bias\":1.0000331711858106,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":40},{\"bias\":0.8564299321616587,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":41},{\"bias\":1.0511721226429898,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":42},{\"bias\":0.9406355641404118,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":43},{\"bias\":0.709571901575319,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":44},{\"bias\":0.9674380674978912,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":45},{\"bias\":0.9065815545204796,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":46},{\"bias\":0.6860337193853381,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":47},{\"bias\":0.999731245991407,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":48},{\"bias\":1.1208882659465718,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":49},{\"bias\":0.37705218961855314,\"type\":\"output\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":50}],\"connections\":[{\"weight\":1,\"from\":30,\"to\":30,\"gater\":20},{\"weight\":1,\"from\":31,\"to\":31,\"gater\":21},{\"weight\":1,\"from\":32,\"to\":32,\"gater\":22},{\"weight\":1,\"from\":33,\"to\":33,\"gater\":23},{\"weight\":1,\"from\":34,\"to\":34,\"gater\":24},{\"weight\":1,\"from\":35,\"to\":35,\"gater\":25},{\"weight\":1,\"from\":36,\"to\":36,\"gater\":26},{\"weight\":1,\"from\":37,\"to\":37,\"gater\":27},{\"weight\":1,\"from\":38,\"to\":38,\"gater\":28},{\"weight\":1,\"from\":39,\"to\":39,\"gater\":29},{\"weight\":-0.060191097792790714,\"from\":0,\"to\":30,\"gater\":10},{\"weight\":0.07399700887622301,\"from\":0,\"to\":31,\"gater\":11},{\"weight\":-0.30677528373964563,\"from\":0,\"to\":32,\"gater\":12},{\"weight\":-0.5076291129214775,\"from\":0,\"to\":33,\"gater\":13},{\"weight\":0.049068154255902136,\"from\":0,\"to\":34,\"gater\":14},{\"weight\":0.40105590278431386,\"from\":0,\"to\":35,\"gater\":15},{\"weight\":-0.011125796212322053,\"from\":0,\"to\":36,\"gater\":16},{\"weight\":0.013205930626863859,\"from\":0,\"to\":37,\"gater\":17},{\"weight\":-0.052159858764792094,\"from\":0,\"to\":38,\"gater\":18},{\"weight\":0.008082178738679837,\"from\":0,\"to\":39,\"gater\":19},{\"weight\":-0.008973770918813944,\"from\":0,\"to\":10,\"gater\":null},{\"weight\":-0.008512107681070441,\"from\":0,\"to\":11,\"gater\":null},{\"weight\":-0.23703100418558312,\"from\":0,\"to\":12,\"gater\":null},{\"weight\":-0.19115323233907117,\"from\":0,\"to\":13,\"gater\":null},{\"weight\":0.27110064737288553,\"from\":0,\"to\":14,\"gater\":null},{\"weight\":-0.28544579631805367,\"from\":0,\"to\":15,\"gater\":null},{\"weight\":0.15175676265482335,\"from\":0,\"to\":16,\"gater\":null},{\"weight\":0.011335196630381973,\"from\":0,\"to\":17,\"gater\":null},{\"weight\":0.0457430432728192,\"from\":0,\"to\":18,\"gater\":null},{\"weight\":-0.20201045104000062,\"from\":0,\"to\":19,\"gater\":null},{\"weight\":0.0750591528293745,\"from\":0,\"to\":40,\"gater\":null},{\"weight\":0.18394133274822427,\"from\":0,\"to\":41,\"gater\":null},{\"weight\":-0.31995503613007287,\"from\":0,\"to\":42,\"gater\":null},{\"weight\":0.559668020630776,\"from\":0,\"to\":43,\"gater\":null},{\"weight\":0.13371068435636388,\"from\":0,\"to\":44,\"gater\":null},{\"weight\":0.31013758946810316,\"from\":0,\"to\":45,\"gater\":null},{\"weight\":0.17220175797154308,\"from\":0,\"to\":46,\"gater\":null},{\"weight\":0.15283017136829397,\"from\":0,\"to\":47,\"gater\":null},{\"weight\":-0.057706224320413425,\"from\":0,\"to\":48,\"gater\":null},{\"weight\":-0.08016358219812382,\"from\":0,\"to\":49,\"gater\":null},{\"weight\":-0.07792413781569284,\"from\":0,\"to\":20,\"gater\":null},{\"weight\":0.04031256224015923,\"from\":0,\"to\":21,\"gater\":null},{\"weight\":0.14291990656995143,\"from\":0,\"to\":22,\"gater\":null},{\"weight\":-0.5086552580323205,\"from\":0,\"to\":23,\"gater\":null},{\"weight\":0.13540188660400537,\"from\":0,\"to\":24,\"gater\":null},{\"weight\":-0.30370820448107116,\"from\":0,\"to\":25,\"gater\":null},{\"weight\":-0.18901428122157468,\"from\":0,\"to\":26,\"gater\":null},{\"weight\":0.06955954918201782,\"from\":0,\"to\":27,\"gater\":null},{\"weight\":0.054416732947147856,\"from\":0,\"to\":28,\"gater\":null},{\"weight\":-0.23762913070934327,\"from\":0,\"to\":29,\"gater\":null},{\"weight\":-0.11106847694675691,\"from\":0,\"to\":50,\"gater\":null},{\"weight\":0.02158443582836773,\"from\":1,\"to\":30,\"gater\":10},{\"weight\":0.06863875572376633,\"from\":1,\"to\":31,\"gater\":11},{\"weight\":0.033703715782246825,\"from\":1,\"to\":32,\"gater\":12},{\"weight\":0.16393120953557846,\"from\":1,\"to\":33,\"gater\":13},{\"weight\":-0.01858685429736778,\"from\":1,\"to\":34,\"gater\":14},{\"weight\":-0.5724085605631007,\"from\":1,\"to\":35,\"gater\":15},{\"weight\":0.6073101954008531,\"from\":1,\"to\":36,\"gater\":16},{\"weight\":0.1558937910642412,\"from\":1,\"to\":37,\"gater\":17},{\"weight\":-0.015360857053934227,\"from\":1,\"to\":38,\"gater\":18},{\"weight\":0.20451104151602728,\"from\":1,\"to\":39,\"gater\":19},{\"weight\":-0.028832574239345383,\"from\":1,\"to\":10,\"gater\":null},{\"weight\":0.10283748914420408,\"from\":1,\"to\":11,\"gater\":null},{\"weight\":-0.0555797899519411,\"from\":1,\"to\":12,\"gater\":null},{\"weight\":0.5292779182278785,\"from\":1,\"to\":13,\"gater\":null},{\"weight\":-0.12096503651723026,\"from\":1,\"to\":14,\"gater\":null},{\"weight\":-0.0015783441937747673,\"from\":1,\"to\":15,\"gater\":null},{\"weight\":-0.28145636640685034,\"from\":1,\"to\":16,\"gater\":null},{\"weight\":-0.01507014183932092,\"from\":1,\"to\":17,\"gater\":null},{\"weight\":-0.03594958631376604,\"from\":1,\"to\":18,\"gater\":null},{\"weight\":0.08436894979077371,\"from\":1,\"to\":19,\"gater\":null},{\"weight\":-0.007285566761166537,\"from\":1,\"to\":40,\"gater\":null},{\"weight\":-0.6398463745205869,\"from\":1,\"to\":41,\"gater\":null},{\"weight\":-0.3600879295788318,\"from\":1,\"to\":42,\"gater\":null},{\"weight\":-0.4385054349056962,\"from\":1,\"to\":43,\"gater\":null},{\"weight\":-0.1432719240025067,\"from\":1,\"to\":44,\"gater\":null},{\"weight\":0.7514193158538861,\"from\":1,\"to\":45,\"gater\":null},{\"weight\":0.11931407275955318,\"from\":1,\"to\":46,\"gater\":null},{\"weight\":-0.1546778691543078,\"from\":1,\"to\":47,\"gater\":null},{\"weight\":0.04074658321021817,\"from\":1,\"to\":48,\"gater\":null},{\"weight\":-0.32150803376433357,\"from\":1,\"to\":49,\"gater\":null},{\"weight\":0.05518502567595125,\"from\":1,\"to\":20,\"gater\":null},{\"weight\":0.020731035757073666,\"from\":1,\"to\":21,\"gater\":null},{\"weight\":-0.3298208288506908,\"from\":1,\"to\":22,\"gater\":null},{\"weight\":-0.006941658909187438,\"from\":1,\"to\":23,\"gater\":null},{\"weight\":0.008614453782906399,\"from\":1,\"to\":24,\"gater\":null},{\"weight\":-0.19698887572101206,\"from\":1,\"to\":25,\"gater\":null},{\"weight\":-0.2654245297165701,\"from\":1,\"to\":26,\"gater\":null},{\"weight\":0.023380192181930392,\"from\":1,\"to\":27,\"gater\":null},{\"weight\":0.09794529591417754,\"from\":1,\"to\":28,\"gater\":null},{\"weight\":0.35378147279888117,\"from\":1,\"to\":29,\"gater\":null},{\"weight\":0.03287453122495557,\"from\":1,\"to\":50,\"gater\":null},{\"weight\":-0.03717810534691705,\"from\":2,\"to\":30,\"gater\":10},{\"weight\":0.09010207383431675,\"from\":2,\"to\":31,\"gater\":11},{\"weight\":0.2191242661491997,\"from\":2,\"to\":32,\"gater\":12},{\"weight\":0.15618766264091077,\"from\":2,\"to\":33,\"gater\":13},{\"weight\":0.1012762707278259,\"from\":2,\"to\":34,\"gater\":14},{\"weight\":0.5245493354987926,\"from\":2,\"to\":35,\"gater\":15},{\"weight\":0.13898692984038583,\"from\":2,\"to\":36,\"gater\":16},{\"weight\":0.1013506286850504,\"from\":2,\"to\":37,\"gater\":17},{\"weight\":-0.08711845043416691,\"from\":2,\"to\":38,\"gater\":18},{\"weight\":0.2449682893165771,\"from\":2,\"to\":39,\"gater\":19},{\"weight\":0.08637554996446692,\"from\":2,\"to\":10,\"gater\":null},{\"weight\":-0.006604418976544007,\"from\":2,\"to\":11,\"gater\":null},{\"weight\":0.32293974767903644,\"from\":2,\"to\":12,\"gater\":null},{\"weight\":0.5573877319424894,\"from\":2,\"to\":13,\"gater\":null},{\"weight\":-0.17131648930707444,\"from\":2,\"to\":14,\"gater\":null},{\"weight\":0.04071481008450371,\"from\":2,\"to\":15,\"gater\":null},{\"weight\":-0.046651285480756165,\"from\":2,\"to\":16,\"gater\":null},{\"weight\":0.1184672376216021,\"from\":2,\"to\":17,\"gater\":null},{\"weight\":0.001904192090014431,\"from\":2,\"to\":18,\"gater\":null},{\"weight\":0.22071542718483614,\"from\":2,\"to\":19,\"gater\":null},{\"weight\":0.02244451373900096,\"from\":2,\"to\":40,\"gater\":null},{\"weight\":0.2201890867134619,\"from\":2,\"to\":41,\"gater\":null},{\"weight\":0.05231096507866549,\"from\":2,\"to\":42,\"gater\":null},{\"weight\":0.2124990731208568,\"from\":2,\"to\":43,\"gater\":null},{\"weight\":-0.35567744022461,\"from\":2,\"to\":44,\"gater\":null},{\"weight\":-0.304519043754936,\"from\":2,\"to\":45,\"gater\":null},{\"weight\":-0.05508475337283447,\"from\":2,\"to\":46,\"gater\":null},{\"weight\":-0.34465213317891186,\"from\":2,\"to\":47,\"gater\":null},{\"weight\":-0.060345719342175995,\"from\":2,\"to\":48,\"gater\":null},{\"weight\":-0.16635660156110044,\"from\":2,\"to\":49,\"gater\":null},{\"weight\":0.10543878798910286,\"from\":2,\"to\":20,\"gater\":null},{\"weight\":0.0020678969502954934,\"from\":2,\"to\":21,\"gater\":null},{\"weight\":-0.24167397371684934,\"from\":2,\"to\":22,\"gater\":null},{\"weight\":-0.631078688745955,\"from\":2,\"to\":23,\"gater\":null},{\"weight\":0.11268527961868466,\"from\":2,\"to\":24,\"gater\":null},{\"weight\":-0.3282807669975003,\"from\":2,\"to\":25,\"gater\":null},{\"weight\":-0.14736372406834405,\"from\":2,\"to\":26,\"gater\":null},{\"weight\":-0.03943614331705337,\"from\":2,\"to\":27,\"gater\":null},{\"weight\":0.014136400838834004,\"from\":2,\"to\":28,\"gater\":null},{\"weight\":0.3041892453878172,\"from\":2,\"to\":29,\"gater\":null},{\"weight\":-0.11944765714804148,\"from\":2,\"to\":50,\"gater\":null},{\"weight\":0.028001736625470043,\"from\":3,\"to\":30,\"gater\":10},{\"weight\":0.13117501732082423,\"from\":3,\"to\":31,\"gater\":11},{\"weight\":0.6981166829519909,\"from\":3,\"to\":32,\"gater\":12},{\"weight\":0.2586011560898195,\"from\":3,\"to\":33,\"gater\":13},{\"weight\":0.03314022375263637,\"from\":3,\"to\":34,\"gater\":14},{\"weight\":0.5507260145210292,\"from\":3,\"to\":35,\"gater\":15},{\"weight\":-0.7625307301803426,\"from\":3,\"to\":36,\"gater\":16},{\"weight\":-0.013257701667187474,\"from\":3,\"to\":37,\"gater\":17},{\"weight\":0.018744585225548883,\"from\":3,\"to\":38,\"gater\":18},{\"weight\":0.1470189170977691,\"from\":3,\"to\":39,\"gater\":19},{\"weight\":-0.016937305699983293,\"from\":3,\"to\":10,\"gater\":null},{\"weight\":-0.04107038679049054,\"from\":3,\"to\":11,\"gater\":null},{\"weight\":-0.06909214562148593,\"from\":3,\"to\":12,\"gater\":null},{\"weight\":-0.1821430798985757,\"from\":3,\"to\":13,\"gater\":null},{\"weight\":0.016590920157084056,\"from\":3,\"to\":14,\"gater\":null},{\"weight\":-0.21425924364699556,\"from\":3,\"to\":15,\"gater\":null},{\"weight\":0.05290369564903573,\"from\":3,\"to\":16,\"gater\":null},{\"weight\":-0.05046760336998682,\"from\":3,\"to\":17,\"gater\":null},{\"weight\":-0.04602813545652209,\"from\":3,\"to\":18,\"gater\":null},{\"weight\":0.2852525280151405,\"from\":3,\"to\":19,\"gater\":null},{\"weight\":0.040040890521638915,\"from\":3,\"to\":40,\"gater\":null},{\"weight\":0.45451693584738795,\"from\":3,\"to\":41,\"gater\":null},{\"weight\":0.46198376791040097,\"from\":3,\"to\":42,\"gater\":null},{\"weight\":-0.003227214056669197,\"from\":3,\"to\":43,\"gater\":null},{\"weight\":-0.23799968303233301,\"from\":3,\"to\":44,\"gater\":null},{\"weight\":-0.8040475386739592,\"from\":3,\"to\":45,\"gater\":null},{\"weight\":-0.28585513540493224,\"from\":3,\"to\":46,\"gater\":null},{\"weight\":-0.21604972074612094,\"from\":3,\"to\":47,\"gater\":null},{\"weight\":0.04435289832003907,\"from\":3,\"to\":48,\"gater\":null},{\"weight\":0.17597742180440232,\"from\":3,\"to\":49,\"gater\":null},{\"weight\":-0.009749592134129837,\"from\":3,\"to\":20,\"gater\":null},{\"weight\":-0.039846644586301806,\"from\":3,\"to\":21,\"gater\":null},{\"weight\":-0.09580383883237485,\"from\":3,\"to\":22,\"gater\":null},{\"weight\":-0.060796466754753586,\"from\":3,\"to\":23,\"gater\":null},{\"weight\":-0.1861430261915091,\"from\":3,\"to\":24,\"gater\":null},{\"weight\":-0.11824473409196692,\"from\":3,\"to\":25,\"gater\":null},{\"weight\":-0.23896456182744538,\"from\":3,\"to\":26,\"gater\":null},{\"weight\":0.017077976094653075,\"from\":3,\"to\":27,\"gater\":null},{\"weight\":-0.06930352499472058,\"from\":3,\"to\":28,\"gater\":null},{\"weight\":-0.12931859234661022,\"from\":3,\"to\":29,\"gater\":null},{\"weight\":0.09275263035162283,\"from\":3,\"to\":50,\"gater\":null},{\"weight\":-0.044549540034527824,\"from\":4,\"to\":30,\"gater\":10},{\"weight\":-0.03401116082389882,\"from\":4,\"to\":31,\"gater\":11},{\"weight\":-0.19188905697284975,\"from\":4,\"to\":32,\"gater\":12},{\"weight\":0.4310441420236008,\"from\":4,\"to\":33,\"gater\":13},{\"weight\":0.10066658807130102,\"from\":4,\"to\":34,\"gater\":14},{\"weight\":-0.975690455017405,\"from\":4,\"to\":35,\"gater\":15},{\"weight\":0.40733469204177536,\"from\":4,\"to\":36,\"gater\":16},{\"weight\":-0.02542341257818275,\"from\":4,\"to\":37,\"gater\":17},{\"weight\":-0.0419837683018074,\"from\":4,\"to\":38,\"gater\":18},{\"weight\":-0.0037841108259249975,\"from\":4,\"to\":39,\"gater\":19},{\"weight\":-0.05523508755712354,\"from\":4,\"to\":10,\"gater\":null},{\"weight\":0.05775681813597021,\"from\":4,\"to\":11,\"gater\":null},{\"weight\":0.19330447145465768,\"from\":4,\"to\":12,\"gater\":null},{\"weight\":0.10076783355230051,\"from\":4,\"to\":13,\"gater\":null},{\"weight\":0.3733241262634749,\"from\":4,\"to\":14,\"gater\":null},{\"weight\":0.8206109856772305,\"from\":4,\"to\":15,\"gater\":null},{\"weight\":0.0798466877550727,\"from\":4,\"to\":16,\"gater\":null},{\"weight\":-0.07746720930556439,\"from\":4,\"to\":17,\"gater\":null},{\"weight\":0.022888741902954077,\"from\":4,\"to\":18,\"gater\":null},{\"weight\":-0.016393985123451617,\"from\":4,\"to\":19,\"gater\":null},{\"weight\":0.07852758801381401,\"from\":4,\"to\":40,\"gater\":null},{\"weight\":0.09228376718066686,\"from\":4,\"to\":41,\"gater\":null},{\"weight\":-0.33554902050040214,\"from\":4,\"to\":42,\"gater\":null},{\"weight\":0.10201293654424379,\"from\":4,\"to\":43,\"gater\":null},{\"weight\":1.0115974695574725,\"from\":4,\"to\":44,\"gater\":null},{\"weight\":0.028936165678664836,\"from\":4,\"to\":45,\"gater\":null},{\"weight\":0.1295740638442343,\"from\":4,\"to\":46,\"gater\":null},{\"weight\":1.0480187383897321,\"from\":4,\"to\":47,\"gater\":null},{\"weight\":0.08552614256665347,\"from\":4,\"to\":48,\"gater\":null},{\"weight\":-0.08259348573079675,\"from\":4,\"to\":49,\"gater\":null},{\"weight\":-0.03505190926781267,\"from\":4,\"to\":20,\"gater\":null},{\"weight\":0.004037979651019202,\"from\":4,\"to\":21,\"gater\":null},{\"weight\":0.11266249083905473,\"from\":4,\"to\":22,\"gater\":null},{\"weight\":-0.0941295534709068,\"from\":4,\"to\":23,\"gater\":null},{\"weight\":-0.011258031843626585,\"from\":4,\"to\":24,\"gater\":null},{\"weight\":-0.13822747798280477,\"from\":4,\"to\":25,\"gater\":null},{\"weight\":-0.1560411765441779,\"from\":4,\"to\":26,\"gater\":null},{\"weight\":-0.019887333462989053,\"from\":4,\"to\":27,\"gater\":null},{\"weight\":0.08328283029048418,\"from\":4,\"to\":28,\"gater\":null},{\"weight\":-0.13683122710602572,\"from\":4,\"to\":29,\"gater\":null},{\"weight\":-0.20047948879916883,\"from\":4,\"to\":50,\"gater\":null},{\"weight\":0.009405209662230761,\"from\":5,\"to\":30,\"gater\":10},{\"weight\":-0.0081227482055558,\"from\":5,\"to\":31,\"gater\":11},{\"weight\":-0.04440783902342742,\"from\":5,\"to\":32,\"gater\":12},{\"weight\":-1.0502155292625595,\"from\":5,\"to\":33,\"gater\":13},{\"weight\":0.09340944439914423,\"from\":5,\"to\":34,\"gater\":14},{\"weight\":-0.2534815655513479,\"from\":5,\"to\":35,\"gater\":15},{\"weight\":-0.24935475636978244,\"from\":5,\"to\":36,\"gater\":16},{\"weight\":0.10178794063095488,\"from\":5,\"to\":37,\"gater\":17},{\"weight\":-0.06338741465702687,\"from\":5,\"to\":38,\"gater\":18},{\"weight\":-0.004418411239974998,\"from\":5,\"to\":39,\"gater\":19},{\"weight\":0.011321354780099152,\"from\":5,\"to\":10,\"gater\":null},{\"weight\":0.06599227615435031,\"from\":5,\"to\":11,\"gater\":null},{\"weight\":-0.08944562519766755,\"from\":5,\"to\":12,\"gater\":null},{\"weight\":0.08219589241753272,\"from\":5,\"to\":13,\"gater\":null},{\"weight\":-0.04993036669992953,\"from\":5,\"to\":14,\"gater\":null},{\"weight\":-0.2916889062354522,\"from\":5,\"to\":15,\"gater\":null},{\"weight\":0.340169889327369,\"from\":5,\"to\":16,\"gater\":null},{\"weight\":0.0646206290364833,\"from\":5,\"to\":17,\"gater\":null},{\"weight\":0.06005546456987594,\"from\":5,\"to\":18,\"gater\":null},{\"weight\":-0.2842545648019645,\"from\":5,\"to\":19,\"gater\":null},{\"weight\":0.058103844894066045,\"from\":5,\"to\":40,\"gater\":null},{\"weight\":-0.05654871689965078,\"from\":5,\"to\":41,\"gater\":null},{\"weight\":0.13600183307003738,\"from\":5,\"to\":42,\"gater\":null},{\"weight\":0.146077823171107,\"from\":5,\"to\":43,\"gater\":null},{\"weight\":0.0635994259075785,\"from\":5,\"to\":44,\"gater\":null},{\"weight\":-0.013415258563504829,\"from\":5,\"to\":45,\"gater\":null},{\"weight\":0.061174968830430075,\"from\":5,\"to\":46,\"gater\":null},{\"weight\":0.02542602766164263,\"from\":5,\"to\":47,\"gater\":null},{\"weight\":-0.05748684304871429,\"from\":5,\"to\":48,\"gater\":null},{\"weight\":0.4287818932576261,\"from\":5,\"to\":49,\"gater\":null},{\"weight\":0.0793798776131446,\"from\":5,\"to\":20,\"gater\":null},{\"weight\":-0.021996698335963117,\"from\":5,\"to\":21,\"gater\":null},{\"weight\":0.2996218812083777,\"from\":5,\"to\":22,\"gater\":null},{\"weight\":0.2393678940283427,\"from\":5,\"to\":23,\"gater\":null},{\"weight\":-0.0938998433442277,\"from\":5,\"to\":24,\"gater\":null},{\"weight\":-0.19389559870724749,\"from\":5,\"to\":25,\"gater\":null},{\"weight\":-0.12223833390747874,\"from\":5,\"to\":26,\"gater\":null},{\"weight\":0.08398580229322984,\"from\":5,\"to\":27,\"gater\":null},{\"weight\":0.05439746263320801,\"from\":5,\"to\":28,\"gater\":null},{\"weight\":-0.18400534512121872,\"from\":5,\"to\":29,\"gater\":null},{\"weight\":0.10288649147723047,\"from\":5,\"to\":50,\"gater\":null},{\"weight\":-0.0735294478992343,\"from\":6,\"to\":30,\"gater\":10},{\"weight\":0.017035855144800417,\"from\":6,\"to\":31,\"gater\":11},{\"weight\":-0.21211271392377468,\"from\":6,\"to\":32,\"gater\":12},{\"weight\":0.7357538329142285,\"from\":6,\"to\":33,\"gater\":13},{\"weight\":0.03153165731450119,\"from\":6,\"to\":34,\"gater\":14},{\"weight\":0.4957921351601243,\"from\":6,\"to\":35,\"gater\":15},{\"weight\":-0.0013336540917364445,\"from\":6,\"to\":36,\"gater\":16},{\"weight\":-0.029273666099336036,\"from\":6,\"to\":37,\"gater\":17},{\"weight\":-0.06476269582648247,\"from\":6,\"to\":38,\"gater\":18},{\"weight\":0.10952852624185187,\"from\":6,\"to\":39,\"gater\":19},{\"weight\":0.015249527730826174,\"from\":6,\"to\":10,\"gater\":null},{\"weight\":-0.06319835945421592,\"from\":6,\"to\":11,\"gater\":null},{\"weight\":0.12702311020812299,\"from\":6,\"to\":12,\"gater\":null},{\"weight\":-0.5607612485869075,\"from\":6,\"to\":13,\"gater\":null},{\"weight\":-0.014888503205220904,\"from\":6,\"to\":14,\"gater\":null},{\"weight\":-0.010386050201056627,\"from\":6,\"to\":15,\"gater\":null},{\"weight\":0.06759575361726028,\"from\":6,\"to\":16,\"gater\":null},{\"weight\":-0.08425413818440333,\"from\":6,\"to\":17,\"gater\":null},{\"weight\":0.017353544704874924,\"from\":6,\"to\":18,\"gater\":null},{\"weight\":-0.21889556374454902,\"from\":6,\"to\":19,\"gater\":null},{\"weight\":0.0639011723166602,\"from\":6,\"to\":40,\"gater\":null},{\"weight\":-0.1504138090196436,\"from\":6,\"to\":41,\"gater\":null},{\"weight\":0.26344619945226416,\"from\":6,\"to\":42,\"gater\":null},{\"weight\":-0.45940304528801806,\"from\":6,\"to\":43,\"gater\":null},{\"weight\":0.10274267713557407,\"from\":6,\"to\":44,\"gater\":null},{\"weight\":-0.17377429627329338,\"from\":6,\"to\":45,\"gater\":null},{\"weight\":0.03339266829462424,\"from\":6,\"to\":46,\"gater\":null},{\"weight\":0.10733453295975626,\"from\":6,\"to\":47,\"gater\":null},{\"weight\":-0.06811013472704336,\"from\":6,\"to\":48,\"gater\":null},{\"weight\":0.3027300913835616,\"from\":6,\"to\":49,\"gater\":null},{\"weight\":-0.07647788696785457,\"from\":6,\"to\":20,\"gater\":null},{\"weight\":0.09748795721636591,\"from\":6,\"to\":21,\"gater\":null},{\"weight\":0.08457191684883643,\"from\":6,\"to\":22,\"gater\":null},{\"weight\":0.21823871027288302,\"from\":6,\"to\":23,\"gater\":null},{\"weight\":0.08119991575907093,\"from\":6,\"to\":24,\"gater\":null},{\"weight\":-0.21376954858851271,\"from\":6,\"to\":25,\"gater\":null},{\"weight\":-0.19260278686193522,\"from\":6,\"to\":26,\"gater\":null},{\"weight\":-0.05716496432558612,\"from\":6,\"to\":27,\"gater\":null},{\"weight\":-0.01260196512713575,\"from\":6,\"to\":28,\"gater\":null},{\"weight\":-0.28011409469437565,\"from\":6,\"to\":29,\"gater\":null},{\"weight\":-0.015954798434962825,\"from\":6,\"to\":50,\"gater\":null},{\"weight\":0.049451430466626235,\"from\":7,\"to\":30,\"gater\":10},{\"weight\":0.03949567371145356,\"from\":7,\"to\":31,\"gater\":11},{\"weight\":0.00987571668798527,\"from\":7,\"to\":32,\"gater\":12},{\"weight\":-0.32566263763224856,\"from\":7,\"to\":33,\"gater\":13},{\"weight\":-0.004558814818816513,\"from\":7,\"to\":34,\"gater\":14},{\"weight\":0.4954091069296098,\"from\":7,\"to\":35,\"gater\":15},{\"weight\":-0.41938518305992195,\"from\":7,\"to\":36,\"gater\":16},{\"weight\":-0.01889433316555648,\"from\":7,\"to\":37,\"gater\":17},{\"weight\":-0.0013254414636758992,\"from\":7,\"to\":38,\"gater\":18},{\"weight\":0.07612732483608516,\"from\":7,\"to\":39,\"gater\":19},{\"weight\":-0.0764809934233615,\"from\":7,\"to\":10,\"gater\":null},{\"weight\":0.03563193630797348,\"from\":7,\"to\":11,\"gater\":null},{\"weight\":-0.2309191024358985,\"from\":7,\"to\":12,\"gater\":null},{\"weight\":0.1639747820902544,\"from\":7,\"to\":13,\"gater\":null},{\"weight\":-0.08162863010308677,\"from\":7,\"to\":14,\"gater\":null},{\"weight\":0.22100064345960513,\"from\":7,\"to\":15,\"gater\":null},{\"weight\":-0.11527615419057653,\"from\":7,\"to\":16,\"gater\":null},{\"weight\":-0.06689453740678467,\"from\":7,\"to\":17,\"gater\":null},{\"weight\":0.03192152739881463,\"from\":7,\"to\":18,\"gater\":null},{\"weight\":-0.34412648774657295,\"from\":7,\"to\":19,\"gater\":null},{\"weight\":0.07423203093311083,\"from\":7,\"to\":40,\"gater\":null},{\"weight\":0.033328853010994273,\"from\":7,\"to\":41,\"gater\":null},{\"weight\":0.10715468926221856,\"from\":7,\"to\":42,\"gater\":null},{\"weight\":0.060439109343097194,\"from\":7,\"to\":43,\"gater\":null},{\"weight\":-0.3530551270012489,\"from\":7,\"to\":44,\"gater\":null},{\"weight\":0.5571329270096419,\"from\":7,\"to\":45,\"gater\":null},{\"weight\":-0.06268425418870713,\"from\":7,\"to\":46,\"gater\":null},{\"weight\":-0.3319901129612088,\"from\":7,\"to\":47,\"gater\":null},{\"weight\":0.07727013283532591,\"from\":7,\"to\":48,\"gater\":null},{\"weight\":0.25067655816188167,\"from\":7,\"to\":49,\"gater\":null},{\"weight\":0.10435138443558382,\"from\":7,\"to\":20,\"gater\":null},{\"weight\":-0.060742340789930176,\"from\":7,\"to\":21,\"gater\":null},{\"weight\":-0.020879882266106535,\"from\":7,\"to\":22,\"gater\":null},{\"weight\":0.7084394397438396,\"from\":7,\"to\":23,\"gater\":null},{\"weight\":0.05145987199585616,\"from\":7,\"to\":24,\"gater\":null},{\"weight\":-0.25979698932049455,\"from\":7,\"to\":25,\"gater\":null},{\"weight\":-0.1800734638771324,\"from\":7,\"to\":26,\"gater\":null},{\"weight\":0.012589356672918628,\"from\":7,\"to\":27,\"gater\":null},{\"weight\":-0.004538407783286822,\"from\":7,\"to\":28,\"gater\":null},{\"weight\":0.17071022980230666,\"from\":7,\"to\":29,\"gater\":null},{\"weight\":0.0494859612587377,\"from\":7,\"to\":50,\"gater\":null},{\"weight\":-0.08695040071186604,\"from\":8,\"to\":30,\"gater\":10},{\"weight\":0.04431787024616616,\"from\":8,\"to\":31,\"gater\":11},{\"weight\":0.39198827165077116,\"from\":8,\"to\":32,\"gater\":12},{\"weight\":-0.27937988145228876,\"from\":8,\"to\":33,\"gater\":13},{\"weight\":-0.004931516880658044,\"from\":8,\"to\":34,\"gater\":14},{\"weight\":-0.17529361549198713,\"from\":8,\"to\":35,\"gater\":15},{\"weight\":0.41027618332455806,\"from\":8,\"to\":36,\"gater\":16},{\"weight\":-0.01747963352068139,\"from\":8,\"to\":37,\"gater\":17},{\"weight\":-0.062241937480818424,\"from\":8,\"to\":38,\"gater\":18},{\"weight\":0.10060692024574656,\"from\":8,\"to\":39,\"gater\":19},{\"weight\":0.060144050594062,\"from\":8,\"to\":10,\"gater\":null},{\"weight\":-0.029599467201786408,\"from\":8,\"to\":11,\"gater\":null},{\"weight\":-0.14117793091035905,\"from\":8,\"to\":12,\"gater\":null},{\"weight\":0.00017701077277129676,\"from\":8,\"to\":13,\"gater\":null},{\"weight\":-0.07297102024840035,\"from\":8,\"to\":14,\"gater\":null},{\"weight\":0.07867205867503795,\"from\":8,\"to\":15,\"gater\":null},{\"weight\":0.048543126005545986,\"from\":8,\"to\":16,\"gater\":null},{\"weight\":0.03157746235057539,\"from\":8,\"to\":17,\"gater\":null},{\"weight\":-0.049914319207846634,\"from\":8,\"to\":18,\"gater\":null},{\"weight\":0.13936999782059004,\"from\":8,\"to\":19,\"gater\":null},{\"weight\":0.06710829873693741,\"from\":8,\"to\":40,\"gater\":null},{\"weight\":0.2725929007103123,\"from\":8,\"to\":41,\"gater\":null},{\"weight\":0.2891666979583322,\"from\":8,\"to\":42,\"gater\":null},{\"weight\":0.10250387107748066,\"from\":8,\"to\":43,\"gater\":null},{\"weight\":0.38220995541653485,\"from\":8,\"to\":44,\"gater\":null},{\"weight\":-0.623138569726358,\"from\":8,\"to\":45,\"gater\":null},{\"weight\":-0.1805651130470342,\"from\":8,\"to\":46,\"gater\":null},{\"weight\":0.4117452867389283,\"from\":8,\"to\":47,\"gater\":null},{\"weight\":-0.07092283521380754,\"from\":8,\"to\":48,\"gater\":null},{\"weight\":-0.08478456540390578,\"from\":8,\"to\":49,\"gater\":null},{\"weight\":-0.0770629669417515,\"from\":8,\"to\":20,\"gater\":null},{\"weight\":0.05123664136672433,\"from\":8,\"to\":21,\"gater\":null},{\"weight\":0.14124270606937323,\"from\":8,\"to\":22,\"gater\":null},{\"weight\":-0.1077053467925963,\"from\":8,\"to\":23,\"gater\":null},{\"weight\":0.09904994805117304,\"from\":8,\"to\":24,\"gater\":null},{\"weight\":-0.08242092408524009,\"from\":8,\"to\":25,\"gater\":null},{\"weight\":-0.14535394631689066,\"from\":8,\"to\":26,\"gater\":null},{\"weight\":0.043853322706771926,\"from\":8,\"to\":27,\"gater\":null},{\"weight\":-0.031700094428389836,\"from\":8,\"to\":28,\"gater\":null},{\"weight\":-0.1417707392757979,\"from\":8,\"to\":29,\"gater\":null},{\"weight\":-0.16107629210760707,\"from\":8,\"to\":50,\"gater\":null},{\"weight\":-0.003922489181616219,\"from\":9,\"to\":30,\"gater\":10},{\"weight\":-0.050058932563891496,\"from\":9,\"to\":31,\"gater\":11},{\"weight\":-0.5001054301600268,\"from\":9,\"to\":32,\"gater\":12},{\"weight\":0.2772068710920389,\"from\":9,\"to\":33,\"gater\":13},{\"weight\":0.04795891098202622,\"from\":9,\"to\":34,\"gater\":14},{\"weight\":-0.012890023790711337,\"from\":9,\"to\":35,\"gater\":15},{\"weight\":0.13887606915801534,\"from\":9,\"to\":36,\"gater\":16},{\"weight\":0.007368066093387224,\"from\":9,\"to\":37,\"gater\":17},{\"weight\":0.007444104577052907,\"from\":9,\"to\":38,\"gater\":18},{\"weight\":0.09401752121275855,\"from\":9,\"to\":39,\"gater\":19},{\"weight\":0.038655187658581024,\"from\":9,\"to\":10,\"gater\":null},{\"weight\":-0.029940550138573552,\"from\":9,\"to\":11,\"gater\":null},{\"weight\":0.06151893083115839,\"from\":9,\"to\":12,\"gater\":null},{\"weight\":0.2234790597608724,\"from\":9,\"to\":13,\"gater\":null},{\"weight\":0.07950078080606578,\"from\":9,\"to\":14,\"gater\":null},{\"weight\":-0.07455862112953925,\"from\":9,\"to\":15,\"gater\":null},{\"weight\":0.016112534278010147,\"from\":9,\"to\":16,\"gater\":null},{\"weight\":0.053639091492534964,\"from\":9,\"to\":17,\"gater\":null},{\"weight\":-0.03543212585906832,\"from\":9,\"to\":18,\"gater\":null},{\"weight\":-0.04004705318287066,\"from\":9,\"to\":19,\"gater\":null},{\"weight\":-0.06962334212616988,\"from\":9,\"to\":40,\"gater\":null},{\"weight\":-0.14473338261037957,\"from\":9,\"to\":41,\"gater\":null},{\"weight\":0.3137139107366364,\"from\":9,\"to\":42,\"gater\":null},{\"weight\":0.04228306922558975,\"from\":9,\"to\":43,\"gater\":null},{\"weight\":-0.14679297382031162,\"from\":9,\"to\":44,\"gater\":null},{\"weight\":0.7415934606993894,\"from\":9,\"to\":45,\"gater\":null},{\"weight\":0.24524018239680256,\"from\":9,\"to\":46,\"gater\":null},{\"weight\":-0.16814548840782573,\"from\":9,\"to\":47,\"gater\":null},{\"weight\":0.05654022016727203,\"from\":9,\"to\":48,\"gater\":null},{\"weight\":-0.2316348133084764,\"from\":9,\"to\":49,\"gater\":null},{\"weight\":-0.008984805426922898,\"from\":9,\"to\":20,\"gater\":null},{\"weight\":-0.000230635083514924,\"from\":9,\"to\":21,\"gater\":null},{\"weight\":-0.22564750771184403,\"from\":9,\"to\":22,\"gater\":null},{\"weight\":0.4441922194175365,\"from\":9,\"to\":23,\"gater\":null},{\"weight\":0.17866047132459698,\"from\":9,\"to\":24,\"gater\":null},{\"weight\":-0.12965611948059644,\"from\":9,\"to\":25,\"gater\":null},{\"weight\":0.14456402858067244,\"from\":9,\"to\":26,\"gater\":null},{\"weight\":0.05740796802924603,\"from\":9,\"to\":27,\"gater\":null},{\"weight\":-0.033541642940455016,\"from\":9,\"to\":28,\"gater\":null},{\"weight\":-0.04004949551142196,\"from\":9,\"to\":29,\"gater\":null},{\"weight\":-0.32313230504394935,\"from\":9,\"to\":50,\"gater\":null},{\"weight\":-0.0683621774612158,\"from\":30,\"to\":10,\"gater\":null},{\"weight\":-0.059613939507304675,\"from\":30,\"to\":11,\"gater\":null},{\"weight\":0.07985510081832775,\"from\":30,\"to\":12,\"gater\":null},{\"weight\":-0.06514920632175447,\"from\":30,\"to\":13,\"gater\":null},{\"weight\":-0.09306643157931097,\"from\":30,\"to\":14,\"gater\":null},{\"weight\":0.09147954708854855,\"from\":30,\"to\":15,\"gater\":null},{\"weight\":0.006976131419843927,\"from\":30,\"to\":16,\"gater\":null},{\"weight\":-0.06521692125421852,\"from\":30,\"to\":17,\"gater\":null},{\"weight\":-0.008222576043685113,\"from\":30,\"to\":18,\"gater\":null},{\"weight\":0.008936406575089728,\"from\":30,\"to\":19,\"gater\":null},{\"weight\":-0.04778862188334455,\"from\":30,\"to\":20,\"gater\":null},{\"weight\":0.025006229821998925,\"from\":30,\"to\":21,\"gater\":null},{\"weight\":0.062221368836740516,\"from\":30,\"to\":22,\"gater\":null},{\"weight\":0.07498800436562877,\"from\":30,\"to\":23,\"gater\":null},{\"weight\":0.010733431369043006,\"from\":30,\"to\":24,\"gater\":null},{\"weight\":-0.07355382094263556,\"from\":30,\"to\":25,\"gater\":null},{\"weight\":0.07326307919972161,\"from\":30,\"to\":26,\"gater\":null},{\"weight\":-0.06764715538752679,\"from\":30,\"to\":27,\"gater\":null},{\"weight\":-0.04004432765276563,\"from\":30,\"to\":28,\"gater\":null},{\"weight\":-0.06530060066681256,\"from\":30,\"to\":29,\"gater\":null},{\"weight\":-0.05709224209532237,\"from\":30,\"to\":40,\"gater\":null},{\"weight\":0.03801318540363747,\"from\":30,\"to\":41,\"gater\":null},{\"weight\":-0.045125527895564475,\"from\":30,\"to\":42,\"gater\":null},{\"weight\":-0.04282458945940772,\"from\":30,\"to\":43,\"gater\":null},{\"weight\":0.0799318027176858,\"from\":30,\"to\":44,\"gater\":null},{\"weight\":0.06027540317489369,\"from\":30,\"to\":45,\"gater\":null},{\"weight\":-0.024068869107493868,\"from\":30,\"to\":46,\"gater\":null},{\"weight\":-0.027429797981256235,\"from\":30,\"to\":47,\"gater\":null},{\"weight\":0.013178650305441925,\"from\":30,\"to\":48,\"gater\":null},{\"weight\":0.0637729087442704,\"from\":30,\"to\":49,\"gater\":null},{\"weight\":0.08644240104509596,\"from\":30,\"to\":50,\"gater\":40},{\"weight\":-0.006034997737904278,\"from\":31,\"to\":10,\"gater\":null},{\"weight\":0.05458431102995631,\"from\":31,\"to\":11,\"gater\":null},{\"weight\":-0.13962847359108793,\"from\":31,\"to\":12,\"gater\":null},{\"weight\":-0.013872952042821152,\"from\":31,\"to\":13,\"gater\":null},{\"weight\":-0.09193423489954451,\"from\":31,\"to\":14,\"gater\":null},{\"weight\":-0.006208548617905737,\"from\":31,\"to\":15,\"gater\":null},{\"weight\":0.09008672715540421,\"from\":31,\"to\":16,\"gater\":null},{\"weight\":-0.06386951998231247,\"from\":31,\"to\":17,\"gater\":null},{\"weight\":0.0685702131257418,\"from\":31,\"to\":18,\"gater\":null},{\"weight\":-0.014213837663346073,\"from\":31,\"to\":19,\"gater\":null},{\"weight\":0.09483586697398327,\"from\":31,\"to\":20,\"gater\":null},{\"weight\":-0.011383157798598236,\"from\":31,\"to\":21,\"gater\":null},{\"weight\":0.04103471075547212,\"from\":31,\"to\":22,\"gater\":null},{\"weight\":-0.012109608195499217,\"from\":31,\"to\":23,\"gater\":null},{\"weight\":0.023639555664931543,\"from\":31,\"to\":24,\"gater\":null},{\"weight\":-0.06385936342171604,\"from\":31,\"to\":25,\"gater\":null},{\"weight\":-0.030012057359385166,\"from\":31,\"to\":26,\"gater\":null},{\"weight\":0.00972696611295869,\"from\":31,\"to\":27,\"gater\":null},{\"weight\":-0.043439630969027206,\"from\":31,\"to\":28,\"gater\":null},{\"weight\":0.06607665099983455,\"from\":31,\"to\":29,\"gater\":null},{\"weight\":-0.03050603260360215,\"from\":31,\"to\":40,\"gater\":null},{\"weight\":-0.12501138862535588,\"from\":31,\"to\":41,\"gater\":null},{\"weight\":0.06963570702899856,\"from\":31,\"to\":42,\"gater\":null},{\"weight\":0.0016988305185957047,\"from\":31,\"to\":43,\"gater\":null},{\"weight\":-0.19324125053240732,\"from\":31,\"to\":44,\"gater\":null},{\"weight\":-0.05317056537721863,\"from\":31,\"to\":45,\"gater\":null},{\"weight\":-0.11742253145963823,\"from\":31,\"to\":46,\"gater\":null},{\"weight\":-0.3908399061617972,\"from\":31,\"to\":47,\"gater\":null},{\"weight\":0.0557486304373021,\"from\":31,\"to\":48,\"gater\":null},{\"weight\":0.08915173994115642,\"from\":31,\"to\":49,\"gater\":null},{\"weight\":0.9792690464775257,\"from\":31,\"to\":50,\"gater\":41},{\"weight\":0.016067822877794746,\"from\":32,\"to\":10,\"gater\":null},{\"weight\":0.03757344799923473,\"from\":32,\"to\":11,\"gater\":null},{\"weight\":-0.025877292996545537,\"from\":32,\"to\":12,\"gater\":null},{\"weight\":0.04201879967897641,\"from\":32,\"to\":13,\"gater\":null},{\"weight\":0.004448564099319714,\"from\":32,\"to\":14,\"gater\":null},{\"weight\":0.09157774611510608,\"from\":32,\"to\":15,\"gater\":null},{\"weight\":-0.03879470102466536,\"from\":32,\"to\":16,\"gater\":null},{\"weight\":0.02474382300638949,\"from\":32,\"to\":17,\"gater\":null},{\"weight\":0.05990866684896762,\"from\":32,\"to\":18,\"gater\":null},{\"weight\":0.13137653554314227,\"from\":32,\"to\":19,\"gater\":null},{\"weight\":-0.07713052948694236,\"from\":32,\"to\":20,\"gater\":null},{\"weight\":-0.09487374155102685,\"from\":32,\"to\":21,\"gater\":null},{\"weight\":0.016594984256987393,\"from\":32,\"to\":22,\"gater\":null},{\"weight\":-0.13754836417360136,\"from\":32,\"to\":23,\"gater\":null},{\"weight\":0.05701024400199151,\"from\":32,\"to\":24,\"gater\":null},{\"weight\":0.022374725004361804,\"from\":32,\"to\":25,\"gater\":null},{\"weight\":0.052224880001380175,\"from\":32,\"to\":26,\"gater\":null},{\"weight\":-0.023581860380783852,\"from\":32,\"to\":27,\"gater\":null},{\"weight\":0.08865634569215698,\"from\":32,\"to\":28,\"gater\":null},{\"weight\":0.12703838680056861,\"from\":32,\"to\":29,\"gater\":null},{\"weight\":0.01541843500937803,\"from\":32,\"to\":40,\"gater\":null},{\"weight\":0.017437174123724378,\"from\":32,\"to\":41,\"gater\":null},{\"weight\":0.06763430173017834,\"from\":32,\"to\":42,\"gater\":null},{\"weight\":-0.13698748046476864,\"from\":32,\"to\":43,\"gater\":null},{\"weight\":-0.18833517299615543,\"from\":32,\"to\":44,\"gater\":null},{\"weight\":-0.25405093830891856,\"from\":32,\"to\":45,\"gater\":null},{\"weight\":-0.12338099229357524,\"from\":32,\"to\":46,\"gater\":null},{\"weight\":-0.1281106541426816,\"from\":32,\"to\":47,\"gater\":null},{\"weight\":0.038443680740301855,\"from\":32,\"to\":48,\"gater\":null},{\"weight\":-0.00807778933062477,\"from\":32,\"to\":49,\"gater\":null},{\"weight\":-1.586734101667247,\"from\":32,\"to\":50,\"gater\":42},{\"weight\":-0.005541417037960713,\"from\":33,\"to\":10,\"gater\":null},{\"weight\":-0.04353250570317605,\"from\":33,\"to\":11,\"gater\":null},{\"weight\":0.0504579456614425,\"from\":33,\"to\":12,\"gater\":null},{\"weight\":-0.021441529035564805,\"from\":33,\"to\":13,\"gater\":null},{\"weight\":-0.054434937890209645,\"from\":33,\"to\":14,\"gater\":null},{\"weight\":-0.07751288135809864,\"from\":33,\"to\":15,\"gater\":null},{\"weight\":0.0017078160907100413,\"from\":33,\"to\":16,\"gater\":null},{\"weight\":0.008528008613234444,\"from\":33,\"to\":17,\"gater\":null},{\"weight\":0.05464589313892318,\"from\":33,\"to\":18,\"gater\":null},{\"weight\":-0.023730574684522412,\"from\":33,\"to\":19,\"gater\":null},{\"weight\":-0.005199267549161658,\"from\":33,\"to\":20,\"gater\":null},{\"weight\":0.05037219928431978,\"from\":33,\"to\":21,\"gater\":null},{\"weight\":0.07171659621915075,\"from\":33,\"to\":22,\"gater\":null},{\"weight\":-0.0645710749113516,\"from\":33,\"to\":23,\"gater\":null},{\"weight\":0.0060486315013379525,\"from\":33,\"to\":24,\"gater\":null},{\"weight\":-0.04317825122434004,\"from\":33,\"to\":25,\"gater\":null},{\"weight\":-0.06379115315527198,\"from\":33,\"to\":26,\"gater\":null},{\"weight\":0.04184182216954697,\"from\":33,\"to\":27,\"gater\":null},{\"weight\":0.015089093014474619,\"from\":33,\"to\":28,\"gater\":null},{\"weight\":-0.07315408417313768,\"from\":33,\"to\":29,\"gater\":null},{\"weight\":-0.09479801613290206,\"from\":33,\"to\":40,\"gater\":null},{\"weight\":-0.046703152185485694,\"from\":33,\"to\":41,\"gater\":null},{\"weight\":-0.00797071175606161,\"from\":33,\"to\":42,\"gater\":null},{\"weight\":-0.007826930538674151,\"from\":33,\"to\":43,\"gater\":null},{\"weight\":-0.07241021058445696,\"from\":33,\"to\":44,\"gater\":null},{\"weight\":0.1734354956589495,\"from\":33,\"to\":45,\"gater\":null},{\"weight\":-0.10097789349147364,\"from\":33,\"to\":46,\"gater\":null},{\"weight\":-0.10115085522348578,\"from\":33,\"to\":47,\"gater\":null},{\"weight\":-0.02324103880617634,\"from\":33,\"to\":48,\"gater\":null},{\"weight\":-0.011087751220366593,\"from\":33,\"to\":49,\"gater\":null},{\"weight\":2.2763835043455436,\"from\":33,\"to\":50,\"gater\":43},{\"weight\":0.09689929890582441,\"from\":34,\"to\":10,\"gater\":null},{\"weight\":-0.05579276687896759,\"from\":34,\"to\":11,\"gater\":null},{\"weight\":0.04816083543064295,\"from\":34,\"to\":12,\"gater\":null},{\"weight\":-0.017609952797933707,\"from\":34,\"to\":13,\"gater\":null},{\"weight\":-0.03332622480119778,\"from\":34,\"to\":14,\"gater\":null},{\"weight\":-0.0897497046533321,\"from\":34,\"to\":15,\"gater\":null},{\"weight\":0.008858482991835344,\"from\":34,\"to\":16,\"gater\":null},{\"weight\":0.058935665921063224,\"from\":34,\"to\":17,\"gater\":null},{\"weight\":0.09564713716161895,\"from\":34,\"to\":18,\"gater\":null},{\"weight\":0.13967577091567526,\"from\":34,\"to\":19,\"gater\":null},{\"weight\":-0.05883014160290643,\"from\":34,\"to\":20,\"gater\":null},{\"weight\":0.01455109032157454,\"from\":34,\"to\":21,\"gater\":null},{\"weight\":0.03078437484547066,\"from\":34,\"to\":22,\"gater\":null},{\"weight\":0.015109792996160257,\"from\":34,\"to\":23,\"gater\":null},{\"weight\":-0.007880573204239608,\"from\":34,\"to\":24,\"gater\":null},{\"weight\":-0.15464731131926138,\"from\":34,\"to\":25,\"gater\":null},{\"weight\":0.03285776597562154,\"from\":34,\"to\":26,\"gater\":null},{\"weight\":-0.025587697845922838,\"from\":34,\"to\":27,\"gater\":null},{\"weight\":-0.04179651730324166,\"from\":34,\"to\":28,\"gater\":null},{\"weight\":0.10433054141044966,\"from\":34,\"to\":29,\"gater\":null},{\"weight\":-0.026231210280168914,\"from\":34,\"to\":40,\"gater\":null},{\"weight\":-0.1079518934836616,\"from\":34,\"to\":41,\"gater\":null},{\"weight\":0.08623420564265596,\"from\":34,\"to\":42,\"gater\":null},{\"weight\":-0.008616842178829671,\"from\":34,\"to\":43,\"gater\":null},{\"weight\":-0.3748374132631234,\"from\":34,\"to\":44,\"gater\":null},{\"weight\":-0.05541110722060048,\"from\":34,\"to\":45,\"gater\":null},{\"weight\":-0.032371609854503804,\"from\":34,\"to\":46,\"gater\":null},{\"weight\":-0.2525223825412981,\"from\":34,\"to\":47,\"gater\":null},{\"weight\":-0.03514056927722768,\"from\":34,\"to\":48,\"gater\":null},{\"weight\":0.05411009312797428,\"from\":34,\"to\":49,\"gater\":null},{\"weight\":1.3679114674085846,\"from\":34,\"to\":50,\"gater\":44},{\"weight\":0.031835833346893334,\"from\":35,\"to\":10,\"gater\":null},{\"weight\":0.0016366831898492697,\"from\":35,\"to\":11,\"gater\":null},{\"weight\":0.02389010832771919,\"from\":35,\"to\":12,\"gater\":null},{\"weight\":-0.07743646568963955,\"from\":35,\"to\":13,\"gater\":null},{\"weight\":-0.04072705282703206,\"from\":35,\"to\":14,\"gater\":null},{\"weight\":-0.11002848012836944,\"from\":35,\"to\":15,\"gater\":null},{\"weight\":-0.0368408931463782,\"from\":35,\"to\":16,\"gater\":null},{\"weight\":0.05703535831897732,\"from\":35,\"to\":17,\"gater\":null},{\"weight\":-0.09137821917093512,\"from\":35,\"to\":18,\"gater\":null},{\"weight\":0.12085544603933747,\"from\":35,\"to\":19,\"gater\":null},{\"weight\":-0.0858059041144829,\"from\":35,\"to\":20,\"gater\":null},{\"weight\":-0.03145813819034271,\"from\":35,\"to\":21,\"gater\":null},{\"weight\":0.016851738319321213,\"from\":35,\"to\":22,\"gater\":null},{\"weight\":0.031124052545432535,\"from\":35,\"to\":23,\"gater\":null},{\"weight\":-0.09332580030250742,\"from\":35,\"to\":24,\"gater\":null},{\"weight\":-0.0632852414307637,\"from\":35,\"to\":25,\"gater\":null},{\"weight\":-0.13512855719650776,\"from\":35,\"to\":26,\"gater\":null},{\"weight\":0.07294792179376292,\"from\":35,\"to\":27,\"gater\":null},{\"weight\":0.08446790766360743,\"from\":35,\"to\":28,\"gater\":null},{\"weight\":0.03388832077207904,\"from\":35,\"to\":29,\"gater\":null},{\"weight\":0.008370387038641253,\"from\":35,\"to\":40,\"gater\":null},{\"weight\":-0.07238008733439044,\"from\":35,\"to\":41,\"gater\":null},{\"weight\":0.08679195164571613,\"from\":35,\"to\":42,\"gater\":null},{\"weight\":0.057808547232427905,\"from\":35,\"to\":43,\"gater\":null},{\"weight\":-0.0717775405623687,\"from\":35,\"to\":44,\"gater\":null},{\"weight\":0.03439062024420893,\"from\":35,\"to\":45,\"gater\":null},{\"weight\":-0.1108051359207117,\"from\":35,\"to\":46,\"gater\":null},{\"weight\":-0.07340104642925634,\"from\":35,\"to\":47,\"gater\":null},{\"weight\":-0.029450702335329867,\"from\":35,\"to\":48,\"gater\":null},{\"weight\":0.051409295336234645,\"from\":35,\"to\":49,\"gater\":null},{\"weight\":2.763244462992073,\"from\":35,\"to\":50,\"gater\":45},{\"weight\":0.09961554868058835,\"from\":36,\"to\":10,\"gater\":null},{\"weight\":0.07950669775973379,\"from\":36,\"to\":11,\"gater\":null},{\"weight\":0.01407614198152005,\"from\":36,\"to\":12,\"gater\":null},{\"weight\":-0.07048115211624066,\"from\":36,\"to\":13,\"gater\":null},{\"weight\":0.06341931689878656,\"from\":36,\"to\":14,\"gater\":null},{\"weight\":0.17447917034878585,\"from\":36,\"to\":15,\"gater\":null},{\"weight\":0.1081448728719388,\"from\":36,\"to\":16,\"gater\":null},{\"weight\":-0.01683390367312917,\"from\":36,\"to\":17,\"gater\":null},{\"weight\":-0.01934818462268775,\"from\":36,\"to\":18,\"gater\":null},{\"weight\":-0.0030087151478784785,\"from\":36,\"to\":19,\"gater\":null},{\"weight\":-0.0733555497661095,\"from\":36,\"to\":20,\"gater\":null},{\"weight\":0.0570622953254154,\"from\":36,\"to\":21,\"gater\":null},{\"weight\":0.08453194020170378,\"from\":36,\"to\":22,\"gater\":null},{\"weight\":-0.09336833379969511,\"from\":36,\"to\":23,\"gater\":null},{\"weight\":0.014511211266580925,\"from\":36,\"to\":24,\"gater\":null},{\"weight\":-0.08079300323207575,\"from\":36,\"to\":25,\"gater\":null},{\"weight\":-0.0699984276562199,\"from\":36,\"to\":26,\"gater\":null},{\"weight\":0.04131330548316674,\"from\":36,\"to\":27,\"gater\":null},{\"weight\":-0.006574844964831095,\"from\":36,\"to\":28,\"gater\":null},{\"weight\":0.07634051414861291,\"from\":36,\"to\":29,\"gater\":null},{\"weight\":0.09945983569035735,\"from\":36,\"to\":40,\"gater\":null},{\"weight\":-0.0792362673277407,\"from\":36,\"to\":41,\"gater\":null},{\"weight\":-0.10536127967725031,\"from\":36,\"to\":42,\"gater\":null},{\"weight\":0.04175804296816555,\"from\":36,\"to\":43,\"gater\":null},{\"weight\":0.01571985092996928,\"from\":36,\"to\":44,\"gater\":null},{\"weight\":0.13596829013903683,\"from\":36,\"to\":45,\"gater\":null},{\"weight\":-0.006014415660815187,\"from\":36,\"to\":46,\"gater\":null},{\"weight\":-0.1552364514840095,\"from\":36,\"to\":47,\"gater\":null},{\"weight\":0.009837988843256961,\"from\":36,\"to\":48,\"gater\":null},{\"weight\":-0.009759665450114077,\"from\":36,\"to\":49,\"gater\":null},{\"weight\":1.8016402011648578,\"from\":36,\"to\":50,\"gater\":46},{\"weight\":0.0013748179148884215,\"from\":37,\"to\":10,\"gater\":null},{\"weight\":-0.08987723109903074,\"from\":37,\"to\":11,\"gater\":null},{\"weight\":-0.051716334770661475,\"from\":37,\"to\":12,\"gater\":null},{\"weight\":-0.08692091867199028,\"from\":37,\"to\":13,\"gater\":null},{\"weight\":0.043234023667318495,\"from\":37,\"to\":14,\"gater\":null},{\"weight\":-0.09199866733447791,\"from\":37,\"to\":15,\"gater\":null},{\"weight\":-0.060074433312649965,\"from\":37,\"to\":16,\"gater\":null},{\"weight\":-0.08753178213962669,\"from\":37,\"to\":17,\"gater\":null},{\"weight\":0.06239917852819916,\"from\":37,\"to\":18,\"gater\":null},{\"weight\":0.09258897380588522,\"from\":37,\"to\":19,\"gater\":null},{\"weight\":0.08753194294885844,\"from\":37,\"to\":20,\"gater\":null},{\"weight\":-0.07001662650406998,\"from\":37,\"to\":21,\"gater\":null},{\"weight\":0.022413521192489013,\"from\":37,\"to\":22,\"gater\":null},{\"weight\":-0.034037112249044606,\"from\":37,\"to\":23,\"gater\":null},{\"weight\":-0.04915055042280517,\"from\":37,\"to\":24,\"gater\":null},{\"weight\":-0.06971283597431968,\"from\":37,\"to\":25,\"gater\":null},{\"weight\":-0.099154472537604,\"from\":37,\"to\":26,\"gater\":null},{\"weight\":-0.027474809098825645,\"from\":37,\"to\":27,\"gater\":null},{\"weight\":-0.07865099570090925,\"from\":37,\"to\":28,\"gater\":null},{\"weight\":-0.021513849186788662,\"from\":37,\"to\":29,\"gater\":null},{\"weight\":-0.0855768875130714,\"from\":37,\"to\":40,\"gater\":null},{\"weight\":-0.15579380609763813,\"from\":37,\"to\":41,\"gater\":null},{\"weight\":-0.04490962909924923,\"from\":37,\"to\":42,\"gater\":null},{\"weight\":-0.15871699676239923,\"from\":37,\"to\":43,\"gater\":null},{\"weight\":-0.37516811734710553,\"from\":37,\"to\":44,\"gater\":null},{\"weight\":0.044455539251897956,\"from\":37,\"to\":45,\"gater\":null},{\"weight\":-0.04949542866768565,\"from\":37,\"to\":46,\"gater\":null},{\"weight\":-0.3754279447727664,\"from\":37,\"to\":47,\"gater\":null},{\"weight\":-0.023998364716469604,\"from\":37,\"to\":48,\"gater\":null},{\"weight\":0.09571540478008653,\"from\":37,\"to\":49,\"gater\":null},{\"weight\":1.3530792330307182,\"from\":37,\"to\":50,\"gater\":47},{\"weight\":0.0028386442822054313,\"from\":38,\"to\":10,\"gater\":null},{\"weight\":-0.05530893388171947,\"from\":38,\"to\":11,\"gater\":null},{\"weight\":-0.04475029474201304,\"from\":38,\"to\":12,\"gater\":null},{\"weight\":0.08677594834670672,\"from\":38,\"to\":13,\"gater\":null},{\"weight\":0.055658464638257146,\"from\":38,\"to\":14,\"gater\":null},{\"weight\":-0.035953575004674845,\"from\":38,\"to\":15,\"gater\":null},{\"weight\":-0.038787935408313066,\"from\":38,\"to\":16,\"gater\":null},{\"weight\":-0.0003510102587263273,\"from\":38,\"to\":17,\"gater\":null},{\"weight\":0.021283211984575806,\"from\":38,\"to\":18,\"gater\":null},{\"weight\":-0.05478553076967487,\"from\":38,\"to\":19,\"gater\":null},{\"weight\":0.08758640741701423,\"from\":38,\"to\":20,\"gater\":null},{\"weight\":0.07227097132349573,\"from\":38,\"to\":21,\"gater\":null},{\"weight\":0.0626517038905322,\"from\":38,\"to\":22,\"gater\":null},{\"weight\":-0.04477461029963022,\"from\":38,\"to\":23,\"gater\":null},{\"weight\":-0.07964624562208385,\"from\":38,\"to\":24,\"gater\":null},{\"weight\":-0.07794346428609591,\"from\":38,\"to\":25,\"gater\":null},{\"weight\":-0.09445532852501742,\"from\":38,\"to\":26,\"gater\":null},{\"weight\":0.05883783257743791,\"from\":38,\"to\":27,\"gater\":null},{\"weight\":-0.09398263759509644,\"from\":38,\"to\":28,\"gater\":null},{\"weight\":-0.05434851640217519,\"from\":38,\"to\":29,\"gater\":null},{\"weight\":0.07969996359737043,\"from\":38,\"to\":40,\"gater\":null},{\"weight\":-0.050814808102078876,\"from\":38,\"to\":41,\"gater\":null},{\"weight\":0.029741404385051594,\"from\":38,\"to\":42,\"gater\":null},{\"weight\":0.061335445559491365,\"from\":38,\"to\":43,\"gater\":null},{\"weight\":-0.06997720513783998,\"from\":38,\"to\":44,\"gater\":null},{\"weight\":-0.09760187225329704,\"from\":38,\"to\":45,\"gater\":null},{\"weight\":-0.043692959098049565,\"from\":38,\"to\":46,\"gater\":null},{\"weight\":0.0038025009569007118,\"from\":38,\"to\":47,\"gater\":null},{\"weight\":-0.07955488113922729,\"from\":38,\"to\":48,\"gater\":null},{\"weight\":-0.059987851395979466,\"from\":38,\"to\":49,\"gater\":null},{\"weight\":-0.06353215734119362,\"from\":38,\"to\":50,\"gater\":48},{\"weight\":-0.022856587056681407,\"from\":39,\"to\":10,\"gater\":null},{\"weight\":0.0629093741138176,\"from\":39,\"to\":11,\"gater\":null},{\"weight\":-0.0505752449517071,\"from\":39,\"to\":12,\"gater\":null},{\"weight\":-0.015516021711804133,\"from\":39,\"to\":13,\"gater\":null},{\"weight\":0.06863616089736582,\"from\":39,\"to\":14,\"gater\":null},{\"weight\":-0.12354139217815352,\"from\":39,\"to\":15,\"gater\":null},{\"weight\":0.09564596649042602,\"from\":39,\"to\":16,\"gater\":null},{\"weight\":0.020882955038725382,\"from\":39,\"to\":17,\"gater\":null},{\"weight\":0.021546469052786683,\"from\":39,\"to\":18,\"gater\":null},{\"weight\":0.12438019321330915,\"from\":39,\"to\":19,\"gater\":null},{\"weight\":-0.02765926486196716,\"from\":39,\"to\":20,\"gater\":null},{\"weight\":0.08197890949337083,\"from\":39,\"to\":21,\"gater\":null},{\"weight\":-0.029657207983198566,\"from\":39,\"to\":22,\"gater\":null},{\"weight\":-0.08677648680759492,\"from\":39,\"to\":23,\"gater\":null},{\"weight\":0.058363950399454294,\"from\":39,\"to\":24,\"gater\":null},{\"weight\":-0.012472063440281173,\"from\":39,\"to\":25,\"gater\":null},{\"weight\":-0.014888891758237698,\"from\":39,\"to\":26,\"gater\":null},{\"weight\":0.0041862981519185495,\"from\":39,\"to\":27,\"gater\":null},{\"weight\":0.09027455640307641,\"from\":39,\"to\":28,\"gater\":null},{\"weight\":0.16203693635516345,\"from\":39,\"to\":29,\"gater\":null},{\"weight\":0.019466571952771773,\"from\":39,\"to\":40,\"gater\":null},{\"weight\":-0.17633329153870672,\"from\":39,\"to\":41,\"gater\":null},{\"weight\":0.07207979686665328,\"from\":39,\"to\":42,\"gater\":null},{\"weight\":-0.030474562027453904,\"from\":39,\"to\":43,\"gater\":null},{\"weight\":-0.30608417112585773,\"from\":39,\"to\":44,\"gater\":null},{\"weight\":-0.13269711816451674,\"from\":39,\"to\":45,\"gater\":null},{\"weight\":-0.16729819109561028,\"from\":39,\"to\":46,\"gater\":null},{\"weight\":-0.41140942692228016,\"from\":39,\"to\":47,\"gater\":null},{\"weight\":-0.08512943200570623,\"from\":39,\"to\":48,\"gater\":null},{\"weight\":0.23932894957281547,\"from\":39,\"to\":49,\"gater\":null},{\"weight\":-1.2454553363169925,\"from\":39,\"to\":50,\"gater\":49}],\"input\":10,\"output\":1,\"dropout\":0});\r\n\r\nconst length = xy => Math.sqrt(xy[0]*xy[0] + xy[1]*xy[1]);\r\nconst prepareData = dataPositions => dataPositions.map((dp, i) => {\r\n\tif(i > 0){\r\n\t\tconst last = dataPositions[i-1];\r\n\t\treturn [\r\n\t\t\tdp[0] - last[0],\r\n\t\t\tdp[1] - last[1]\r\n\t\t]\r\n\t}\r\n}).slice(1, dataPositions.length).map(length);\r\n\r\nconst predictAction = mousePositions => !!Math.round(network.activate(prepareData(mousePositions)));\n\n//# sourceURL=webpack:///./predictor/predictAction.js?");

/***/ }),

/***/ "./styles.js":
/*!*******************!*\
  !*** ./styles.js ***!
  \*******************/
/*! exports provided: addPredictiveHoverRules, addHoverClass, removeHoverClass */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addPredictiveHoverRules\", function() { return addPredictiveHoverRules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addHoverClass\", function() { return addHoverClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeHoverClass\", function() { return removeHoverClass; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./constants.js\");\n\r\n\r\n\r\nconst hoverRegex = /\\S+:hover/g;\r\n\r\nconst addPredictiveHoverRules = () => {\r\n\r\n\tconst sheets = document.styleSheets;\r\n\r\n\tfor(let i = 0, il = sheets.length; i < il; i++){\r\n\t\tconst sheet = sheets[i],\r\n\t\t\trules = sheet.cssRules,\r\n\t\t\trulesToAdd = [];\r\n\r\n\t\tfor(let j = 0, jl = rules.length; j < jl; j++){\r\n\t\t\tconst rule = rules[j],\r\n\t\t\t\tselectorText = rule.selectorText;\r\n\r\n\t\t\tif(selectorText.indexOf(':hover') > -1){\r\n\t\t\t\trulesToAdd.push({\r\n\t\t\t\t\tselector: selectorText.replace(hoverRegex, '.' + _constants__WEBPACK_IMPORTED_MODULE_0__[\"hoverClass\"]),\r\n\t\t\t\t\tcss: rule.style.cssText\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trulesToAdd.map(r => addCSSRule(sheet, r.selector, r.css, 1));\r\n\t}\r\n}\r\n\r\nconst addHoverClass = target => {\r\n    target.classList.add(_constants__WEBPACK_IMPORTED_MODULE_0__[\"hoverClass\"]);\r\n}\r\n\r\nconst removeHoverClass = target => {\r\n    target.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_0__[\"hoverClass\"]);\r\n}\r\n\r\nconst addCSSRule = (sheet, selector, rules, index) => {\r\n\tif(\"insertRule\" in sheet) {\r\n\t\tsheet.insertRule(selector + \"{\" + rules + \"}\", index);\r\n\t}\r\n\telse if(\"addRule\" in sheet) {\r\n\t\tsheet.addRule(selector, rules, index);\r\n\t}\r\n}\n\n//# sourceURL=webpack:///./styles.js?");

/***/ }),

/***/ 0:
/*!*******************************!*\
  !*** child_process (ignored) ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///child_process_(ignored)?");

/***/ })

/******/ });