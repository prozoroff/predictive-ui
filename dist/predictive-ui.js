/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./constants.js":
/*!**********************!*\
  !*** ./constants.js ***!
  \**********************/
/*! exports provided: particlesNumber, distributionSize, predictionFactor, predictiveAttribute, hoverClass, predictiveTimeout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"particlesNumber\", function() { return particlesNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distributionSize\", function() { return distributionSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"predictionFactor\", function() { return predictionFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"predictiveAttribute\", function() { return predictiveAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hoverClass\", function() { return hoverClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"predictiveTimeout\", function() { return predictiveTimeout; });\nconst particlesNumber = 50;\r\nconst distributionSize = 10;\r\nconst predictionFactor = 10;\r\nconst predictiveAttribute = 'predictive-item';\r\nconst hoverClass = 'predictive-item-hover';\r\nconst predictiveTimeout = 1000;\n\n//# sourceURL=webpack:///./constants.js?");

/***/ }),

/***/ "./filters.js":
/*!********************!*\
  !*** ./filters.js ***!
  \********************/
/*! exports provided: getParticleFilter, getMovingAverageFilter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getParticleFilter\", function() { return getParticleFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMovingAverageFilter\", function() { return getMovingAverageFilter; });\n/* harmony import */ var particle_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! particle-filter */ \"./node_modules/particle-filter/lib/index.js\");\n/* harmony import */ var particle_filter__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(particle_filter__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"./constants.js\");\n\r\n\r\n\r\n\r\n\r\nconst getParticleFilter = () => {\r\n\tconst variablesNumber = 2, //x,y\r\n\t\tfilter = new particle_filter__WEBPACK_IMPORTED_MODULE_0___default.a(_constants__WEBPACK_IMPORTED_MODULE_1__[\"particlesNumber\"], variablesNumber, _constants__WEBPACK_IMPORTED_MODULE_1__[\"distributionSize\"]);\r\n\r\n\treturn {\r\n\t\tupdate: coords => filter.update(coords),\r\n\t\tstate: () => filter.result.state \r\n\t}\r\n}\r\n\r\nconst getMovingAverageFilter = () => {\r\n\tconst depth = 5,\r\n\t\thistory = [],\r\n\t\taverage = arr => {\r\n\t\t\tconst sum = arr.reduce(function(a, b) { return a + b; });\r\n    \t\treturn sum / arr.length;\r\n\t\t}\r\n\r\n\treturn {\r\n\t\tupdate: coords => {\r\n\t\t\tif(history.length === 5){\r\n\t\t\t\thistory.shift();\r\n\t\t\t}\r\n\t\t\thistory.push(coords);\r\n\t\t},\r\n\t\tstate: () => [\r\n\t\t\taverage(history.map(h => h[0])),\r\n\t\t\taverage(history.map(h => h[1]))\r\n\t\t]\r\n\t}\r\n}\n\n//# sourceURL=webpack:///./filters.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _filters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filters */ \"./filters.js\");\n/* harmony import */ var _styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles */ \"./styles.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ \"./constants.js\");\n/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mouse */ \"./mouse.js\");\n/* harmony import */ var _predictor_predictAction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./predictor/predictAction */ \"./predictor/predictAction.js\");\n\r\n\r\n\r\n\r\n\r\n\t\r\n\r\nObject(_styles__WEBPACK_IMPORTED_MODULE_1__[\"addPredictiveHoverRules\"])();\r\n\r\nconst filter = Object(_filters__WEBPACK_IMPORTED_MODULE_0__[\"getParticleFilter\"])();\r\nconst elements = document.querySelectorAll(`[${_constants__WEBPACK_IMPORTED_MODULE_2__[\"predictiveAttribute\"]}]`);\r\n\r\ndocument.body.onmousemove = Object(_mouse__WEBPACK_IMPORTED_MODULE_3__[\"getMouseHandler\"])(filter, elements/*, predictAction*/);\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./mouse.js":
/*!******************!*\
  !*** ./mouse.js ***!
  \******************/
/*! exports provided: getMouseHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMouseHandler\", function() { return getMouseHandler; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./constants.js\");\n/* harmony import */ var _styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles */ \"./styles.js\");\n\r\n\r\n\r\n//17 last positions = 16 last differences\r\nconst positionsFull = mousePositions => mousePositions.length === 17;\r\n\r\nconst isIn = (x,y,coordinates) => \r\n\tx > coordinates.x && \r\n\tx < (coordinates.x + coordinates.width) && \r\n\ty > coordinates.y && \r\n\ty < (coordinates.y + coordinates.height);\r\n\r\nconst getMouseHandler = (filter, elements, predict) => {\r\n\t\r\n\tconst coordinatesCheckers = [];\r\n\tfor(let i = 0, l = elements.length; i < l; i++){\r\n\t\tconst element = elements[i],\r\n\t\t\trect = element.getBoundingClientRect();\r\n\r\n\t\tcoordinatesCheckers.push((x,y) => isIn(x,y,rect));\r\n\t}\r\n\r\n  const timeoutIds = new Array(elements.length);\r\n\r\n\tlet globalX, \r\n\t\tglobalY,\r\n    mousePositions = [];\r\n\r\n\treturn e => {\r\n\r\n    \tlet x, y;\r\n\r\n    \tif (document.all)  { \r\n      \t\tx = event.x + document.body.scrollLeft; \r\n      \t\ty = event.y + document.body.scrollTop; \r\n    \t} else {\r\n      \t\tx = e.pageX;\r\n      \t\ty = e.pageY;\r\n    \t}\r\n\r\n    \tglobalX = globalX || x;\r\n    \tglobalY = globalY || y;\r\n\r\n    \tfilter.update([(x - globalX)*_constants__WEBPACK_IMPORTED_MODULE_0__[\"predictionFactor\"], (y - globalY)*_constants__WEBPACK_IMPORTED_MODULE_0__[\"predictionFactor\"]]);\r\n\r\n\t\tconst filterState = filter.state(),\r\n\t\t\tpredictX = globalX + filterState[0],\r\n\t\t\tpredictY = globalY + filterState[1];\r\n\r\n      if(!predict || !positionsFull(mousePositions) || predict(mousePositions)){\r\n        for(let i = 0, l = coordinatesCheckers.length; i < l; i++){\r\n          if(coordinatesCheckers[i](predictX, predictY)){\r\n            const element = elements[i];\r\n            if(!timeoutIds[i]){\r\n              Object(_styles__WEBPACK_IMPORTED_MODULE_1__[\"addHoverClass\"])(element);\r\n              timeoutIds[i] = setTimeout(() => {\r\n                Object(_styles__WEBPACK_IMPORTED_MODULE_1__[\"removeHoverClass\"])(element);\r\n                delete timeoutIds[i];\r\n              }, _constants__WEBPACK_IMPORTED_MODULE_0__[\"predictiveTimeout\"]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n    \tglobalX = x;\r\n    \tglobalY = y;\r\n\r\n      if(predict){\r\n        positionsFull(mousePositions) && mousePositions.shift();\r\n        mousePositions.push([x,y]);\r\n      }\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./mouse.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/architecture/architect.js":
/*!**************************************************************!*\
  !*** ./node_modules/neataptic/src/architecture/architect.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Import */\r\nvar methods = __webpack_require__(/*! ../methods/methods */ \"./node_modules/neataptic/src/methods/methods.js\");\r\nvar Network = __webpack_require__(/*! ./network */ \"./node_modules/neataptic/src/architecture/network.js\");\r\nvar Group = __webpack_require__(/*! ./group */ \"./node_modules/neataptic/src/architecture/group.js\");\r\nvar Layer = __webpack_require__(/*! ./layer */ \"./node_modules/neataptic/src/architecture/layer.js\");\r\nvar Node = __webpack_require__(/*! ./node */ \"./node_modules/neataptic/src/architecture/node.js\");\r\n\r\n/*******************************************************************************\r\n                                        architect\r\n*******************************************************************************/\r\n\r\nvar architect = {\r\n  /**\r\n   * Constructs a network from a given array of connected nodes\r\n   */\r\n  Construct: function (list) {\r\n    // Create a network\r\n    var network = new Network(0, 0);\r\n\r\n    // Transform all groups into nodes\r\n    var nodes = [];\r\n\r\n    var i;\r\n    for (i = 0; i < list.length; i++) {\r\n      let j;\r\n      if (list[i] instanceof Group) {\r\n        for (j = 0; j < list[i].nodes.length; j++) {\r\n          nodes.push(list[i].nodes[j]);\r\n        }\r\n      } else if (list[i] instanceof Layer) {\r\n        for (j = 0; j < list[i].nodes.length; j++) {\r\n          for (var k = 0; k < list[i].nodes[j].nodes.length; k++) {\r\n            nodes.push(list[i].nodes[j].nodes[k]);\r\n          }\r\n        }\r\n      } else if (list[i] instanceof Node) {\r\n        nodes.push(list[i]);\r\n      }\r\n    }\r\n\r\n    // Determine input and output nodes\r\n    var inputs = [];\r\n    var outputs = [];\r\n    for (i = nodes.length - 1; i >= 0; i--) {\r\n      if (nodes[i].type === 'output' || nodes[i].connections.out.length + nodes[i].connections.gated.length === 0) {\r\n        nodes[i].type = 'output';\r\n        network.output++;\r\n        outputs.push(nodes[i]);\r\n        nodes.splice(i, 1);\r\n      } else if (nodes[i].type === 'input' || !nodes[i].connections.in.length) {\r\n        nodes[i].type = 'input';\r\n        network.input++;\r\n        inputs.push(nodes[i]);\r\n        nodes.splice(i, 1);\r\n      }\r\n    }\r\n\r\n    // Input nodes are always first, output nodes are always last\r\n    nodes = inputs.concat(nodes).concat(outputs);\r\n\r\n    if (network.input === 0 || network.output === 0) {\r\n      throw new Error('Given nodes have no clear input/output node!');\r\n    }\r\n\r\n    for (i = 0; i < nodes.length; i++) {\r\n      let j;\r\n      for (j = 0; j < nodes[i].connections.out.length; j++) {\r\n        network.connections.push(nodes[i].connections.out[j]);\r\n      }\r\n      for (j = 0; j < nodes[i].connections.gated.length; j++) {\r\n        network.gates.push(nodes[i].connections.gated[j]);\r\n      }\r\n      if (nodes[i].connections.self.weight !== 0) {\r\n        network.selfconns.push(nodes[i].connections.self);\r\n      }\r\n    }\r\n\r\n    network.nodes = nodes;\r\n\r\n    return network;\r\n  },\r\n\r\n  /**\r\n   * Creates a multilayer perceptron (MLP)\r\n   */\r\n  Perceptron: function () {\r\n    // Convert arguments to Array\r\n    var layers = Array.prototype.slice.call(arguments);\r\n    if (layers.length < 3) {\r\n      throw new Error('You have to specify at least 3 layers');\r\n    }\r\n\r\n    // Create a list of nodes/groups\r\n    var nodes = [];\r\n    nodes.push(new Group(layers[0]));\r\n\r\n    for (var i = 1; i < layers.length; i++) {\r\n      var layer = layers[i];\r\n      layer = new Group(layer);\r\n      nodes.push(layer);\r\n      nodes[i - 1].connect(nodes[i], methods.connection.ALL_TO_ALL);\r\n    }\r\n\r\n    // Construct the network\r\n    return architect.Construct(nodes);\r\n  },\r\n\r\n  /**\r\n   * Creates a randomly connected network\r\n   */\r\n  Random: function (input, hidden, output, options) {\r\n    options = options || {};\r\n\r\n    var connections = options.connections || hidden * 2;\r\n    var backconnections = options.backconnections || 0;\r\n    var selfconnections = options.selfconnections || 0;\r\n    var gates = options.gates || 0;\r\n\r\n    var network = new Network(input, output);\r\n\r\n    var i;\r\n    for (i = 0; i < hidden; i++) {\r\n      network.mutate(methods.mutation.ADD_NODE);\r\n    }\r\n\r\n    for (i = 0; i < connections - hidden; i++) {\r\n      network.mutate(methods.mutation.ADD_CONN);\r\n    }\r\n\r\n    for (i = 0; i < backconnections; i++) {\r\n      network.mutate(methods.mutation.ADD_BACK_CONN);\r\n    }\r\n\r\n    for (i = 0; i < selfconnections; i++) {\r\n      network.mutate(methods.mutation.ADD_SELF_CONN);\r\n    }\r\n\r\n    for (i = 0; i < gates; i++) {\r\n      network.mutate(methods.mutation.ADD_GATE);\r\n    }\r\n\r\n    return network;\r\n  },\r\n\r\n  /**\r\n   * Creates a long short-term memory network\r\n   */\r\n  LSTM: function () {\r\n    var args = Array.prototype.slice.call(arguments);\r\n    if (args.length < 3) {\r\n      throw new Error('You have to specify at least 3 layers');\r\n    }\r\n\r\n    var last = args.pop();\r\n\r\n    var outputLayer;\r\n    if (typeof last === 'number') {\r\n      outputLayer = new Group(last);\r\n      last = {};\r\n    } else {\r\n      outputLayer = new Group(args.pop()); // last argument\r\n    }\r\n\r\n    outputLayer.set({\r\n      type: 'output'\r\n    });\r\n\r\n    var options = {};\r\n    options.memoryToMemory = last.memoryToMemory || false;\r\n    options.outputToMemory = last.outputToMemory || false;\r\n    options.outputToGates = last.outputToGates || false;\r\n    options.inputToOutput = last.inputToOutput === undefined ? true : last.inputToOutput;\r\n    options.inputToDeep = last.inputToDeep === undefined ? true : last.inputToDeep;\r\n\r\n    var inputLayer = new Group(args.shift()); // first argument\r\n    inputLayer.set({\r\n      type: 'input'\r\n    });\r\n\r\n    var blocks = args; // all the arguments in the middle\r\n\r\n    var nodes = [];\r\n    nodes.push(inputLayer);\r\n\r\n    var previous = inputLayer;\r\n    for (var i = 0; i < blocks.length; i++) {\r\n      var block = blocks[i];\r\n\r\n      // Init required nodes (in activation order)\r\n      var inputGate = new Group(block);\r\n      var forgetGate = new Group(block);\r\n      var memoryCell = new Group(block);\r\n      var outputGate = new Group(block);\r\n      var outputBlock = i === blocks.length - 1 ? outputLayer : new Group(block);\r\n\r\n      inputGate.set({\r\n        bias: 1\r\n      });\r\n      forgetGate.set({\r\n        bias: 1\r\n      });\r\n      outputGate.set({\r\n        bias: 1\r\n      });\r\n\r\n      // Connect the input with all the nodes\r\n      var input = previous.connect(memoryCell, methods.connection.ALL_TO_ALL);\r\n      previous.connect(inputGate, methods.connection.ALL_TO_ALL);\r\n      previous.connect(outputGate, methods.connection.ALL_TO_ALL);\r\n      previous.connect(forgetGate, methods.connection.ALL_TO_ALL);\r\n\r\n      // Set up internal connections\r\n      memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL);\r\n      memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL);\r\n      memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL);\r\n      var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE);\r\n      var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL);\r\n\r\n      // Set up gates\r\n      inputGate.gate(input, methods.gating.INPUT);\r\n      forgetGate.gate(forget, methods.gating.SELF);\r\n      outputGate.gate(output, methods.gating.OUTPUT);\r\n\r\n      // Input to all memory cells\r\n      if (options.inputToDeep && i > 0) {\r\n        let input = inputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL);\r\n        inputGate.gate(input, methods.gating.INPUT);\r\n      }\r\n\r\n      // Optional connections\r\n      if (options.memoryToMemory) {\r\n        let input = memoryCell.connect(memoryCell, methods.connection.ALL_TO_ELSE);\r\n        inputGate.gate(input, methods.gating.INPUT);\r\n      }\r\n\r\n      if (options.outputToMemory) {\r\n        let input = outputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL);\r\n        inputGate.gate(input, methods.gating.INPUT);\r\n      }\r\n\r\n      if (options.outputToGates) {\r\n        outputLayer.connect(inputGate, methods.connection.ALL_TO_ALL);\r\n        outputLayer.connect(forgetGate, methods.connection.ALL_TO_ALL);\r\n        outputLayer.connect(outputGate, methods.connection.ALL_TO_ALL);\r\n      }\r\n\r\n      // Add to array\r\n      nodes.push(inputGate);\r\n      nodes.push(forgetGate);\r\n      nodes.push(memoryCell);\r\n      nodes.push(outputGate);\r\n      if (i !== blocks.length - 1) nodes.push(outputBlock);\r\n\r\n      previous = outputBlock;\r\n    }\r\n\r\n    // input to output direct connection\r\n    if (options.inputToOutput) {\r\n      inputLayer.connect(outputLayer, methods.connection.ALL_TO_ALL);\r\n    }\r\n\r\n    nodes.push(outputLayer);\r\n    return architect.Construct(nodes);\r\n  },\r\n\r\n  /**\r\n   * Creates a gated recurrent unit network\r\n   */\r\n  GRU: function () {\r\n    var args = Array.prototype.slice.call(arguments);\r\n    if (args.length < 3) {\r\n      throw new Error('not enough layers (minimum 3) !!');\r\n    }\r\n\r\n    var inputLayer = new Group(args.shift()); // first argument\r\n    var outputLayer = new Group(args.pop()); // last argument\r\n    var blocks = args; // all the arguments in the middle\r\n\r\n    var nodes = [];\r\n    nodes.push(inputLayer);\r\n\r\n    var previous = inputLayer;\r\n    for (var i = 0; i < blocks.length; i++) {\r\n      var layer = new Layer.GRU(blocks[i]);\r\n      previous.connect(layer);\r\n      previous = layer;\r\n\r\n      nodes.push(layer);\r\n    }\r\n\r\n    previous.connect(outputLayer);\r\n    nodes.push(outputLayer);\r\n\r\n    return architect.Construct(nodes);\r\n  },\r\n\r\n  /**\r\n   * Creates a hopfield network of the given size\r\n   */\r\n  Hopfield: function (size) {\r\n    var input = new Group(size);\r\n    var output = new Group(size);\r\n\r\n    input.connect(output, methods.connection.ALL_TO_ALL);\r\n\r\n    input.set({\r\n      type: 'input'\r\n    });\r\n    output.set({\r\n      squash: methods.activation.STEP,\r\n      type: 'output'\r\n    });\r\n\r\n    var network = new architect.Construct([input, output]);\r\n\r\n    return network;\r\n  },\r\n\r\n  /**\r\n   * Creates a NARX network (remember previous inputs/outputs)\r\n   */\r\n  NARX: function (inputSize, hiddenLayers, outputSize, previousInput, previousOutput) {\r\n    if (!Array.isArray(hiddenLayers)) {\r\n      hiddenLayers = [hiddenLayers];\r\n    }\r\n\r\n    var nodes = [];\r\n\r\n    var input = new Layer.Dense(inputSize);\r\n    var inputMemory = new Layer.Memory(inputSize, previousInput);\r\n    var hidden = [];\r\n    var output = new Layer.Dense(outputSize);\r\n    var outputMemory = new Layer.Memory(outputSize, previousOutput);\r\n\r\n    nodes.push(input);\r\n    nodes.push(outputMemory);\r\n\r\n    for (var i = 0; i < hiddenLayers.length; i++) {\r\n      var hiddenLayer = new Layer.Dense(hiddenLayers[i]);\r\n      hidden.push(hiddenLayer);\r\n      nodes.push(hiddenLayer);\r\n      if (typeof hidden[i - 1] !== 'undefined') {\r\n        hidden[i - 1].connect(hiddenLayer, methods.connection.ALL_TO_ALL);\r\n      }\r\n    }\r\n\r\n    nodes.push(inputMemory);\r\n    nodes.push(output);\r\n\r\n    input.connect(hidden[0], methods.connection.ALL_TO_ALL);\r\n    input.connect(inputMemory, methods.connection.ONE_TO_ONE, 1);\r\n    inputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);\r\n    hidden[hidden.length - 1].connect(output, methods.connection.ALL_TO_ALL);\r\n    output.connect(outputMemory, methods.connection.ONE_TO_ONE, 1);\r\n    outputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);\r\n\r\n    input.set({\r\n      type: 'input'\r\n    });\r\n    output.set({\r\n      type: 'output'\r\n    });\r\n\r\n    return architect.Construct(nodes);\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = architect;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/architecture/architect.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/architecture/connection.js":
/*!***************************************************************!*\
  !*** ./node_modules/neataptic/src/architecture/connection.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* Export */\r\nmodule.exports = Connection;\r\n\r\n/*******************************************************************************\r\n                                      CONNECTION\r\n*******************************************************************************/\r\n\r\nfunction Connection (from, to, weight) {\r\n  this.from = from;\r\n  this.to = to;\r\n  this.gain = 1;\r\n\r\n  this.weight = (typeof weight === 'undefined') ? Math.random() * 0.2 - 0.1 : weight;\r\n\r\n  this.gater = null;\r\n  this.elegibility = 0;\r\n\r\n  // For tracking momentum\r\n  this.previousDeltaWeight = 0;\r\n\r\n  // Batch training\r\n  this.totalDeltaWeight = 0;\r\n\r\n  this.xtrace = {\r\n    nodes: [],\r\n    values: []\r\n  };\r\n}\r\n\r\nConnection.prototype = {\r\n  /**\r\n   * Converts the connection to a json object\r\n   */\r\n  toJSON: function () {\r\n    var json = {\r\n      weight: this.weight\r\n    };\r\n\r\n    return json;\r\n  }\r\n};\r\n\r\n/**\r\n * Returns an innovation ID\r\n * https://en.wikipedia.org/wiki/Pairing_function (Cantor pairing function)\r\n */\r\nConnection.innovationID = function (a, b) {\r\n  return 1 / 2 * (a + b) * (a + b + 1) + b;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/architecture/connection.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/architecture/group.js":
/*!**********************************************************!*\
  !*** ./node_modules/neataptic/src/architecture/group.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\r\nmodule.exports = Group;\r\n\r\n/* Import */\r\nvar methods = __webpack_require__(/*! ../methods/methods */ \"./node_modules/neataptic/src/methods/methods.js\");\r\nvar config = __webpack_require__(/*! ../config */ \"./node_modules/neataptic/src/config.js\");\r\nvar Layer = __webpack_require__(/*! ./layer */ \"./node_modules/neataptic/src/architecture/layer.js\");\r\nvar Node = __webpack_require__(/*! ./node */ \"./node_modules/neataptic/src/architecture/node.js\");\r\n\r\n/*******************************************************************************\r\n                                         Group\r\n*******************************************************************************/\r\n\r\nfunction Group (size) {\r\n  this.nodes = [];\r\n  this.connections = {\r\n    in: [],\r\n    out: [],\r\n    self: []\r\n  };\r\n\r\n  for (var i = 0; i < size; i++) {\r\n    this.nodes.push(new Node());\r\n  }\r\n}\r\n\r\nGroup.prototype = {\r\n  /**\r\n   * Activates all the nodes in the group\r\n   */\r\n  activate: function (value) {\r\n    var values = [];\r\n\r\n    if (typeof value !== 'undefined' && value.length !== this.nodes.length) {\r\n      throw new Error('Array with values should be same as the amount of nodes!');\r\n    }\r\n\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      var activation;\r\n      if (typeof value === 'undefined') {\r\n        activation = this.nodes[i].activate();\r\n      } else {\r\n        activation = this.nodes[i].activate(value[i]);\r\n      }\r\n\r\n      values.push(activation);\r\n    }\r\n\r\n    return values;\r\n  },\r\n\r\n  /**\r\n   * Propagates all the node in the group\r\n   */\r\n  propagate: function (rate, momentum, target) {\r\n    if (typeof target !== 'undefined' && target.length !== this.nodes.length) {\r\n      throw new Error('Array with values should be same as the amount of nodes!');\r\n    }\r\n\r\n    for (var i = this.nodes.length - 1; i >= 0; i--) {\r\n      if (typeof target === 'undefined') {\r\n        this.nodes[i].propagate(rate, momentum, true);\r\n      } else {\r\n        this.nodes[i].propagate(rate, momentum, true, target[i]);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Connects the nodes in this group to nodes in another group or just a node\r\n   */\r\n  connect: function (target, method, weight) {\r\n    var connections = [];\r\n    var i, j;\r\n    if (target instanceof Group) {\r\n      if (typeof method === 'undefined') {\r\n        if (this !== target) {\r\n          if (config.warnings) console.warn('No group connection specified, using ALL_TO_ALL');\r\n          method = methods.connection.ALL_TO_ALL;\r\n        } else {\r\n          if (config.warnings) console.warn('No group connection specified, using ONE_TO_ONE');\r\n          method = methods.connection.ONE_TO_ONE;\r\n        }\r\n      }\r\n      if (method === methods.connection.ALL_TO_ALL || method === methods.connection.ALL_TO_ELSE) {\r\n        for (i = 0; i < this.nodes.length; i++) {\r\n          for (j = 0; j < target.nodes.length; j++) {\r\n            if (method === methods.connection.ALL_TO_ELSE && this.nodes[i] === target.nodes[j]) continue;\r\n            let connection = this.nodes[i].connect(target.nodes[j], weight);\r\n            this.connections.out.push(connection[0]);\r\n            target.connections.in.push(connection[0]);\r\n            connections.push(connection[0]);\r\n          }\r\n        }\r\n      } else if (method === methods.connection.ONE_TO_ONE) {\r\n        if (this.nodes.length !== target.nodes.length) {\r\n          throw new Error('From and To group must be the same size!');\r\n        }\r\n\r\n        for (i = 0; i < this.nodes.length; i++) {\r\n          let connection = this.nodes[i].connect(target.nodes[i], weight);\r\n          this.connections.self.push(connection[0]);\r\n          connections.push(connection[0]);\r\n        }\r\n      }\r\n    } else if (target instanceof Layer) {\r\n      connections = target.input(this, method, weight);\r\n    } else if (target instanceof Node) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        let connection = this.nodes[i].connect(target, weight);\r\n        this.connections.out.push(connection[0]);\r\n        connections.push(connection[0]);\r\n      }\r\n    }\r\n\r\n    return connections;\r\n  },\r\n\r\n  /**\r\n   * Make nodes from this group gate the given connection(s)\r\n   */\r\n  gate: function (connections, method) {\r\n    if (typeof method === 'undefined') {\r\n      throw new Error('Please specify Gating.INPUT, Gating.OUTPUT');\r\n    }\r\n\r\n    if (!Array.isArray(connections)) {\r\n      connections = [connections];\r\n    }\r\n\r\n    var nodes1 = [];\r\n    var nodes2 = [];\r\n\r\n    var i, j;\r\n    for (i = 0; i < connections.length; i++) {\r\n      var connection = connections[i];\r\n      if (!nodes1.includes(connection.from)) nodes1.push(connection.from);\r\n      if (!nodes2.includes(connection.to)) nodes2.push(connection.to);\r\n    }\r\n\r\n    switch (method) {\r\n      case methods.gating.INPUT:\r\n        for (i = 0; i < nodes2.length; i++) {\r\n          let node = nodes2[i];\r\n          let gater = this.nodes[i % this.nodes.length];\r\n\r\n          for (j = 0; j < node.connections.in.length; j++) {\r\n            let conn = node.connections.in[j];\r\n            if (connections.includes(conn)) {\r\n              gater.gate(conn);\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      case methods.gating.OUTPUT:\r\n        for (i = 0; i < nodes1.length; i++) {\r\n          let node = nodes1[i];\r\n          let gater = this.nodes[i % this.nodes.length];\r\n\r\n          for (j = 0; j < node.connections.out.length; j++) {\r\n            let conn = node.connections.out[j];\r\n            if (connections.includes(conn)) {\r\n              gater.gate(conn);\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      case methods.gating.SELF:\r\n        for (i = 0; i < nodes1.length; i++) {\r\n          let node = nodes1[i];\r\n          let gater = this.nodes[i % this.nodes.length];\r\n\r\n          if (connections.includes(node.connections.self)) {\r\n            gater.gate(node.connections.self);\r\n          }\r\n        }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sets the value of a property for every node\r\n   */\r\n  set: function (values) {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      if (typeof values.bias !== 'undefined') {\r\n        this.nodes[i].bias = values.bias;\r\n      }\r\n\r\n      this.nodes[i].squash = values.squash || this.nodes[i].squash;\r\n      this.nodes[i].type = values.type || this.nodes[i].type;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Disconnects all nodes from this group from another given group/node\r\n   */\r\n  disconnect: function (target, twosided) {\r\n    twosided = twosided || false;\r\n\r\n    // In the future, disconnect will return a connection so indexOf can be used\r\n    var i, j, k;\r\n    if (target instanceof Group) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        for (j = 0; j < target.nodes.length; j++) {\r\n          this.nodes[i].disconnect(target.nodes[j], twosided);\r\n\r\n          for (k = this.connections.out.length - 1; k >= 0; k--) {\r\n            let conn = this.connections.out[k];\r\n\r\n            if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {\r\n              this.connections.out.splice(k, 1);\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (twosided) {\r\n            for (k = this.connections.in.length - 1; k >= 0; k--) {\r\n              let conn = this.connections.in[k];\r\n\r\n              if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {\r\n                this.connections.in.splice(k, 1);\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else if (target instanceof Node) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        this.nodes[i].disconnect(target, twosided);\r\n\r\n        for (j = this.connections.out.length - 1; j >= 0; j--) {\r\n          let conn = this.connections.out[j];\r\n\r\n          if (conn.from === this.nodes[i] && conn.to === target) {\r\n            this.connections.out.splice(j, 1);\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (twosided) {\r\n          for (j = this.connections.in.length - 1; j >= 0; j--) {\r\n            var conn = this.connections.in[j];\r\n\r\n            if (conn.from === target && conn.to === this.nodes[i]) {\r\n              this.connections.in.splice(j, 1);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Clear the context of this group\r\n   */\r\n  clear: function () {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].clear();\r\n    }\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/architecture/group.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/architecture/layer.js":
/*!**********************************************************!*\
  !*** ./node_modules/neataptic/src/architecture/layer.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\r\nmodule.exports = Layer;\r\n\r\n/* Import */\r\nvar methods = __webpack_require__(/*! ../methods/methods */ \"./node_modules/neataptic/src/methods/methods.js\");\r\nvar Group = __webpack_require__(/*! ./group */ \"./node_modules/neataptic/src/architecture/group.js\");\r\nvar Node = __webpack_require__(/*! ./node */ \"./node_modules/neataptic/src/architecture/node.js\");\r\n\r\n/*******************************************************************************\r\n                                         Group\r\n*******************************************************************************/\r\n\r\nfunction Layer () {\r\n  this.output = null;\r\n\r\n  this.nodes = [];\r\n  this.connections = { in: [],\r\n    out: [],\r\n    self: []\r\n  };\r\n}\r\n\r\nLayer.prototype = {\r\n  /**\r\n   * Activates all the nodes in the group\r\n   */\r\n  activate: function (value) {\r\n    var values = [];\r\n\r\n    if (typeof value !== 'undefined' && value.length !== this.nodes.length) {\r\n      throw new Error('Array with values should be same as the amount of nodes!');\r\n    }\r\n\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      var activation;\r\n      if (typeof value === 'undefined') {\r\n        activation = this.nodes[i].activate();\r\n      } else {\r\n        activation = this.nodes[i].activate(value[i]);\r\n      }\r\n\r\n      values.push(activation);\r\n    }\r\n\r\n    return values;\r\n  },\r\n\r\n  /**\r\n   * Propagates all the node in the group\r\n   */\r\n  propagate: function (rate, momentum, target) {\r\n    if (typeof target !== 'undefined' && target.length !== this.nodes.length) {\r\n      throw new Error('Array with values should be same as the amount of nodes!');\r\n    }\r\n\r\n    for (var i = this.nodes.length - 1; i >= 0; i--) {\r\n      if (typeof target === 'undefined') {\r\n        this.nodes[i].propagate(rate, momentum, true);\r\n      } else {\r\n        this.nodes[i].propagate(rate, momentum, true, target[i]);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Connects the nodes in this group to nodes in another group or just a node\r\n   */\r\n  connect: function (target, method, weight) {\r\n    var connections;\r\n    if (target instanceof Group || target instanceof Node) {\r\n      connections = this.output.connect(target, method, weight);\r\n    } else if (target instanceof Layer) {\r\n      connections = target.input(this, method, weight);\r\n    }\r\n\r\n    return connections;\r\n  },\r\n\r\n  /**\r\n   * Make nodes from this group gate the given connection(s)\r\n   */\r\n  gate: function (connections, method) {\r\n    this.output.gate(connections, method);\r\n  },\r\n\r\n  /**\r\n   * Sets the value of a property for every node\r\n   */\r\n  set: function (values) {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      var node = this.nodes[i];\r\n\r\n      if (node instanceof Node) {\r\n        if (typeof values.bias !== 'undefined') {\r\n          node.bias = values.bias;\r\n        }\r\n\r\n        node.squash = values.squash || node.squash;\r\n        node.type = values.type || node.type;\r\n      } else if (node instanceof Group) {\r\n        node.set(values);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Disconnects all nodes from this group from another given group/node\r\n   */\r\n  disconnect: function (target, twosided) {\r\n    twosided = twosided || false;\r\n\r\n    // In the future, disconnect will return a connection so indexOf can be used\r\n    var i, j, k;\r\n    if (target instanceof Group) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        for (j = 0; j < target.nodes.length; j++) {\r\n          this.nodes[i].disconnect(target.nodes[j], twosided);\r\n\r\n          for (k = this.connections.out.length - 1; k >= 0; k--) {\r\n            let conn = this.connections.out[k];\r\n\r\n            if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {\r\n              this.connections.out.splice(k, 1);\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (twosided) {\r\n            for (k = this.connections.in.length - 1; k >= 0; k--) {\r\n              let conn = this.connections.in[k];\r\n\r\n              if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {\r\n                this.connections.in.splice(k, 1);\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else if (target instanceof Node) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        this.nodes[i].disconnect(target, twosided);\r\n\r\n        for (j = this.connections.out.length - 1; j >= 0; j--) {\r\n          let conn = this.connections.out[j];\r\n\r\n          if (conn.from === this.nodes[i] && conn.to === target) {\r\n            this.connections.out.splice(j, 1);\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (twosided) {\r\n          for (k = this.connections.in.length - 1; k >= 0; k--) {\r\n            let conn = this.connections.in[k];\r\n\r\n            if (conn.from === target && conn.to === this.nodes[i]) {\r\n              this.connections.in.splice(k, 1);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Clear the context of this group\r\n   */\r\n  clear: function () {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].clear();\r\n    }\r\n  }\r\n};\r\n\r\nLayer.Dense = function (size) {\r\n  // Create the layer\r\n  var layer = new Layer();\r\n\r\n  // Init required nodes (in activation order)\r\n  var block = new Group(size);\r\n\r\n  layer.nodes.push(block);\r\n  layer.output = block;\r\n\r\n  layer.input = function (from, method, weight) {\r\n    if (from instanceof Layer) from = from.output;\r\n    method = method || methods.connection.ALL_TO_ALL;\r\n    return from.connect(block, method, weight);\r\n  };\r\n\r\n  return layer;\r\n};\r\n\r\nLayer.LSTM = function (size) {\r\n  // Create the layer\r\n  var layer = new Layer();\r\n\r\n  // Init required nodes (in activation order)\r\n  var inputGate = new Group(size);\r\n  var forgetGate = new Group(size);\r\n  var memoryCell = new Group(size);\r\n  var outputGate = new Group(size);\r\n  var outputBlock = new Group(size);\r\n\r\n  inputGate.set({\r\n    bias: 1\r\n  });\r\n  forgetGate.set({\r\n    bias: 1\r\n  });\r\n  outputGate.set({\r\n    bias: 1\r\n  });\r\n\r\n  // Set up internal connections\r\n  memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL);\r\n  memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL);\r\n  memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL);\r\n  var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE);\r\n  var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL);\r\n\r\n  // Set up gates\r\n  forgetGate.gate(forget, methods.gating.SELF);\r\n  outputGate.gate(output, methods.gating.OUTPUT);\r\n\r\n  // Add to nodes array\r\n  layer.nodes = [inputGate, forgetGate, memoryCell, outputGate, outputBlock];\r\n\r\n  // Define output\r\n  layer.output = outputBlock;\r\n\r\n  layer.input = function (from, method, weight) {\r\n    if (from instanceof Layer) from = from.output;\r\n    method = method || methods.connection.ALL_TO_ALL;\r\n    var connections = [];\r\n\r\n    var input = from.connect(memoryCell, method, weight);\r\n    connections = connections.concat(input);\r\n\r\n    connections = connections.concat(from.connect(inputGate, method, weight));\r\n    connections = connections.concat(from.connect(outputGate, method, weight));\r\n    connections = connections.concat(from.connect(forgetGate, method, weight));\r\n\r\n    inputGate.gate(input, methods.gating.INPUT);\r\n\r\n    return connections;\r\n  };\r\n\r\n  return layer;\r\n};\r\n\r\nLayer.GRU = function (size) {\r\n  // Create the layer\r\n  var layer = new Layer();\r\n\r\n  var updateGate = new Group(size);\r\n  var inverseUpdateGate = new Group(size);\r\n  var resetGate = new Group(size);\r\n  var memoryCell = new Group(size);\r\n  var output = new Group(size);\r\n  var previousOutput = new Group(size);\r\n\r\n  previousOutput.set({\r\n    bias: 0,\r\n    squash: methods.activation.IDENTITY,\r\n    type: 'constant'\r\n  });\r\n  memoryCell.set({\r\n    squash: methods.activation.TANH\r\n  });\r\n  inverseUpdateGate.set({\r\n    bias: 0,\r\n    squash: methods.activation.INVERSE,\r\n    type: 'constant'\r\n  });\r\n  updateGate.set({\r\n    bias: 1\r\n  });\r\n  resetGate.set({\r\n    bias: 0\r\n  });\r\n\r\n  // Update gate calculation\r\n  previousOutput.connect(updateGate, methods.connection.ALL_TO_ALL);\r\n\r\n  // Inverse update gate calculation\r\n  updateGate.connect(inverseUpdateGate, methods.connection.ONE_TO_ONE, 1);\r\n\r\n  // Reset gate calculation\r\n  previousOutput.connect(resetGate, methods.connection.ALL_TO_ALL);\r\n\r\n  // Memory calculation\r\n  var reset = previousOutput.connect(memoryCell, methods.connection.ALL_TO_ALL);\r\n\r\n  resetGate.gate(reset, methods.gating.OUTPUT); // gate\r\n\r\n  // Output calculation\r\n  var update1 = previousOutput.connect(output, methods.connection.ALL_TO_ALL);\r\n  var update2 = memoryCell.connect(output, methods.connection.ALL_TO_ALL);\r\n\r\n  updateGate.gate(update1, methods.gating.OUTPUT);\r\n  inverseUpdateGate.gate(update2, methods.gating.OUTPUT);\r\n\r\n  // Previous output calculation\r\n  output.connect(previousOutput, methods.connection.ONE_TO_ONE, 1);\r\n\r\n  // Add to nodes array\r\n  layer.nodes = [updateGate, inverseUpdateGate, resetGate, memoryCell, output, previousOutput];\r\n\r\n  layer.output = output;\r\n\r\n  layer.input = function (from, method, weight) {\r\n    if (from instanceof Layer) from = from.output;\r\n    method = method || methods.connection.ALL_TO_ALL;\r\n    var connections = [];\r\n\r\n    connections = connections.concat(from.connect(updateGate, method, weight));\r\n    connections = connections.concat(from.connect(resetGate, method, weight));\r\n    connections = connections.concat(from.connect(memoryCell, method, weight));\r\n\r\n    return connections;\r\n  };\r\n\r\n  return layer;\r\n};\r\n\r\nLayer.Memory = function (size, memory) {\r\n  // Create the layer\r\n  var layer = new Layer();\r\n  // Because the output can only be one group, we have to put the nodes all in óne group\r\n\r\n  var previous = null;\r\n  var i;\r\n  for (i = 0; i < memory; i++) {\r\n    var block = new Group(size);\r\n\r\n    block.set({\r\n      squash: methods.activation.IDENTITY,\r\n      bias: 0,\r\n      type: 'constant'\r\n    });\r\n\r\n    if (previous != null) {\r\n      previous.connect(block, methods.connection.ONE_TO_ONE, 1);\r\n    }\r\n\r\n    layer.nodes.push(block);\r\n    previous = block;\r\n  }\r\n\r\n  layer.nodes.reverse();\r\n\r\n  for (i = 0; i < layer.nodes.length; i++) {\r\n    layer.nodes[i].nodes.reverse();\r\n  }\r\n\r\n  // Because output can only be óne group, fit all memory nodes in óne group\r\n  var outputGroup = new Group(0);\r\n  for (var group in layer.nodes) {\r\n    outputGroup.nodes = outputGroup.nodes.concat(layer.nodes[group].nodes);\r\n  }\r\n  layer.output = outputGroup;\r\n\r\n  layer.input = function (from, method, weight) {\r\n    if (from instanceof Layer) from = from.output;\r\n    method = method || methods.connection.ALL_TO_ALL;\r\n\r\n    if (from.nodes.length !== layer.nodes[layer.nodes.length - 1].nodes.length) {\r\n      throw new Error('Previous layer size must be same as memory size');\r\n    }\r\n\r\n    return from.connect(layer.nodes[layer.nodes.length - 1], methods.connection.ONE_TO_ONE, 1);\r\n  };\r\n\r\n  return layer;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/architecture/layer.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/architecture/network.js":
/*!************************************************************!*\
  !*** ./node_modules/neataptic/src/architecture/network.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\r\nmodule.exports = Network;\r\n\r\n/* Import */\r\nvar multi = __webpack_require__(/*! ../multithreading/multi */ \"./node_modules/neataptic/src/multithreading/multi.js\");\r\nvar methods = __webpack_require__(/*! ../methods/methods */ \"./node_modules/neataptic/src/methods/methods.js\");\r\nvar Connection = __webpack_require__(/*! ./connection */ \"./node_modules/neataptic/src/architecture/connection.js\");\r\nvar config = __webpack_require__(/*! ../config */ \"./node_modules/neataptic/src/config.js\");\r\nvar Neat = __webpack_require__(/*! ../neat */ \"./node_modules/neataptic/src/neat.js\");\r\nvar Node = __webpack_require__(/*! ./node */ \"./node_modules/neataptic/src/architecture/node.js\");\r\n\r\n/* Easier variable naming */\r\nvar mutation = methods.mutation;\r\n\r\n/*******************************************************************************\r\n                                 NETWORK\r\n*******************************************************************************/\r\n\r\nfunction Network (input, output) {\r\n  if (typeof input === 'undefined' || typeof output === 'undefined') {\r\n    throw new Error('No input or output size given');\r\n  }\r\n\r\n  this.input = input;\r\n  this.output = output;\r\n\r\n  // Store all the node and connection genes\r\n  this.nodes = []; // Stored in activation order\r\n  this.connections = [];\r\n  this.gates = [];\r\n  this.selfconns = [];\r\n\r\n  // Regularization\r\n  this.dropout = 0;\r\n\r\n  // Create input and output nodes\r\n  var i;\r\n  for (i = 0; i < this.input + this.output; i++) {\r\n    var type = i < this.input ? 'input' : 'output';\r\n    this.nodes.push(new Node(type));\r\n  }\r\n\r\n  // Connect input nodes with output nodes directly\r\n  for (i = 0; i < this.input; i++) {\r\n    for (var j = this.input; j < this.output + this.input; j++) {\r\n      // https://stats.stackexchange.com/a/248040/147931\r\n      var weight = Math.random() * this.input * Math.sqrt(2 / this.input);\r\n      this.connect(this.nodes[i], this.nodes[j], weight);\r\n    }\r\n  }\r\n}\r\n\r\nNetwork.prototype = {\r\n  /**\r\n   * Activates the network\r\n   */\r\n  activate: function (input, training) {\r\n    var output = [];\r\n\r\n    // Activate nodes chronologically\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      if (this.nodes[i].type === 'input') {\r\n        this.nodes[i].activate(input[i]);\r\n      } else if (this.nodes[i].type === 'output') {\r\n        var activation = this.nodes[i].activate();\r\n        output.push(activation);\r\n      } else {\r\n        if (training) this.nodes[i].mask = Math.random() < this.dropout ? 0 : 1;\r\n        this.nodes[i].activate();\r\n      }\r\n    }\r\n\r\n    return output;\r\n  },\r\n\r\n  /**\r\n   * Activates the network without calculating elegibility traces and such\r\n   */\r\n  noTraceActivate: function (input) {\r\n    var output = [];\r\n\r\n    // Activate nodes chronologically\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      if (this.nodes[i].type === 'input') {\r\n        this.nodes[i].noTraceActivate(input[i]);\r\n      } else if (this.nodes[i].type === 'output') {\r\n        var activation = this.nodes[i].noTraceActivate();\r\n        output.push(activation);\r\n      } else {\r\n        this.nodes[i].noTraceActivate();\r\n      }\r\n    }\r\n\r\n    return output;\r\n  },\r\n\r\n  /**\r\n   * Backpropagate the network\r\n   */\r\n  propagate: function (rate, momentum, update, target) {\r\n    if (typeof target === 'undefined' || target.length !== this.output) {\r\n      throw new Error('Output target length should match network output length');\r\n    }\r\n\r\n    var targetIndex = target.length;\r\n\r\n    // Propagate output nodes\r\n    var i;\r\n    for (i = this.nodes.length - 1; i >= this.nodes.length - this.output; i--) {\r\n      this.nodes[i].propagate(rate, momentum, update, target[--targetIndex]);\r\n    }\r\n\r\n    // Propagate hidden and input nodes\r\n    for (i = this.nodes.length - this.output - 1; i >= this.input; i--) {\r\n      this.nodes[i].propagate(rate, momentum, update);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Clear the context of the network\r\n   */\r\n  clear: function () {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].clear();\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Connects the from node to the to node\r\n   */\r\n  connect: function (from, to, weight) {\r\n    var connections = from.connect(to, weight);\r\n\r\n    for (var i = 0; i < connections.length; i++) {\r\n      var connection = connections[i];\r\n      if (from !== to) {\r\n        this.connections.push(connection);\r\n      } else {\r\n        this.selfconns.push(connection);\r\n      }\r\n    }\r\n\r\n    return connections;\r\n  },\r\n\r\n  /**\r\n   * Disconnects the from node from the to node\r\n   */\r\n  disconnect: function (from, to) {\r\n    // Delete the connection in the network's connection array\r\n    var connections = from === to ? this.selfconns : this.connections;\r\n\r\n    for (var i = 0; i < connections.length; i++) {\r\n      var connection = connections[i];\r\n      if (connection.from === from && connection.to === to) {\r\n        if (connection.gater !== null) this.ungate(connection);\r\n        connections.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Delete the connection at the sending and receiving neuron\r\n    from.disconnect(to);\r\n  },\r\n\r\n  /**\r\n   * Gate a connection with a node\r\n   */\r\n  gate: function (node, connection) {\r\n    if (this.nodes.indexOf(node) === -1) {\r\n      throw new Error('This node is not part of the network!');\r\n    } else if (connection.gater != null) {\r\n      if (config.warnings) console.warn('This connection is already gated!');\r\n      return;\r\n    }\r\n    node.gate(connection);\r\n    this.gates.push(connection);\r\n  },\r\n\r\n  /**\r\n   *  Remove the gate of a connection\r\n   */\r\n  ungate: function (connection) {\r\n    var index = this.gates.indexOf(connection);\r\n    if (index === -1) {\r\n      throw new Error('This connection is not gated!');\r\n    }\r\n\r\n    this.gates.splice(index, 1);\r\n    connection.gater.ungate(connection);\r\n  },\r\n\r\n  /**\r\n   *  Removes a node from the network\r\n   */\r\n  remove: function (node) {\r\n    var index = this.nodes.indexOf(node);\r\n\r\n    if (index === -1) {\r\n      throw new Error('This node does not exist in the network!');\r\n    }\r\n\r\n    // Keep track of gaters\r\n    var gaters = [];\r\n\r\n    // Remove selfconnections from this.selfconns\r\n    this.disconnect(node, node);\r\n\r\n    // Get all its inputting nodes\r\n    var inputs = [];\r\n    for (var i = node.connections.in.length - 1; i >= 0; i--) {\r\n      let connection = node.connections.in[i];\r\n      if (mutation.SUB_NODE.keep_gates && connection.gater !== null && connection.gater !== node) {\r\n        gaters.push(connection.gater);\r\n      }\r\n      inputs.push(connection.from);\r\n      this.disconnect(connection.from, node);\r\n    }\r\n\r\n    // Get all its outputing nodes\r\n    var outputs = [];\r\n    for (i = node.connections.out.length - 1; i >= 0; i--) {\r\n      let connection = node.connections.out[i];\r\n      if (mutation.SUB_NODE.keep_gates && connection.gater !== null && connection.gater !== node) {\r\n        gaters.push(connection.gater);\r\n      }\r\n      outputs.push(connection.to);\r\n      this.disconnect(node, connection.to);\r\n    }\r\n\r\n    // Connect the input nodes to the output nodes (if not already connected)\r\n    var connections = [];\r\n    for (i = 0; i < inputs.length; i++) {\r\n      let input = inputs[i];\r\n      for (var j = 0; j < outputs.length; j++) {\r\n        let output = outputs[j];\r\n        if (!input.isProjectingTo(output)) {\r\n          var conn = this.connect(input, output);\r\n          connections.push(conn[0]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Gate random connections with gaters\r\n    for (i = 0; i < gaters.length; i++) {\r\n      if (connections.length === 0) break;\r\n\r\n      let gater = gaters[i];\r\n      let connIndex = Math.floor(Math.random() * connections.length);\r\n\r\n      this.gate(gater, connections[connIndex]);\r\n      connections.splice(connIndex, 1);\r\n    }\r\n\r\n    // Remove gated connections gated by this node\r\n    for (i = node.connections.gated.length - 1; i >= 0; i--) {\r\n      let conn = node.connections.gated[i];\r\n      this.ungate(conn);\r\n    }\r\n\r\n    // Remove selfconnection\r\n    this.disconnect(node, node);\r\n\r\n    // Remove the node from this.nodes\r\n    this.nodes.splice(index, 1);\r\n  },\r\n\r\n  /**\r\n   * Mutates the network with the given method\r\n   */\r\n  mutate: function (method) {\r\n    if (typeof method === 'undefined') {\r\n      throw new Error('No (correct) mutate method given!');\r\n    }\r\n\r\n    var i, j;\r\n    switch (method) {\r\n      case mutation.ADD_NODE:\r\n        // Look for an existing connection and place a node in between\r\n        var connection = this.connections[Math.floor(Math.random() * this.connections.length)];\r\n        var gater = connection.gater;\r\n        this.disconnect(connection.from, connection.to);\r\n\r\n        // Insert the new node right before the old connection.to\r\n        var toIndex = this.nodes.indexOf(connection.to);\r\n        var node = new Node('hidden');\r\n\r\n        // Random squash function\r\n        node.mutate(mutation.MOD_ACTIVATION);\r\n\r\n        // Place it in this.nodes\r\n        var minBound = Math.min(toIndex, this.nodes.length - this.output);\r\n        this.nodes.splice(minBound, 0, node);\r\n\r\n        // Now create two new connections\r\n        var newConn1 = this.connect(connection.from, node)[0];\r\n        var newConn2 = this.connect(node, connection.to)[0];\r\n\r\n        // Check if the original connection was gated\r\n        if (gater != null) {\r\n          this.gate(gater, Math.random() >= 0.5 ? newConn1 : newConn2);\r\n        }\r\n        break;\r\n      case mutation.SUB_NODE:\r\n        // Check if there are nodes left to remove\r\n        if (this.nodes.length === this.input + this.output) {\r\n          if (config.warnings) console.warn('No more nodes left to remove!');\r\n          break;\r\n        }\r\n\r\n        // Select a node which isn't an input or output node\r\n        var index = Math.floor(Math.random() * (this.nodes.length - this.output - this.input) + this.input);\r\n        this.remove(this.nodes[index]);\r\n        break;\r\n      case mutation.ADD_CONN:\r\n        // Create an array of all uncreated (feedforward) connections\r\n        var available = [];\r\n        for (i = 0; i < this.nodes.length - this.output; i++) {\r\n          let node1 = this.nodes[i];\r\n          for (j = Math.max(i + 1, this.input); j < this.nodes.length; j++) {\r\n            let node2 = this.nodes[j];\r\n            if (!node1.isProjectingTo(node2)) available.push([node1, node2]);\r\n          }\r\n        }\r\n\r\n        if (available.length === 0) {\r\n          if (config.warnings) console.warn('No more connections to be made!');\r\n          break;\r\n        }\r\n\r\n        var pair = available[Math.floor(Math.random() * available.length)];\r\n        this.connect(pair[0], pair[1]);\r\n        break;\r\n      case mutation.SUB_CONN:\r\n        // List of possible connections that can be removed\r\n        var possible = [];\r\n\r\n        for (i = 0; i < this.connections.length; i++) {\r\n          let conn = this.connections[i];\r\n          // Check if it is not disabling a node\r\n          if (conn.from.connections.out.length > 1 && conn.to.connections.in.length > 1 && this.nodes.indexOf(conn.to) > this.nodes.indexOf(conn.from)) {\r\n            possible.push(conn);\r\n          }\r\n        }\r\n\r\n        if (possible.length === 0) {\r\n          if (config.warnings) console.warn('No connections to remove!');\r\n          break;\r\n        }\r\n\r\n        var randomConn = possible[Math.floor(Math.random() * possible.length)];\r\n        this.disconnect(randomConn.from, randomConn.to);\r\n        break;\r\n      case mutation.MOD_WEIGHT:\r\n        var allconnections = this.connections.concat(this.selfconns);\r\n\r\n        var connection = allconnections[Math.floor(Math.random() * allconnections.length)];\r\n        var modification = Math.random() * (method.max - method.min) + method.min;\r\n        connection.weight += modification;\r\n        break;\r\n      case mutation.MOD_BIAS:\r\n        // Has no effect on input node, so they are excluded\r\n        var index = Math.floor(Math.random() * (this.nodes.length - this.input) + this.input);\r\n        var node = this.nodes[index];\r\n        node.mutate(method);\r\n        break;\r\n      case mutation.MOD_ACTIVATION:\r\n        // Has no effect on input node, so they are excluded\r\n        if (!method.mutateOutput && this.input + this.output === this.nodes.length) {\r\n          if (config.warnings) console.warn('No nodes that allow mutation of activation function');\r\n          break;\r\n        }\r\n\r\n        var index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);\r\n        var node = this.nodes[index];\r\n\r\n        node.mutate(method);\r\n        break;\r\n      case mutation.ADD_SELF_CONN:\r\n        // Check which nodes aren't selfconnected yet\r\n        var possible = [];\r\n        for (i = this.input; i < this.nodes.length; i++) {\r\n          let node = this.nodes[i];\r\n          if (node.connections.self.weight === 0) {\r\n            possible.push(node);\r\n          }\r\n        }\r\n\r\n        if (possible.length === 0) {\r\n          if (config.warnings) console.warn('No more self-connections to add!');\r\n          break;\r\n        }\r\n\r\n        // Select a random node\r\n        var node = possible[Math.floor(Math.random() * possible.length)];\r\n\r\n        // Connect it to himself\r\n        this.connect(node, node);\r\n        break;\r\n      case mutation.SUB_SELF_CONN:\r\n        if (this.selfconns.length === 0) {\r\n          if (config.warnings) console.warn('No more self-connections to remove!');\r\n          break;\r\n        }\r\n        var conn = this.selfconns[Math.floor(Math.random() * this.selfconns.length)];\r\n        this.disconnect(conn.from, conn.to);\r\n        break;\r\n      case mutation.ADD_GATE:\r\n        var allconnections = this.connections.concat(this.selfconns);\r\n\r\n        // Create a list of all non-gated connections\r\n        var possible = [];\r\n        for (i = 0; i < allconnections.length; i++) {\r\n          let conn = allconnections[i];\r\n          if (conn.gater === null) {\r\n            possible.push(conn);\r\n          }\r\n        }\r\n\r\n        if (possible.length === 0) {\r\n          if (config.warnings) console.warn('No more connections to gate!');\r\n          break;\r\n        }\r\n\r\n        // Select a random gater node and connection, can't be gated by input\r\n        var index = Math.floor(Math.random() * (this.nodes.length - this.input) + this.input);\r\n        var node = this.nodes[index];\r\n        var conn = possible[Math.floor(Math.random() * possible.length)];\r\n\r\n        // Gate the connection with the node\r\n        this.gate(node, conn);\r\n        break;\r\n      case mutation.SUB_GATE:\r\n        // Select a random gated connection\r\n        if (this.gates.length === 0) {\r\n          if (config.warnings) console.warn('No more connections to ungate!');\r\n          break;\r\n        }\r\n\r\n        var index = Math.floor(Math.random() * this.gates.length);\r\n        var gatedconn = this.gates[index];\r\n\r\n        this.ungate(gatedconn);\r\n        break;\r\n      case mutation.ADD_BACK_CONN:\r\n        // Create an array of all uncreated (backfed) connections\r\n        var available = [];\r\n        for (i = this.input; i < this.nodes.length; i++) {\r\n          let node1 = this.nodes[i];\r\n          for (j = this.input; j < i; j++) {\r\n            let node2 = this.nodes[j];\r\n            if (!node1.isProjectingTo(node2)) available.push([node1, node2]);\r\n          }\r\n        }\r\n\r\n        if (available.length === 0) {\r\n          if (config.warnings) console.warn('No more connections to be made!');\r\n          break;\r\n        }\r\n\r\n        var pair = available[Math.floor(Math.random() * available.length)];\r\n        this.connect(pair[0], pair[1]);\r\n        break;\r\n      case mutation.SUB_BACK_CONN:\r\n        // List of possible connections that can be removed\r\n        var possible = [];\r\n\r\n        for (i = 0; i < this.connections.length; i++) {\r\n          let conn = this.connections[i];\r\n          // Check if it is not disabling a node\r\n          if (conn.from.connections.out.length > 1 && conn.to.connections.in.length > 1 && this.nodes.indexOf(conn.from) > this.nodes.indexOf(conn.to)) {\r\n            possible.push(conn);\r\n          }\r\n        }\r\n\r\n        if (possible.length === 0) {\r\n          if (config.warnings) console.warn('No connections to remove!');\r\n          break;\r\n        }\r\n\r\n        var randomConn = possible[Math.floor(Math.random() * possible.length)];\r\n        this.disconnect(randomConn.from, randomConn.to);\r\n        break;\r\n      case mutation.SWAP_NODES:\r\n        // Has no effect on input node, so they are excluded\r\n        if ((method.mutateOutput && this.nodes.length - this.input < 2) ||\r\n          (!method.mutateOutput && this.nodes.length - this.input - this.output < 2)) {\r\n          if (config.warnings) console.warn('No nodes that allow swapping of bias and activation function');\r\n          break;\r\n        }\r\n\r\n        var index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);\r\n        var node1 = this.nodes[index];\r\n        index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);\r\n        var node2 = this.nodes[index];\r\n\r\n        var biasTemp = node1.bias;\r\n        var squashTemp = node1.squash;\r\n\r\n        node1.bias = node2.bias;\r\n        node1.squash = node2.squash;\r\n        node2.bias = biasTemp;\r\n        node2.squash = squashTemp;\r\n        break;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Train the given set to this network\r\n   */\r\n  train: function (set, options) {\r\n    if (set[0].input.length !== this.input || set[0].output.length !== this.output) {\r\n      throw new Error('Dataset input/output size should be same as network input/output size!');\r\n    }\r\n\r\n    options = options || {};\r\n\r\n    // Warning messages\r\n    if (typeof options.rate === 'undefined') {\r\n      if (config.warnings) console.warn('Using default learning rate, please define a rate!');\r\n    }\r\n    if (typeof options.iterations === 'undefined') {\r\n      if (config.warnings) console.warn('No target iterations given, running until error is reached!');\r\n    }\r\n\r\n    // Read the options\r\n    var targetError = options.error || 0.05;\r\n    var cost = options.cost || methods.cost.MSE;\r\n    var baseRate = options.rate || 0.3;\r\n    var dropout = options.dropout || 0;\r\n    var momentum = options.momentum || 0;\r\n    var batchSize = options.batchSize || 1; // online learning\r\n    var ratePolicy = options.ratePolicy || methods.rate.FIXED();\r\n\r\n    var start = Date.now();\r\n\r\n    if (batchSize > set.length) {\r\n      throw new Error('Batch size must be smaller or equal to dataset length!');\r\n    } else if (typeof options.iterations === 'undefined' && typeof options.error === 'undefined') {\r\n      throw new Error('At least one of the following options must be specified: error, iterations');\r\n    } else if (typeof options.error === 'undefined') {\r\n      targetError = -1; // run until iterations\r\n    } else if (typeof options.iterations === 'undefined') {\r\n      options.iterations = 0; // run until target error\r\n    }\r\n\r\n    // Save to network\r\n    this.dropout = dropout;\r\n\r\n    if (options.crossValidate) {\r\n      let numTrain = Math.ceil((1 - options.crossValidate.testSize) * set.length);\r\n      var trainSet = set.slice(0, numTrain);\r\n      var testSet = set.slice(numTrain);\r\n    }\r\n\r\n    // Loops the training process\r\n    var currentRate = baseRate;\r\n    var iteration = 0;\r\n    var error = 1;\r\n\r\n    var i, j, x;\r\n    while (error > targetError && (options.iterations === 0 || iteration < options.iterations)) {\r\n      if (options.crossValidate && error <= options.crossValidate.testError) break;\r\n\r\n      iteration++;\r\n\r\n      // Update the rate\r\n      currentRate = ratePolicy(baseRate, iteration);\r\n\r\n      // Checks if cross validation is enabled\r\n      if (options.crossValidate) {\r\n        this._trainSet(trainSet, batchSize, currentRate, momentum, cost);\r\n        if (options.clear) this.clear();\r\n        error = this.test(testSet, cost).error;\r\n        if (options.clear) this.clear();\r\n      } else {\r\n        error = this._trainSet(set, batchSize, currentRate, momentum, cost);\r\n        if (options.clear) this.clear();\r\n      }\r\n\r\n      // Checks for options such as scheduled logs and shuffling\r\n      if (options.shuffle) {\r\n        for (j, x, i = set.length; i; j = Math.floor(Math.random() * i), x = set[--i], set[i] = set[j], set[j] = x);\r\n      }\r\n\r\n      if (options.log && iteration % options.log === 0) {\r\n        console.log('iteration', iteration, 'error', error, 'rate', currentRate);\r\n      }\r\n\r\n      if (options.schedule && iteration % options.schedule.iterations === 0) {\r\n        options.schedule.function({ error: error, iteration: iteration });\r\n      }\r\n    }\r\n\r\n    if (options.clear) this.clear();\r\n\r\n    if (dropout) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        if (this.nodes[i].type === 'hidden' || this.nodes[i].type === 'constant') {\r\n          this.nodes[i].mask = 1 - this.dropout;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      error: error,\r\n      iterations: iteration,\r\n      time: Date.now() - start\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Performs one training epoch and returns the error\r\n   * private function used in this.train\r\n   */\r\n  _trainSet: function (set, batchSize, currentRate, momentum, costFunction) {\r\n    var errorSum = 0;\r\n    for (var i = 0; i < set.length; i++) {\r\n      var input = set[i].input;\r\n      var target = set[i].output;\r\n\r\n      var update = !!((i + 1) % batchSize === 0 || (i + 1) === set.length);\r\n\r\n      var output = this.activate(input, true);\r\n      this.propagate(currentRate, momentum, update, target);\r\n\r\n      errorSum += costFunction(target, output);\r\n    }\r\n    return errorSum / set.length;\r\n  },\r\n\r\n  /**\r\n   * Tests a set and returns the error and elapsed time\r\n   */\r\n  test: function (set, cost = methods.cost.MSE) {\r\n    // Check if dropout is enabled, set correct mask\r\n    var i;\r\n    if (this.dropout) {\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        if (this.nodes[i].type === 'hidden' || this.nodes[i].type === 'constant') {\r\n          this.nodes[i].mask = 1 - this.dropout;\r\n        }\r\n      }\r\n    }\r\n\r\n    var error = 0;\r\n    var start = Date.now();\r\n\r\n    for (i = 0; i < set.length; i++) {\r\n      let input = set[i].input;\r\n      let target = set[i].output;\r\n      let output = this.noTraceActivate(input);\r\n      error += cost(target, output);\r\n    }\r\n\r\n    error /= set.length;\r\n\r\n    var results = {\r\n      error: error,\r\n      time: Date.now() - start\r\n    };\r\n\r\n    return results;\r\n  },\r\n\r\n  /**\r\n   * Creates a json that can be used to create a graph with d3 and webcola\r\n   */\r\n  graph: function (width, height) {\r\n    var input = 0;\r\n    var output = 0;\r\n\r\n    var json = {\r\n      nodes: [],\r\n      links: [],\r\n      constraints: [{\r\n        type: 'alignment',\r\n        axis: 'x',\r\n        offsets: []\r\n      }, {\r\n        type: 'alignment',\r\n        axis: 'y',\r\n        offsets: []\r\n      }]\r\n    };\r\n\r\n    var i;\r\n    for (i = 0; i < this.nodes.length; i++) {\r\n      var node = this.nodes[i];\r\n\r\n      if (node.type === 'input') {\r\n        if (this.input === 1) {\r\n          json.constraints[0].offsets.push({\r\n            node: i,\r\n            offset: 0\r\n          });\r\n        } else {\r\n          json.constraints[0].offsets.push({\r\n            node: i,\r\n            offset: 0.8 * width / (this.input - 1) * input++\r\n          });\r\n        }\r\n        json.constraints[1].offsets.push({\r\n          node: i,\r\n          offset: 0\r\n        });\r\n      } else if (node.type === 'output') {\r\n        if (this.output === 1) {\r\n          json.constraints[0].offsets.push({\r\n            node: i,\r\n            offset: 0\r\n          });\r\n        } else {\r\n          json.constraints[0].offsets.push({\r\n            node: i,\r\n            offset: 0.8 * width / (this.output - 1) * output++\r\n          });\r\n        }\r\n        json.constraints[1].offsets.push({\r\n          node: i,\r\n          offset: -0.8 * height\r\n        });\r\n      }\r\n\r\n      json.nodes.push({\r\n        id: i,\r\n        name: node.type === 'hidden' ? node.squash.name : node.type.toUpperCase(),\r\n        activation: node.activation,\r\n        bias: node.bias\r\n      });\r\n    }\r\n\r\n    var connections = this.connections.concat(this.selfconns);\r\n    for (i = 0; i < connections.length; i++) {\r\n      var connection = connections[i];\r\n      if (connection.gater == null) {\r\n        json.links.push({\r\n          source: this.nodes.indexOf(connection.from),\r\n          target: this.nodes.indexOf(connection.to),\r\n          weight: connection.weight\r\n        });\r\n      } else {\r\n        // Add a gater 'node'\r\n        var index = json.nodes.length;\r\n        json.nodes.push({\r\n          id: index,\r\n          activation: connection.gater.activation,\r\n          name: 'GATE'\r\n        });\r\n        json.links.push({\r\n          source: this.nodes.indexOf(connection.from),\r\n          target: index,\r\n          weight: 1 / 2 * connection.weight\r\n        });\r\n        json.links.push({\r\n          source: index,\r\n          target: this.nodes.indexOf(connection.to),\r\n          weight: 1 / 2 * connection.weight\r\n        });\r\n        json.links.push({\r\n          source: this.nodes.indexOf(connection.gater),\r\n          target: index,\r\n          weight: connection.gater.activation,\r\n          gate: true\r\n        });\r\n      }\r\n    }\r\n\r\n    return json;\r\n  },\r\n\r\n  /**\r\n   * Convert the network to a json object\r\n   */\r\n  toJSON: function () {\r\n    var json = {\r\n      nodes: [],\r\n      connections: [],\r\n      input: this.input,\r\n      output: this.output,\r\n      dropout: this.dropout\r\n    };\r\n\r\n    // So we don't have to use expensive .indexOf()\r\n    var i;\r\n    for (i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].index = i;\r\n    }\r\n\r\n    for (i = 0; i < this.nodes.length; i++) {\r\n      let node = this.nodes[i];\r\n      let tojson = node.toJSON();\r\n      tojson.index = i;\r\n      json.nodes.push(tojson);\r\n\r\n      if (node.connections.self.weight !== 0) {\r\n        let tojson = node.connections.self.toJSON();\r\n        tojson.from = i;\r\n        tojson.to = i;\r\n\r\n        tojson.gater = node.connections.self.gater != null ? node.connections.self.gater.index : null;\r\n        json.connections.push(tojson);\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < this.connections.length; i++) {\r\n      let conn = this.connections[i];\r\n      let tojson = conn.toJSON();\r\n      tojson.from = conn.from.index;\r\n      tojson.to = conn.to.index;\r\n\r\n      tojson.gater = conn.gater != null ? conn.gater.index : null;\r\n\r\n      json.connections.push(tojson);\r\n    }\r\n\r\n    return json;\r\n  },\r\n\r\n  /**\r\n   * Sets the value of a property for every node in this network\r\n   */\r\n  set: function (values) {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].bias = values.bias || this.nodes[i].bias;\r\n      this.nodes[i].squash = values.squash || this.nodes[i].squash;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Evolves the network to reach a lower error on a dataset\r\n   */\r\n  evolve: async function (set, options) {\r\n    if (set[0].input.length !== this.input || set[0].output.length !== this.output) {\r\n      throw new Error('Dataset input/output size should be same as network input/output size!');\r\n    }\r\n\r\n    // Read the options\r\n    options = options || {};\r\n    var targetError = typeof options.error !== 'undefined' ? options.error : 0.05;\r\n    var growth = typeof options.growth !== 'undefined' ? options.growth : 0.0001;\r\n    var cost = options.cost || methods.cost.MSE;\r\n    var amount = options.amount || 1;\r\n\r\n    var threads = options.threads;\r\n    if (typeof threads === 'undefined') {\r\n      if (typeof window === 'undefined') { // Node.js\r\n        threads = __webpack_require__(/*! os */ \"./node_modules/os-browserify/browser.js\").cpus().length;\r\n      } else { // Browser\r\n        threads = navigator.hardwareConcurrency;\r\n      }\r\n    }\r\n\r\n    var start = Date.now();\r\n\r\n    if (typeof options.iterations === 'undefined' && typeof options.error === 'undefined') {\r\n      throw new Error('At least one of the following options must be specified: error, iterations');\r\n    } else if (typeof options.error === 'undefined') {\r\n      targetError = -1; // run until iterations\r\n    } else if (typeof options.iterations === 'undefined') {\r\n      options.iterations = 0; // run until target error\r\n    }\r\n\r\n    var fitnessFunction;\r\n    if (threads === 1) {\r\n      // Create the fitness function\r\n      fitnessFunction = function (genome) {\r\n        var score = 0;\r\n        for (var i = 0; i < amount; i++) {\r\n          score -= genome.test(set, cost).error;\r\n        }\r\n\r\n        score -= (genome.nodes.length - genome.input - genome.output + genome.connections.length + genome.gates.length) * growth;\r\n        score = isNaN(score) ? -Infinity : score; // this can cause problems with fitness proportionate selection\r\n\r\n        return score / amount;\r\n      };\r\n    } else {\r\n      // Serialize the dataset\r\n      var converted = multi.serializeDataSet(set);\r\n\r\n      // Create workers, send datasets\r\n      var workers = [];\r\n      if (typeof window === 'undefined') {\r\n        for (var i = 0; i < threads; i++) {\r\n          workers.push(new multi.workers.node.TestWorker(converted, cost));\r\n        }\r\n      } else {\r\n        for (var i = 0; i < threads; i++) {\r\n          workers.push(new multi.workers.browser.TestWorker(converted, cost));\r\n        }\r\n      }\r\n\r\n      fitnessFunction = function (population) {\r\n        return new Promise((resolve, reject) => {\r\n          // Create a queue\r\n          var queue = population.slice();\r\n          var done = 0;\r\n\r\n          // Start worker function\r\n          var startWorker = function (worker) {\r\n            if (!queue.length) {\r\n              if (++done === threads) resolve();\r\n              return;\r\n            }\r\n\r\n            var genome = queue.shift();\r\n\r\n            worker.evaluate(genome).then(function (result) {\r\n              genome.score = -result;\r\n              genome.score -= (genome.nodes.length - genome.input - genome.output +\r\n                genome.connections.length + genome.gates.length) * growth;\r\n              genome.score = isNaN(parseFloat(result)) ? -Infinity : genome.score;\r\n              startWorker(worker);\r\n            });\r\n          };\r\n\r\n          for (var i = 0; i < workers.length; i++) {\r\n            startWorker(workers[i]);\r\n          }\r\n        });\r\n      };\r\n\r\n      options.fitnessPopulation = true;\r\n    }\r\n\r\n    // Intialise the NEAT instance\r\n    options.network = this;\r\n    var neat = new Neat(this.input, this.output, fitnessFunction, options);\r\n\r\n    var error = -Infinity;\r\n    var bestFitness = -Infinity;\r\n    var bestGenome;\r\n\r\n    while (error < -targetError && (options.iterations === 0 || neat.generation < options.iterations)) {\r\n      let fittest = await neat.evolve();\r\n      let fitness = fittest.score;\r\n      error = fitness + (fittest.nodes.length - fittest.input - fittest.output + fittest.connections.length + fittest.gates.length) * growth;\r\n\r\n      if (fitness > bestFitness) {\r\n        bestFitness = fitness;\r\n        bestGenome = fittest;\r\n      }\r\n\r\n      if (options.log && neat.generation % options.log === 0) {\r\n        console.log('iteration', neat.generation, 'fitness', fitness, 'error', -error);\r\n      }\r\n\r\n      if (options.schedule && neat.generation % options.schedule.iterations === 0) {\r\n        options.schedule.function({ fitness: fitness, error: -error, iteration: neat.generation });\r\n      }\r\n    }\r\n\r\n    if (threads > 1) {\r\n      for (var i = 0; i < workers.length; i++) workers[i].terminate();\r\n    }\r\n\r\n    if (typeof bestGenome !== 'undefined') {\r\n      this.nodes = bestGenome.nodes;\r\n      this.connections = bestGenome.connections;\r\n      this.selfconns = bestGenome.selfconns;\r\n      this.gates = bestGenome.gates;\r\n\r\n      if (options.clear) this.clear();\r\n    }\r\n\r\n    return {\r\n      error: -error,\r\n      iterations: neat.generation,\r\n      time: Date.now() - start\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Creates a standalone function of the network which can be run without the\r\n   * need of a library\r\n   */\r\n  standalone: function () {\r\n    var present = [];\r\n    var activations = [];\r\n    var states = [];\r\n    var lines = [];\r\n    var functions = [];\r\n\r\n    var i;\r\n    for (i = 0; i < this.input; i++) {\r\n      var node = this.nodes[i];\r\n      activations.push(node.activation);\r\n      states.push(node.state);\r\n    }\r\n\r\n    lines.push('for(var i = 0; i < input.length; i++) A[i] = input[i];');\r\n\r\n    // So we don't have to use expensive .indexOf()\r\n    for (i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].index = i;\r\n    }\r\n\r\n    for (i = this.input; i < this.nodes.length; i++) {\r\n      let node = this.nodes[i];\r\n      activations.push(node.activation);\r\n      states.push(node.state);\r\n\r\n      var functionIndex = present.indexOf(node.squash.name);\r\n\r\n      if (functionIndex === -1) {\r\n        functionIndex = present.length;\r\n        present.push(node.squash.name);\r\n        functions.push(node.squash.toString());\r\n      }\r\n\r\n      var incoming = [];\r\n      for (var j = 0; j < node.connections.in.length; j++) {\r\n        var conn = node.connections.in[j];\r\n        var computation = `A[${conn.from.index}] * ${conn.weight}`;\r\n\r\n        if (conn.gater != null) {\r\n          computation += ` * A[${conn.gater.index}]`;\r\n        }\r\n\r\n        incoming.push(computation);\r\n      }\r\n\r\n      if (node.connections.self.weight) {\r\n        let conn = node.connections.self;\r\n        let computation = `S[${i}] * ${conn.weight}`;\r\n\r\n        if (conn.gater != null) {\r\n          computation += ` * A[${conn.gater.index}]`;\r\n        }\r\n\r\n        incoming.push(computation);\r\n      }\r\n\r\n      var line1 = `S[${i}] = ${incoming.join(' + ')} + ${node.bias};`;\r\n      var line2 = `A[${i}] = F[${functionIndex}](S[${i}])${!node.mask ? ' * ' + node.mask : ''};`;\r\n      lines.push(line1);\r\n      lines.push(line2);\r\n    }\r\n\r\n    var output = [];\r\n    for (i = this.nodes.length - this.output; i < this.nodes.length; i++) {\r\n      output.push(`A[${i}]`);\r\n    }\r\n\r\n    output = `return [${output.join(',')}];`;\r\n    lines.push(output);\r\n\r\n    var total = '';\r\n    total += `var F = [${functions.toString()}];\\r\\n`;\r\n    total += `var A = [${activations.toString()}];\\r\\n`;\r\n    total += `var S = [${states.toString()}];\\r\\n`;\r\n    total += `function activate(input){\\r\\n${lines.join('\\r\\n')}\\r\\n}`;\r\n\r\n    return total;\r\n  },\r\n\r\n  /**\r\n   * Serialize to send to workers efficiently\r\n   */\r\n  serialize: function () {\r\n    var activations = [];\r\n    var states = [];\r\n    var conns = [];\r\n    var squashes = [\r\n      'LOGISTIC', 'TANH', 'IDENTITY', 'STEP', 'RELU', 'SOFTSIGN', 'SINUSOID',\r\n      'GAUSSIAN', 'BENT_IDENTITY', 'BIPOLAR', 'BIPOLAR_SIGMOID', 'HARD_TANH',\r\n      'ABSOLUTE', 'INVERSE', 'SELU'\r\n    ];\r\n\r\n    conns.push(this.input);\r\n    conns.push(this.output);\r\n\r\n    var i;\r\n    for (i = 0; i < this.nodes.length; i++) {\r\n      let node = this.nodes[i];\r\n      node.index = i;\r\n      activations.push(node.activation);\r\n      states.push(node.state);\r\n    }\r\n\r\n    for (i = this.input; i < this.nodes.length; i++) {\r\n      let node = this.nodes[i];\r\n      conns.push(node.index);\r\n      conns.push(node.bias);\r\n      conns.push(squashes.indexOf(node.squash.name));\r\n\r\n      conns.push(node.connections.self.weight);\r\n      conns.push(node.connections.self.gater == null ? -1 : node.connections.self.gater.index);\r\n\r\n      for (var j = 0; j < node.connections.in.length; j++) {\r\n        let conn = node.connections.in[j];\r\n\r\n        conns.push(conn.from.index);\r\n        conns.push(conn.weight);\r\n        conns.push(conn.gater == null ? -1 : conn.gater.index);\r\n      }\r\n\r\n      conns.push(-2); // stop token -> next node\r\n    }\r\n\r\n    return [activations, states, conns];\r\n  }\r\n};\r\n\r\n/**\r\n * Convert a json object to a network\r\n */\r\nNetwork.fromJSON = function (json) {\r\n  var network = new Network(json.input, json.output);\r\n  network.dropout = json.dropout;\r\n  network.nodes = [];\r\n  network.connections = [];\r\n\r\n  var i;\r\n  for (i = 0; i < json.nodes.length; i++) {\r\n    network.nodes.push(Node.fromJSON(json.nodes[i]));\r\n  }\r\n\r\n  for (i = 0; i < json.connections.length; i++) {\r\n    var conn = json.connections[i];\r\n\r\n    var connection = network.connect(network.nodes[conn.from], network.nodes[conn.to])[0];\r\n    connection.weight = conn.weight;\r\n\r\n    if (conn.gater != null) {\r\n      network.gate(network.nodes[conn.gater], connection);\r\n    }\r\n  }\r\n\r\n  return network;\r\n};\r\n\r\n/**\r\n * Merge two networks into one\r\n */\r\nNetwork.merge = function (network1, network2) {\r\n  // Create a copy of the networks\r\n  network1 = Network.fromJSON(network1.toJSON());\r\n  network2 = Network.fromJSON(network2.toJSON());\r\n\r\n  // Check if output and input size are the same\r\n  if (network1.output !== network2.input) {\r\n    throw new Error('Output size of network1 should be the same as the input size of network2!');\r\n  }\r\n\r\n  // Redirect all connections from network2 input from network1 output\r\n  var i;\r\n  for (i = 0; i < network2.connections.length; i++) {\r\n    let conn = network2.connections[i];\r\n    if (conn.from.type === 'input') {\r\n      let index = network2.nodes.indexOf(conn.from);\r\n\r\n      // redirect\r\n      conn.from = network1.nodes[network1.nodes.length - 1 - index];\r\n    }\r\n  }\r\n\r\n  // Delete input nodes of network2\r\n  for (i = network2.input - 1; i >= 0; i--) {\r\n    network2.nodes.splice(i, 1);\r\n  }\r\n\r\n  // Change the node type of network1's output nodes (now hidden)\r\n  for (i = network1.nodes.length - network1.output; i < network1.nodes.length; i++) {\r\n    network1.nodes[i].type = 'hidden';\r\n  }\r\n\r\n  // Create one network from both networks\r\n  network1.connections = network1.connections.concat(network2.connections);\r\n  network1.nodes = network1.nodes.concat(network2.nodes);\r\n\r\n  return network1;\r\n};\r\n\r\n/**\r\n * Create an offspring from two parent networks\r\n */\r\nNetwork.crossOver = function (network1, network2, equal) {\r\n  if (network1.input !== network2.input || network1.output !== network2.output) {\r\n    throw new Error(\"Networks don't have the same input/output size!\");\r\n  }\r\n\r\n  // Initialise offspring\r\n  var offspring = new Network(network1.input, network1.output);\r\n  offspring.connections = [];\r\n  offspring.nodes = [];\r\n\r\n  // Save scores and create a copy\r\n  var score1 = network1.score || 0;\r\n  var score2 = network2.score || 0;\r\n\r\n  // Determine offspring node size\r\n  var size;\r\n  if (equal || score1 === score2) {\r\n    let max = Math.max(network1.nodes.length, network2.nodes.length);\r\n    let min = Math.min(network1.nodes.length, network2.nodes.length);\r\n    size = Math.floor(Math.random() * (max - min + 1) + min);\r\n  } else if (score1 > score2) {\r\n    size = network1.nodes.length;\r\n  } else {\r\n    size = network2.nodes.length;\r\n  }\r\n\r\n  // Rename some variables for easier reading\r\n  var outputSize = network1.output;\r\n\r\n  // Set indexes so we don't need indexOf\r\n  var i;\r\n  for (i = 0; i < network1.nodes.length; i++) {\r\n    network1.nodes[i].index = i;\r\n  }\r\n\r\n  for (i = 0; i < network2.nodes.length; i++) {\r\n    network2.nodes[i].index = i;\r\n  }\r\n\r\n  // Assign nodes from parents to offspring\r\n  for (i = 0; i < size; i++) {\r\n    // Determine if an output node is needed\r\n    var node;\r\n    if (i < size - outputSize) {\r\n      let random = Math.random();\r\n      node = random >= 0.5 ? network1.nodes[i] : network2.nodes[i];\r\n      let other = random < 0.5 ? network1.nodes[i] : network2.nodes[i];\r\n\r\n      if (typeof node === 'undefined' || node.type === 'output') {\r\n        node = other;\r\n      }\r\n    } else {\r\n      if (Math.random() >= 0.5) {\r\n        node = network1.nodes[network1.nodes.length + i - size];\r\n      } else {\r\n        node = network2.nodes[network2.nodes.length + i - size];\r\n      }\r\n    }\r\n\r\n    var newNode = new Node();\r\n    newNode.bias = node.bias;\r\n    newNode.squash = node.squash;\r\n    newNode.type = node.type;\r\n\r\n    offspring.nodes.push(newNode);\r\n  }\r\n\r\n  // Create arrays of connection genes\r\n  var n1conns = {};\r\n  var n2conns = {};\r\n\r\n  // Normal connections\r\n  for (i = 0; i < network1.connections.length; i++) {\r\n    let conn = network1.connections[i];\r\n    let data = {\r\n      weight: conn.weight,\r\n      from: conn.from.index,\r\n      to: conn.to.index,\r\n      gater: conn.gater != null ? conn.gater.index : -1\r\n    };\r\n    n1conns[Connection.innovationID(data.from, data.to)] = data;\r\n  }\r\n\r\n  // Selfconnections\r\n  for (i = 0; i < network1.selfconns.length; i++) {\r\n    let conn = network1.selfconns[i];\r\n    let data = {\r\n      weight: conn.weight,\r\n      from: conn.from.index,\r\n      to: conn.to.index,\r\n      gater: conn.gater != null ? conn.gater.index : -1\r\n    };\r\n    n1conns[Connection.innovationID(data.from, data.to)] = data;\r\n  }\r\n\r\n  // Normal connections\r\n  for (i = 0; i < network2.connections.length; i++) {\r\n    let conn = network2.connections[i];\r\n    let data = {\r\n      weight: conn.weight,\r\n      from: conn.from.index,\r\n      to: conn.to.index,\r\n      gater: conn.gater != null ? conn.gater.index : -1\r\n    };\r\n    n2conns[Connection.innovationID(data.from, data.to)] = data;\r\n  }\r\n\r\n  // Selfconnections\r\n  for (i = 0; i < network2.selfconns.length; i++) {\r\n    let conn = network2.selfconns[i];\r\n    let data = {\r\n      weight: conn.weight,\r\n      from: conn.from.index,\r\n      to: conn.to.index,\r\n      gater: conn.gater != null ? conn.gater.index : -1\r\n    };\r\n    n2conns[Connection.innovationID(data.from, data.to)] = data;\r\n  }\r\n\r\n  // Split common conn genes from disjoint or excess conn genes\r\n  var connections = [];\r\n  var keys1 = Object.keys(n1conns);\r\n  var keys2 = Object.keys(n2conns);\r\n  for (i = keys1.length - 1; i >= 0; i--) {\r\n    // Common gene\r\n    if (typeof n2conns[keys1[i]] !== 'undefined') {\r\n      let conn = Math.random() >= 0.5 ? n1conns[keys1[i]] : n2conns[keys1[i]];\r\n      connections.push(conn);\r\n\r\n      // Because deleting is expensive, just set it to some value\r\n      n2conns[keys1[i]] = undefined;\r\n    } else if (score1 >= score2 || equal) {\r\n      connections.push(n1conns[keys1[i]]);\r\n    }\r\n  }\r\n\r\n  // Excess/disjoint gene\r\n  if (score2 >= score1 || equal) {\r\n    for (i = 0; i < keys2.length; i++) {\r\n      if (typeof n2conns[keys2[i]] !== 'undefined') {\r\n        connections.push(n2conns[keys2[i]]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Add common conn genes uniformly\r\n  for (i = 0; i < connections.length; i++) {\r\n    let connData = connections[i];\r\n    if (connData.to < size && connData.from < size) {\r\n      let from = offspring.nodes[connData.from];\r\n      let to = offspring.nodes[connData.to];\r\n      let conn = offspring.connect(from, to)[0];\r\n\r\n      conn.weight = connData.weight;\r\n\r\n      if (connData.gater !== -1 && connData.gater < size) {\r\n        offspring.gate(offspring.nodes[connData.gater], conn);\r\n      }\r\n    }\r\n  }\r\n\r\n  return offspring;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/architecture/network.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/architecture/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/neataptic/src/architecture/node.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\r\nmodule.exports = Node;\r\n\r\n/* Import */\r\nvar methods = __webpack_require__(/*! ../methods/methods */ \"./node_modules/neataptic/src/methods/methods.js\");\r\nvar Connection = __webpack_require__(/*! ./connection */ \"./node_modules/neataptic/src/architecture/connection.js\");\r\nvar config = __webpack_require__(/*! ../config */ \"./node_modules/neataptic/src/config.js\");\r\n\r\n/*******************************************************************************\r\n                                         NODE\r\n*******************************************************************************/\r\n\r\nfunction Node (type) {\r\n  this.bias = (type === 'input') ? 0 : Math.random() * 0.2 - 0.1;\r\n  this.squash = methods.activation.LOGISTIC;\r\n  this.type = type || 'hidden';\r\n\r\n  this.activation = 0;\r\n  this.state = 0;\r\n  this.old = 0;\r\n\r\n  // For dropout\r\n  this.mask = 1;\r\n\r\n  // For tracking momentum\r\n  this.previousDeltaBias = 0;\r\n\r\n  // Batch training\r\n  this.totalDeltaBias = 0;\r\n\r\n  this.connections = {\r\n    in: [],\r\n    out: [],\r\n    gated: [],\r\n    self: new Connection(this, this, 0)\r\n  };\r\n\r\n  // Data for backpropagation\r\n  this.error = {\r\n    responsibility: 0,\r\n    projected: 0,\r\n    gated: 0\r\n  };\r\n}\r\n\r\nNode.prototype = {\r\n  /**\r\n   * Activates the node\r\n   */\r\n  activate: function (input) {\r\n    // Check if an input is given\r\n    if (typeof input !== 'undefined') {\r\n      this.activation = input;\r\n      return this.activation;\r\n    }\r\n\r\n    this.old = this.state;\r\n\r\n    // All activation sources coming from the node itself\r\n    this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;\r\n\r\n    // Activation sources coming from connections\r\n    var i;\r\n    for (i = 0; i < this.connections.in.length; i++) {\r\n      var connection = this.connections.in[i];\r\n      this.state += connection.from.activation * connection.weight * connection.gain;\r\n    }\r\n\r\n    // Squash the values received\r\n    this.activation = this.squash(this.state) * this.mask;\r\n    this.derivative = this.squash(this.state, true);\r\n\r\n    // Update traces\r\n    var nodes = [];\r\n    var influences = [];\r\n\r\n    for (i = 0; i < this.connections.gated.length; i++) {\r\n      let conn = this.connections.gated[i];\r\n      let node = conn.to;\r\n\r\n      let index = nodes.indexOf(node);\r\n      if (index > -1) {\r\n        influences[index] += conn.weight * conn.from.activation;\r\n      } else {\r\n        nodes.push(node);\r\n        influences.push(conn.weight * conn.from.activation +\r\n          (node.connections.self.gater === this ? node.old : 0));\r\n      }\r\n\r\n      // Adjust the gain to this nodes' activation\r\n      conn.gain = this.activation;\r\n    }\r\n\r\n    for (i = 0; i < this.connections.in.length; i++) {\r\n      let connection = this.connections.in[i];\r\n\r\n      // Elegibility trace\r\n      connection.elegibility = this.connections.self.gain * this.connections.self.weight *\r\n        connection.elegibility + connection.from.activation * connection.gain;\r\n\r\n      // Extended trace\r\n      for (var j = 0; j < nodes.length; j++) {\r\n        let node = nodes[j];\r\n        let influence = influences[j];\r\n\r\n        let index = connection.xtrace.nodes.indexOf(node);\r\n\r\n        if (index > -1) {\r\n          connection.xtrace.values[index] = node.connections.self.gain * node.connections.self.weight *\r\n            connection.xtrace.values[index] + this.derivative * connection.elegibility * influence;\r\n        } else {\r\n          // Does not exist there yet, might be through mutation\r\n          connection.xtrace.nodes.push(node);\r\n          connection.xtrace.values.push(this.derivative * connection.elegibility * influence);\r\n        }\r\n      }\r\n    }\r\n\r\n    return this.activation;\r\n  },\r\n\r\n  /**\r\n   * Activates the node without calculating elegibility traces and such\r\n   */\r\n  noTraceActivate: function (input) {\r\n    // Check if an input is given\r\n    if (typeof input !== 'undefined') {\r\n      this.activation = input;\r\n      return this.activation;\r\n    }\r\n\r\n    // All activation sources coming from the node itself\r\n    this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;\r\n\r\n    // Activation sources coming from connections\r\n    var i;\r\n    for (i = 0; i < this.connections.in.length; i++) {\r\n      var connection = this.connections.in[i];\r\n      this.state += connection.from.activation * connection.weight * connection.gain;\r\n    }\r\n\r\n    // Squash the values received\r\n    this.activation = this.squash(this.state);\r\n\r\n    for (i = 0; i < this.connections.gated.length; i++) {\r\n      this.connections.gated[i].gain = this.activation;\r\n    }\r\n\r\n    return this.activation;\r\n  },\r\n\r\n  /**\r\n   * Back-propagate the error, aka learn\r\n   */\r\n  propagate: function (rate, momentum, update, target) {\r\n    momentum = momentum || 0;\r\n    rate = rate || 0.3;\r\n\r\n    // Error accumulator\r\n    var error = 0;\r\n\r\n    // Output nodes get their error from the enviroment\r\n    if (this.type === 'output') {\r\n      this.error.responsibility = this.error.projected = target - this.activation;\r\n    } else { // the rest of the nodes compute their error responsibilities by backpropagation\r\n      // error responsibilities from all the connections projected from this node\r\n      var i;\r\n      for (i = 0; i < this.connections.out.length; i++) {\r\n        let connection = this.connections.out[i];\r\n        let node = connection.to;\r\n        // Eq. 21\r\n        error += node.error.responsibility * connection.weight * connection.gain;\r\n      }\r\n\r\n      // Projected error responsibility\r\n      this.error.projected = this.derivative * error;\r\n\r\n      // Error responsibilities from all connections gated by this neuron\r\n      error = 0;\r\n\r\n      for (i = 0; i < this.connections.gated.length; i++) {\r\n        let conn = this.connections.gated[i];\r\n        let node = conn.to;\r\n        let influence = node.connections.self.gater === this ? node.old : 0;\r\n\r\n        influence += conn.weight * conn.from.activation;\r\n        error += node.error.responsibility * influence;\r\n      }\r\n\r\n      // Gated error responsibility\r\n      this.error.gated = this.derivative * error;\r\n\r\n      // Error responsibility\r\n      this.error.responsibility = this.error.projected + this.error.gated;\r\n    }\r\n\r\n    if (this.type === 'constant') return;\r\n\r\n    // Adjust all the node's incoming connections\r\n    for (i = 0; i < this.connections.in.length; i++) {\r\n      let connection = this.connections.in[i];\r\n\r\n      let gradient = this.error.projected * connection.elegibility;\r\n\r\n      for (var j = 0; j < connection.xtrace.nodes.length; j++) {\r\n        let node = connection.xtrace.nodes[j];\r\n        let value = connection.xtrace.values[j];\r\n        gradient += node.error.responsibility * value;\r\n      }\r\n\r\n      // Adjust weight\r\n      let deltaWeight = rate * gradient * this.mask;\r\n      connection.totalDeltaWeight += deltaWeight;\r\n      if (update) {\r\n        connection.totalDeltaWeight += momentum * connection.previousDeltaWeight;\r\n        connection.weight += connection.totalDeltaWeight;\r\n        connection.previousDeltaWeight = connection.totalDeltaWeight;\r\n        connection.totalDeltaWeight = 0;\r\n      }\r\n    }\r\n\r\n    // Adjust bias\r\n    var deltaBias = rate * this.error.responsibility;\r\n    this.totalDeltaBias += deltaBias;\r\n    if (update) {\r\n      this.totalDeltaBias += momentum * this.previousDeltaBias;\r\n      this.bias += this.totalDeltaBias;\r\n      this.previousDeltaBias = this.totalDeltaBias;\r\n      this.totalDeltaBias = 0;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Creates a connection from this node to the given node\r\n   */\r\n  connect: function (target, weight) {\r\n    var connections = [];\r\n    if (typeof target.bias !== 'undefined') { // must be a node!\r\n      if (target === this) {\r\n        // Turn on the self connection by setting the weight\r\n        if (this.connections.self.weight !== 0) {\r\n          if (config.warnings) console.warn('This connection already exists!');\r\n        } else {\r\n          this.connections.self.weight = weight || 1;\r\n        }\r\n        connections.push(this.connections.self);\r\n      } else if (this.isProjectingTo(target)) {\r\n        throw new Error('Already projecting a connection to this node!');\r\n      } else {\r\n        let connection = new Connection(this, target, weight);\r\n        target.connections.in.push(connection);\r\n        this.connections.out.push(connection);\r\n\r\n        connections.push(connection);\r\n      }\r\n    } else { // should be a group\r\n      for (var i = 0; i < target.nodes.length; i++) {\r\n        let connection = new Connection(this, target.nodes[i], weight);\r\n        target.nodes[i].connections.in.push(connection);\r\n        this.connections.out.push(connection);\r\n        target.connections.in.push(connection);\r\n\r\n        connections.push(connection);\r\n      }\r\n    }\r\n    return connections;\r\n  },\r\n\r\n  /**\r\n   * Disconnects this node from the other node\r\n   */\r\n  disconnect: function (node, twosided) {\r\n    if (this === node) {\r\n      this.connections.self.weight = 0;\r\n      return;\r\n    }\r\n\r\n    for (var i = 0; i < this.connections.out.length; i++) {\r\n      let conn = this.connections.out[i];\r\n      if (conn.to === node) {\r\n        this.connections.out.splice(i, 1);\r\n        let j = conn.to.connections.in.indexOf(conn);\r\n        conn.to.connections.in.splice(j, 1);\r\n        if (conn.gater !== null) conn.gater.ungate(conn);\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (twosided) {\r\n      node.disconnect(this);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Make this node gate a connection\r\n   */\r\n  gate: function (connections) {\r\n    if (!Array.isArray(connections)) {\r\n      connections = [connections];\r\n    }\r\n\r\n    for (var i = 0; i < connections.length; i++) {\r\n      var connection = connections[i];\r\n\r\n      this.connections.gated.push(connection);\r\n      connection.gater = this;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Removes the gates from this node from the given connection(s)\r\n   */\r\n  ungate: function (connections) {\r\n    if (!Array.isArray(connections)) {\r\n      connections = [connections];\r\n    }\r\n\r\n    for (var i = connections.length - 1; i >= 0; i--) {\r\n      var connection = connections[i];\r\n\r\n      var index = this.connections.gated.indexOf(connection);\r\n      this.connections.gated.splice(index, 1);\r\n      connection.gater = null;\r\n      connection.gain = 1;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Clear the context of the node\r\n   */\r\n  clear: function () {\r\n    for (var i = 0; i < this.connections.in.length; i++) {\r\n      var connection = this.connections.in[i];\r\n\r\n      connection.elegibility = 0;\r\n      connection.xtrace = {\r\n        nodes: [],\r\n        values: []\r\n      };\r\n    }\r\n\r\n    for (i = 0; i < this.connections.gated.length; i++) {\r\n      let conn = this.connections.gated[i];\r\n      conn.gain = 0;\r\n    }\r\n\r\n    this.error.responsibility = this.error.projected = this.error.gated = 0;\r\n    this.old = this.state = this.activation = 0;\r\n  },\r\n\r\n  /**\r\n   * Mutates the node with the given method\r\n   */\r\n  mutate: function (method) {\r\n    if (typeof method === 'undefined') {\r\n      throw new Error('No mutate method given!');\r\n    } else if (!(method.name in methods.mutation)) {\r\n      throw new Error('This method does not exist!');\r\n    }\r\n\r\n    switch (method) {\r\n      case methods.mutation.MOD_ACTIVATION:\r\n        // Can't be the same squash\r\n        var squash = method.allowed[(method.allowed.indexOf(this.squash) + Math.floor(Math.random() * (method.allowed.length - 1)) + 1) % method.allowed.length];\r\n        this.squash = squash;\r\n        break;\r\n      case methods.mutation.MOD_BIAS:\r\n        var modification = Math.random() * (method.max - method.min) + method.min;\r\n        this.bias += modification;\r\n        break;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Checks if this node is projecting to the given node\r\n   */\r\n  isProjectingTo: function (node) {\r\n    if (node === this && this.connections.self.weight !== 0) return true;\r\n\r\n    for (var i = 0; i < this.connections.out.length; i++) {\r\n      var conn = this.connections.out[i];\r\n      if (conn.to === node) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  },\r\n\r\n  /**\r\n   * Checks if the given node is projecting to this node\r\n   */\r\n  isProjectedBy: function (node) {\r\n    if (node === this && this.connections.self.weight !== 0) return true;\r\n\r\n    for (var i = 0; i < this.connections.in.length; i++) {\r\n      var conn = this.connections.in[i];\r\n      if (conn.from === node) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  },\r\n\r\n  /**\r\n   * Converts the node to a json object\r\n   */\r\n  toJSON: function () {\r\n    var json = {\r\n      bias: this.bias,\r\n      type: this.type,\r\n      squash: this.squash.name,\r\n      mask: this.mask\r\n    };\r\n\r\n    return json;\r\n  }\r\n};\r\n\r\n/**\r\n * Convert a json object to a node\r\n */\r\nNode.fromJSON = function (json) {\r\n  var node = new Node();\r\n  node.bias = json.bias;\r\n  node.type = json.type;\r\n  node.mask = json.mask;\r\n  node.squash = methods.activation[json.squash];\r\n\r\n  return node;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/architecture/node.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/config.js":
/*!**********************************************!*\
  !*** ./node_modules/neataptic/src/config.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                      CONFIG\r\n*******************************************************************************/\r\n\r\n// Config\r\nvar config = {\r\n  warnings: false\r\n};\r\n\r\n/* Export */\r\nmodule.exports = config;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/config.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/activation.js":
/*!**********************************************************!*\
  !*** ./node_modules/neataptic/src/methods/activation.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                  ACTIVATION FUNCTIONS\r\n*******************************************************************************/\r\n\r\n// https://en.wikipedia.org/wiki/Activation_function\r\n// https://stats.stackexchange.com/questions/115258/comprehensive-list-of-activation-functions-in-neural-networks-with-pros-cons\r\nvar activation = {\r\n  LOGISTIC: function (x, derivate) {\r\n    var fx = 1 / (1 + Math.exp(-x));\r\n    if (!derivate) return fx;\r\n    return fx * (1 - fx);\r\n  },\r\n  TANH: function (x, derivate) {\r\n    if (derivate) return 1 - Math.pow(Math.tanh(x), 2);\r\n    return Math.tanh(x);\r\n  },\r\n  IDENTITY: function (x, derivate) {\r\n    return derivate ? 1 : x;\r\n  },\r\n  STEP: function (x, derivate) {\r\n    return derivate ? 0 : x > 0 ? 1 : 0;\r\n  },\r\n  RELU: function (x, derivate) {\r\n    if (derivate) return x > 0 ? 1 : 0;\r\n    return x > 0 ? x : 0;\r\n  },\r\n  SOFTSIGN: function (x, derivate) {\r\n    var d = 1 + Math.abs(x);\r\n    if (derivate) return x / Math.pow(d, 2);\r\n    return x / d;\r\n  },\r\n  SINUSOID: function (x, derivate) {\r\n    if (derivate) return Math.cos(x);\r\n    return Math.sin(x);\r\n  },\r\n  GAUSSIAN: function (x, derivate) {\r\n    var d = Math.exp(-Math.pow(x, 2));\r\n    if (derivate) return -2 * x * d;\r\n    return d;\r\n  },\r\n  BENT_IDENTITY: function (x, derivate) {\r\n    var d = Math.sqrt(Math.pow(x, 2) + 1);\r\n    if (derivate) return x / (2 * d) + 1;\r\n    return (d - 1) / 2 + x;\r\n  },\r\n  BIPOLAR: function (x, derivate) {\r\n    return derivate ? 0 : x > 0 ? 1 : -1;\r\n  },\r\n  BIPOLAR_SIGMOID: function (x, derivate) {\r\n    var d = 2 / (1 + Math.exp(-x)) - 1;\r\n    if (derivate) return 1 / 2 * (1 + d) * (1 - d);\r\n    return d;\r\n  },\r\n  HARD_TANH: function (x, derivate) {\r\n    if (derivate) return x > -1 && x < 1 ? 1 : 0;\r\n    return Math.max(-1, Math.min(1, x));\r\n  },\r\n  ABSOLUTE: function (x, derivate) {\r\n    if (derivate) return x < 0 ? -1 : 1;\r\n    return Math.abs(x);\r\n  },\r\n  INVERSE: function (x, derivate) {\r\n    if (derivate) return -1;\r\n    return 1 - x;\r\n  },\r\n  // https://arxiv.org/pdf/1706.02515.pdf\r\n  SELU: function (x, derivate) {\r\n    var alpha = 1.6732632423543772848170429916717;\r\n    var scale = 1.0507009873554804934193349852946;\r\n    var fx = x > 0 ? x : alpha * Math.exp(x) - alpha;\r\n    if (derivate) { return x > 0 ? scale : (fx + alpha) * scale; }\r\n    return fx * scale;\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = activation;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/activation.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/connection.js":
/*!**********************************************************!*\
  !*** ./node_modules/neataptic/src/methods/connection.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                    CONNECTION\r\n*******************************************************************************/\r\n\r\n// Specifies in what manner two groups are connected\r\nvar connection = {\r\n  ALL_TO_ALL: {\r\n    name: 'OUTPUT'\r\n  },\r\n  ALL_TO_ELSE: {\r\n    name: 'INPUT'\r\n  },\r\n  ONE_TO_ONE: {\r\n    name: 'SELF'\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = connection;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/connection.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/cost.js":
/*!****************************************************!*\
  !*** ./node_modules/neataptic/src/methods/cost.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                    COST FUNCTIONS\r\n*******************************************************************************/\r\n\r\n// https://en.wikipedia.org/wiki/Loss_function\r\nvar cost = {\r\n  // Cross entropy error\r\n  CROSS_ENTROPY: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      // Avoid negative and zero numbers, use 1e-15 http://bit.ly/2p5W29A\r\n      error -= target[i] * Math.log(Math.max(output[i], 1e-15)) + (1 - target[i]) * Math.log(1 - Math.max(output[i], 1e-15));\r\n    }\r\n    return error / output.length;\r\n  },\r\n  // Mean Squared Error\r\n  MSE: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      error += Math.pow(target[i] - output[i], 2);\r\n    }\r\n\r\n    return error / output.length;\r\n  },\r\n  // Binary error\r\n  BINARY: function (target, output) {\r\n    var misses = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      misses += Math.round(target[i] * 2) !== Math.round(output[i] * 2);\r\n    }\r\n\r\n    return misses;\r\n  },\r\n  // Mean Absolute Error\r\n  MAE: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      error += Math.abs(target[i] - output[i]);\r\n    }\r\n\r\n    return error / output.length;\r\n  },\r\n  // Mean Absolute Percentage Error\r\n  MAPE: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      error += Math.abs((output[i] - target[i]) / Math.max(target[i], 1e-15));\r\n    }\r\n\r\n    return error / output.length;\r\n  },\r\n  // Mean Squared Logarithmic Error\r\n  MSLE: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      error += Math.log(Math.max(target[i], 1e-15)) - Math.log(Math.max(output[i], 1e-15));\r\n    }\r\n\r\n    return error;\r\n  },\r\n  // Hinge loss, for classifiers\r\n  HINGE: function (target, output) {\r\n    var error = 0;\r\n    for (var i = 0; i < output.length; i++) {\r\n      error += Math.max(0, 1 - target[i] * output[i]);\r\n    }\r\n\r\n    return error;\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = cost;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/cost.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/crossover.js":
/*!*********************************************************!*\
  !*** ./node_modules/neataptic/src/methods/crossover.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                      CROSSOVER\r\n*******************************************************************************/\r\n\r\n// https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)\r\nvar crossover = {\r\n  SINGLE_POINT: {\r\n    name: 'SINGLE_POINT',\r\n    config: [0.4]\r\n  },\r\n  TWO_POINT: {\r\n    name: 'TWO_POINT',\r\n    config: [0.4, 0.9]\r\n  },\r\n  UNIFORM: {\r\n    name: 'UNIFORM'\r\n  },\r\n  AVERAGE: {\r\n    name: 'AVERAGE'\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = crossover;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/crossover.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/gating.js":
/*!******************************************************!*\
  !*** ./node_modules/neataptic/src/methods/gating.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                    GATING\r\n*******************************************************************************/\r\n\r\n// Specifies how to gate a connection between two groups of multiple neurons\r\nvar gating = {\r\n  OUTPUT: {\r\n    name: 'OUTPUT'\r\n  },\r\n  INPUT: {\r\n    name: 'INPUT'\r\n  },\r\n  SELF: {\r\n    name: 'SELF'\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = gating;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/gating.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/methods.js":
/*!*******************************************************!*\
  !*** ./node_modules/neataptic/src/methods/methods.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*******************************************************************************\r\n                                  METHODS\r\n*******************************************************************************/\r\n\r\nvar methods = {\r\n  activation: __webpack_require__(/*! ./activation */ \"./node_modules/neataptic/src/methods/activation.js\"),\r\n  mutation: __webpack_require__(/*! ./mutation */ \"./node_modules/neataptic/src/methods/mutation.js\"),\r\n  selection: __webpack_require__(/*! ./selection */ \"./node_modules/neataptic/src/methods/selection.js\"),\r\n  crossover: __webpack_require__(/*! ./crossover */ \"./node_modules/neataptic/src/methods/crossover.js\"),\r\n  cost: __webpack_require__(/*! ./cost */ \"./node_modules/neataptic/src/methods/cost.js\"),\r\n  gating: __webpack_require__(/*! ./gating */ \"./node_modules/neataptic/src/methods/gating.js\"),\r\n  connection: __webpack_require__(/*! ./connection */ \"./node_modules/neataptic/src/methods/connection.js\"),\r\n  rate: __webpack_require__(/*! ./rate */ \"./node_modules/neataptic/src/methods/rate.js\")\r\n};\r\n\r\n/** Export */\r\nmodule.exports = methods;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/methods.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/mutation.js":
/*!********************************************************!*\
  !*** ./node_modules/neataptic/src/methods/mutation.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Import */\r\nvar activation = __webpack_require__(/*! ./activation */ \"./node_modules/neataptic/src/methods/activation.js\");\r\n\r\n/*******************************************************************************\r\n                                      MUTATION\r\n*******************************************************************************/\r\n\r\n// https://en.wikipedia.org/wiki/mutation_(genetic_algorithm)\r\nvar mutation = {\r\n  ADD_NODE: {\r\n    name: 'ADD_NODE'\r\n  },\r\n  SUB_NODE: {\r\n    name: 'SUB_NODE',\r\n    keep_gates: true\r\n  },\r\n  ADD_CONN: {\r\n    name: 'ADD_CONN'\r\n  },\r\n  SUB_CONN: {\r\n    name: 'REMOVE_CONN'\r\n  },\r\n  MOD_WEIGHT: {\r\n    name: 'MOD_WEIGHT',\r\n    min: -1,\r\n    max: 1\r\n  },\r\n  MOD_BIAS: {\r\n    name: 'MOD_BIAS',\r\n    min: -1,\r\n    max: 1\r\n  },\r\n  MOD_ACTIVATION: {\r\n    name: 'MOD_ACTIVATION',\r\n    mutateOutput: true,\r\n    allowed: [\r\n      activation.LOGISTIC,\r\n      activation.TANH,\r\n      activation.RELU,\r\n      activation.IDENTITY,\r\n      activation.STEP,\r\n      activation.SOFTSIGN,\r\n      activation.SINUSOID,\r\n      activation.GAUSSIAN,\r\n      activation.BENT_IDENTITY,\r\n      activation.BIPOLAR,\r\n      activation.BIPOLAR_SIGMOID,\r\n      activation.HARD_TANH,\r\n      activation.ABSOLUTE,\r\n      activation.INVERSE,\r\n      activation.SELU\r\n    ]\r\n  },\r\n  ADD_SELF_CONN: {\r\n    name: 'ADD_SELF_CONN'\r\n  },\r\n  SUB_SELF_CONN: {\r\n    name: 'SUB_SELF_CONN'\r\n  },\r\n  ADD_GATE: {\r\n    name: 'ADD_GATE'\r\n  },\r\n  SUB_GATE: {\r\n    name: 'SUB_GATE'\r\n  },\r\n  ADD_BACK_CONN: {\r\n    name: 'ADD_BACK_CONN'\r\n  },\r\n  SUB_BACK_CONN: {\r\n    name: 'SUB_BACK_CONN'\r\n  },\r\n  SWAP_NODES: {\r\n    name: 'SWAP_NODES',\r\n    mutateOutput: true\r\n  }\r\n};\r\n\r\nmutation.ALL = [\r\n  mutation.ADD_NODE,\r\n  mutation.SUB_NODE,\r\n  mutation.ADD_CONN,\r\n  mutation.SUB_CONN,\r\n  mutation.MOD_WEIGHT,\r\n  mutation.MOD_BIAS,\r\n  mutation.MOD_ACTIVATION,\r\n  mutation.ADD_GATE,\r\n  mutation.SUB_GATE,\r\n  mutation.ADD_SELF_CONN,\r\n  mutation.SUB_SELF_CONN,\r\n  mutation.ADD_BACK_CONN,\r\n  mutation.SUB_BACK_CONN,\r\n  mutation.SWAP_NODES\r\n];\r\n\r\nmutation.FFW = [\r\n  mutation.ADD_NODE,\r\n  mutation.SUB_NODE,\r\n  mutation.ADD_CONN,\r\n  mutation.SUB_CONN,\r\n  mutation.MOD_WEIGHT,\r\n  mutation.MOD_BIAS,\r\n  mutation.MOD_ACTIVATION,\r\n  mutation.SWAP_NODES\r\n];\r\n\r\n/* Export */\r\nmodule.exports = mutation;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/mutation.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/rate.js":
/*!****************************************************!*\
  !*** ./node_modules/neataptic/src/methods/rate.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                      RATE\r\n*******************************************************************************/\r\n\r\n// https://stackoverflow.com/questions/30033096/what-is-lr-policy-in-caffe/30045244\r\nvar rate = {\r\n  FIXED: function () {\r\n    var func = function (baseRate, iteration) { return baseRate; };\r\n    return func;\r\n  },\r\n  STEP: function (gamma, stepSize) {\r\n    gamma = gamma || 0.9;\r\n    stepSize = stepSize || 100;\r\n\r\n    var func = function (baseRate, iteration) {\r\n      return baseRate * Math.pow(gamma, Math.floor(iteration / stepSize));\r\n    };\r\n\r\n    return func;\r\n  },\r\n  EXP: function (gamma) {\r\n    gamma = gamma || 0.999;\r\n\r\n    var func = function (baseRate, iteration) {\r\n      return baseRate * Math.pow(gamma, iteration);\r\n    };\r\n\r\n    return func;\r\n  },\r\n  INV: function (gamma, power) {\r\n    gamma = gamma || 0.001;\r\n    power = power || 2;\r\n\r\n    var func = function (baseRate, iteration) {\r\n      return baseRate * Math.pow(1 + gamma * iteration, -power);\r\n    };\r\n\r\n    return func;\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = rate;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/rate.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/methods/selection.js":
/*!*********************************************************!*\
  !*** ./node_modules/neataptic/src/methods/selection.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                      SELECTION\r\n*******************************************************************************/\r\n\r\n// https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)\r\n\r\nvar selection = {\r\n  FITNESS_PROPORTIONATE: {\r\n    name: 'FITNESS_PROPORTIONATE'\r\n  },\r\n  POWER: {\r\n    name: 'POWER',\r\n    power: 4\r\n  },\r\n  TOURNAMENT: {\r\n    name: 'TOURNAMENT',\r\n    size: 5,\r\n    probability: 0.5\r\n  }\r\n};\r\n\r\n/* Export */\r\nmodule.exports = selection;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/methods/selection.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/multithreading/multi.js":
/*!************************************************************!*\
  !*** ./node_modules/neataptic/src/multithreading/multi.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*******************************************************************************\r\n                                MULTITHREADING\r\n*******************************************************************************/\r\n\r\nvar multi = {\r\n  /** Workers */\r\n  workers: __webpack_require__(/*! ./workers/workers */ \"./node_modules/neataptic/src/multithreading/workers/workers.js\"),\r\n\r\n  /** Serializes a dataset */\r\n  serializeDataSet: function (dataSet) {\r\n    var serialized = [dataSet[0].input.length, dataSet[0].output.length];\r\n\r\n    for (var i = 0; i < dataSet.length; i++) {\r\n      var j;\r\n      for (j = 0; j < serialized[0]; j++) {\r\n        serialized.push(dataSet[i].input[j]);\r\n      }\r\n      for (j = 0; j < serialized[1]; j++) {\r\n        serialized.push(dataSet[i].output[j]);\r\n      }\r\n    }\r\n\r\n    return serialized;\r\n  },\r\n\r\n  /** Activate a serialized network */\r\n  activateSerializedNetwork: function (input, A, S, data, F) {\r\n    for (var i = 0; i < data[0]; i++) A[i] = input[i];\r\n    for (i = 2; i < data.length; i++) {\r\n      let index = data[i++];\r\n      let bias = data[i++];\r\n      let squash = data[i++];\r\n      let selfweight = data[i++];\r\n      let selfgater = data[i++];\r\n\r\n      S[index] = (selfgater === -1 ? 1 : A[selfgater]) * selfweight * S[index] + bias;\r\n\r\n      while (data[i] !== -2) {\r\n        S[index] += A[data[i++]] * data[i++] * (data[i++] === -1 ? 1 : A[data[i - 1]]);\r\n      }\r\n      A[index] = F[squash](S[index]);\r\n    }\r\n\r\n    var output = [];\r\n    for (i = A.length - data[1]; i < A.length; i++) output.push(A[i]);\r\n    return output;\r\n  },\r\n\r\n  /** Deserializes a dataset to an array of arrays */\r\n  deserializeDataSet: function (serializedSet) {\r\n    var set = [];\r\n\r\n    var sampleSize = serializedSet[0] + serializedSet[1];\r\n    for (var i = 0; i < (serializedSet.length - 2) / sampleSize; i++) {\r\n      let input = [];\r\n      for (var j = 2 + i * sampleSize; j < 2 + i * sampleSize + serializedSet[0]; j++) {\r\n        input.push(serializedSet[j]);\r\n      }\r\n      let output = [];\r\n      for (j = 2 + i * sampleSize + serializedSet[0]; j < 2 + i * sampleSize + sampleSize; j++) {\r\n        output.push(serializedSet[j]);\r\n      }\r\n      set.push(input);\r\n      set.push(output);\r\n    }\r\n\r\n    return set;\r\n  },\r\n\r\n  /** A list of compiled activation functions in a certain order */\r\n  activations: [\r\n    function (x) { return 1 / (1 + Math.exp(-x)); },\r\n    function (x) { return Math.tanh(x); },\r\n    function (x) { return x; },\r\n    function (x) { return x > 0 ? 1 : 0; },\r\n    function (x) { return x > 0 ? x : 0; },\r\n    function (x) { return x / (1 + Math.abs(x)); },\r\n    function (x) { return Math.sin(x); },\r\n    function (x) { return Math.exp(-Math.pow(x, 2)); },\r\n    function (x) { return (Math.sqrt(Math.pow(x, 2) + 1) - 1) / 2 + x; },\r\n    function (x) { return x > 0 ? 1 : -1; },\r\n    function (x) { return 2 / (1 + Math.exp(-x)) - 1; },\r\n    function (x) { return Math.max(-1, Math.min(1, x)); },\r\n    function (x) { return Math.abs(x); },\r\n    function (x) { return 1 - x; },\r\n    function (x) {\r\n      var a = 1.6732632423543772848170429916717;\r\n      return (x > 0 ? x : a * Math.exp(x) - a) * 1.0507009873554804934193349852946;\r\n    }\r\n  ]\r\n};\r\n\r\nmulti.testSerializedSet = function (set, cost, A, S, data, F) {\r\n  // Calculate how much samples are in the set\r\n  var error = 0;\r\n  for (var i = 0; i < set.length; i += 2) {\r\n    let output = multi.activateSerializedNetwork(set[i], A, S, data, F);\r\n    error += cost(set[i + 1], output);\r\n  }\r\n\r\n  return error / (set.length / 2);\r\n};\r\n\r\n/* Export */\r\nfor (var i in multi) {\r\n  module.exports[i] = multi[i];\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/multithreading/multi.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/multithreading/workers/browser/testworker.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/neataptic/src/multithreading/workers/browser/testworker.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\r\nmodule.exports = TestWorker;\r\n\r\n/* Import */\r\nvar multi = __webpack_require__(/*! ../../multi */ \"./node_modules/neataptic/src/multithreading/multi.js\");\r\n\r\n/*******************************************************************************\r\n                                WEBWORKER\r\n*******************************************************************************/\r\n\r\nfunction TestWorker (dataSet, cost) {\r\n  var blob = new Blob([this._createBlobString(cost)]);\r\n  this.url = window.URL.createObjectURL(blob);\r\n  this.worker = new Worker(this.url);\r\n\r\n  var data = { set: new Float64Array(dataSet).buffer };\r\n  this.worker.postMessage(data, [data.set]);\r\n}\r\n\r\nTestWorker.prototype = {\r\n  evaluate: function (network) {\r\n    return new Promise((resolve, reject) => {\r\n      var serialized = network.serialize();\r\n\r\n      var data = {\r\n        activations: new Float64Array(serialized[0]).buffer,\r\n        states: new Float64Array(serialized[1]).buffer,\r\n        conns: new Float64Array(serialized[2]).buffer\r\n      };\r\n\r\n      this.worker.onmessage = function (e) {\r\n        var error = new Float64Array(e.data.buffer)[0];\r\n        resolve(error);\r\n      };\r\n\r\n      this.worker.postMessage(data, [data.activations, data.states, data.conns]);\r\n    });\r\n  },\r\n\r\n  terminate: function () {\r\n    this.worker.terminate();\r\n    window.URL.revokeObjectURL(this.url);\r\n  },\r\n\r\n  _createBlobString: function (cost) {\r\n    var source = `\r\n      var F = [${multi.activations.toString()}];\r\n      var cost = ${cost.toString()};\r\n      var multi = {\r\n        deserializeDataSet: ${multi.deserializeDataSet.toString()},\r\n        testSerializedSet: ${multi.testSerializedSet.toString()},\r\n        activateSerializedNetwork: ${multi.activateSerializedNetwork.toString()}\r\n      };\r\n\r\n      this.onmessage = function (e) {\r\n        if(typeof e.data.set === 'undefined'){\r\n          var A = new Float64Array(e.data.activations);\r\n          var S = new Float64Array(e.data.states);\r\n          var data = new Float64Array(e.data.conns);\r\n\r\n          var error = multi.testSerializedSet(set, cost, A, S, data, F);\r\n\r\n          var answer = { buffer: new Float64Array([error ]).buffer };\r\n          postMessage(answer, [answer.buffer]);\r\n        } else {\r\n          set = multi.deserializeDataSet(new Float64Array(e.data.set));\r\n        }\r\n      };`;\r\n\r\n    return source;\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/multithreading/workers/browser/testworker.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/multithreading/workers/node/testworker.js":
/*!******************************************************************************!*\
  !*** ./node_modules/neataptic/src/multithreading/workers/node/testworker.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__dirname) {/* Export */\r\nmodule.exports = TestWorker;\r\n\r\n/* Import */\r\nvar cp = __webpack_require__(/*! child_process */ 0);\r\nvar path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\r\n\r\n/*******************************************************************************\r\n                                WEBWORKER\r\n*******************************************************************************/\r\n\r\nfunction TestWorker (dataSet, cost) {\r\n  this.worker = cp.fork(path.join(__dirname, '/worker'));\r\n\r\n  this.worker.send({ set: dataSet, cost: cost.name });\r\n}\r\n\r\nTestWorker.prototype = {\r\n  evaluate: function (network) {\r\n    return new Promise((resolve, reject) => {\r\n      var serialized = network.serialize();\r\n\r\n      var data = {\r\n        activations: serialized[0],\r\n        states: serialized[1],\r\n        conns: serialized[2]\r\n      };\r\n\r\n      var _that = this.worker;\r\n      this.worker.on('message', function callback (e) {\r\n        _that.removeListener('message', callback);\r\n        resolve(e);\r\n      });\r\n\r\n      this.worker.send(data);\r\n    });\r\n  },\r\n\r\n  terminate: function () {\r\n    this.worker.kill();\r\n  }\r\n};\r\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/multithreading/workers/node/testworker.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/multithreading/workers/workers.js":
/*!**********************************************************************!*\
  !*** ./node_modules/neataptic/src/multithreading/workers/workers.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*******************************************************************************\r\n                                  WORKERS\r\n*******************************************************************************/\r\n\r\nvar workers = {\r\n  node: {\r\n    TestWorker: __webpack_require__(/*! ./node/testworker */ \"./node_modules/neataptic/src/multithreading/workers/node/testworker.js\")\r\n  },\r\n  browser: {\r\n    TestWorker: __webpack_require__(/*! ./browser/testworker */ \"./node_modules/neataptic/src/multithreading/workers/browser/testworker.js\")\r\n  }\r\n};\r\n\r\n/** Export */\r\nmodule.exports = workers;\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/multithreading/workers/workers.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/neat.js":
/*!********************************************!*\
  !*** ./node_modules/neataptic/src/neat.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\r\nmodule.exports = Neat;\r\n\r\n/* Import */\r\nvar Network = __webpack_require__(/*! ./architecture/network */ \"./node_modules/neataptic/src/architecture/network.js\");\r\nvar methods = __webpack_require__(/*! ./methods/methods */ \"./node_modules/neataptic/src/methods/methods.js\");\r\nvar config = __webpack_require__(/*! ./config */ \"./node_modules/neataptic/src/config.js\");\r\n\r\n/* Easier variable naming */\r\nvar selection = methods.selection;\r\n\r\n/*******************************************************************************\r\n                                         NEAT\r\n*******************************************************************************/\r\n\r\nfunction Neat (input, output, fitness, options) {\r\n  this.input = input; // The input size of the networks\r\n  this.output = output; // The output size of the networks\r\n  this.fitness = fitness; // The fitness function to evaluate the networks\r\n\r\n  // Configure options\r\n  options = options || {};\r\n  this.equal = options.equal || false;\r\n  this.clear = options.clear || false;\r\n  this.popsize = options.popsize || 50;\r\n  this.elitism = options.elitism || 0;\r\n  this.provenance = options.provenance || 0;\r\n  this.mutationRate = options.mutationRate || 0.3;\r\n  this.mutationAmount = options.mutationAmount || 1;\r\n\r\n  this.fitnessPopulation = options.fitnessPopulation || false;\r\n\r\n  this.selection = options.selection || methods.selection.POWER;\r\n  this.crossover = options.crossover || [\r\n    methods.crossover.SINGLE_POINT,\r\n    methods.crossover.TWO_POINT,\r\n    methods.crossover.UNIFORM,\r\n    methods.crossover.AVERAGE\r\n  ];\r\n  this.mutation = options.mutation || methods.mutation.FFW;\r\n\r\n  this.template = options.network || false;\r\n\r\n  this.maxNodes = options.maxNodes || Infinity;\r\n  this.maxConns = options.maxConns || Infinity;\r\n  this.maxGates = options.maxGates || Infinity;\r\n\r\n  // Custom mutation selection function if given\r\n  this.selectMutationMethod = typeof options.mutationSelection === 'function' ? options.mutationSelection.bind(this) : this.selectMutationMethod;\r\n\r\n  // Generation counter\r\n  this.generation = 0;\r\n\r\n  // Initialise the genomes\r\n  this.createPool(this.template);\r\n}\r\n\r\nNeat.prototype = {\r\n  /**\r\n   * Create the initial pool of genomes\r\n   */\r\n  createPool: function (network) {\r\n    this.population = [];\r\n\r\n    for (var i = 0; i < this.popsize; i++) {\r\n      var copy;\r\n      if (this.template) {\r\n        copy = Network.fromJSON(network.toJSON());\r\n      } else {\r\n        copy = new Network(this.input, this.output);\r\n      }\r\n      copy.score = undefined;\r\n      this.population.push(copy);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Evaluates, selects, breeds and mutates population\r\n   */\r\n  evolve: async function () {\r\n    // Check if evaluated, sort the population\r\n    if (typeof this.population[this.population.length - 1].score === 'undefined') {\r\n      await this.evaluate();\r\n    }\r\n    this.sort();\r\n\r\n    var fittest = Network.fromJSON(this.population[0].toJSON());\r\n    fittest.score = this.population[0].score;\r\n\r\n    var newPopulation = [];\r\n\r\n    // Elitism\r\n    var elitists = [];\r\n    for (var i = 0; i < this.elitism; i++) {\r\n      elitists.push(this.population[i]);\r\n    }\r\n\r\n    // Provenance\r\n    for (i = 0; i < this.provenance; i++) {\r\n      newPopulation.push(Network.fromJSON(this.template.toJSON()));\r\n    }\r\n\r\n    // Breed the next individuals\r\n    for (i = 0; i < this.popsize - this.elitism - this.provenance; i++) {\r\n      newPopulation.push(this.getOffspring());\r\n    }\r\n\r\n    // Replace the old population with the new population\r\n    this.population = newPopulation;\r\n    this.mutate();\r\n\r\n    this.population.push(...elitists);\r\n\r\n    // Reset the scores\r\n    for (i = 0; i < this.population.length; i++) {\r\n      this.population[i].score = undefined;\r\n    }\r\n\r\n    this.generation++;\r\n\r\n    return fittest;\r\n  },\r\n\r\n  /**\r\n   * Breeds two parents into an offspring, population MUST be surted\r\n   */\r\n  getOffspring: function () {\r\n    var parent1 = this.getParent();\r\n    var parent2 = this.getParent();\r\n\r\n    return Network.crossOver(parent1, parent2, this.equal);\r\n  },\r\n\r\n  /**\r\n   * Selects a random mutation method for a genome according to the parameters\r\n   */\r\n  selectMutationMethod: function (genome) {\r\n    var mutationMethod = this.mutation[Math.floor(Math.random() * this.mutation.length)];\r\n\r\n    if (mutationMethod === methods.mutation.ADD_NODE && genome.nodes.length >= this.maxNodes) {\r\n      if (config.warnings) console.warn('maxNodes exceeded!');\r\n      return;\r\n    }\r\n\r\n    if (mutationMethod === methods.mutation.ADD_CONN && genome.connections.length >= this.maxConns) {\r\n      if (config.warnings) console.warn('maxConns exceeded!');\r\n      return;\r\n    }\r\n\r\n    if (mutationMethod === methods.mutation.ADD_GATE && genome.gates.length >= this.maxGates) {\r\n      if (config.warnings) console.warn('maxGates exceeded!');\r\n      return;\r\n    }\r\n\r\n    return mutationMethod;\r\n  },\r\n\r\n  /**\r\n   * Mutates the given (or current) population\r\n   */\r\n  mutate: function () {\r\n    // Elitist genomes should not be included\r\n    for (var i = 0; i < this.population.length; i++) {\r\n      if (Math.random() <= this.mutationRate) {\r\n        for (var j = 0; j < this.mutationAmount; j++) {\r\n          var mutationMethod = this.selectMutationMethod(this.population[i]);\r\n          this.population[i].mutate(mutationMethod);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Evaluates the current population\r\n   */\r\n  evaluate: async function () {\r\n    var i;\r\n    if (this.fitnessPopulation) {\r\n      if (this.clear) {\r\n        for (i = 0; i < this.population.length; i++) {\r\n          this.population[i].clear();\r\n        }\r\n      }\r\n      await this.fitness(this.population);\r\n    } else {\r\n      for (i = 0; i < this.population.length; i++) {\r\n        var genome = this.population[i];\r\n        if (this.clear) genome.clear();\r\n        genome.score = await this.fitness(genome);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sorts the population by score\r\n   */\r\n  sort: function () {\r\n    this.population.sort(function (a, b) {\r\n      return b.score - a.score;\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Returns the fittest genome of the current population\r\n   */\r\n  getFittest: function () {\r\n    // Check if evaluated\r\n    if (typeof this.population[this.population.length - 1].score === 'undefined') {\r\n      this.evaluate();\r\n    }\r\n    if (this.population[0].score < this.population[1].score) {\r\n      this.sort();\r\n    }\r\n\r\n    return this.population[0];\r\n  },\r\n\r\n  /**\r\n   * Returns the average fitness of the current population\r\n   */\r\n  getAverage: function () {\r\n    if (typeof this.population[this.population.length - 1].score === 'undefined') {\r\n      this.evaluate();\r\n    }\r\n\r\n    var score = 0;\r\n    for (var i = 0; i < this.population.length; i++) {\r\n      score += this.population[i].score;\r\n    }\r\n\r\n    return score / this.population.length;\r\n  },\r\n\r\n  /**\r\n   * Gets a genome based on the selection function\r\n   * @return {Network} genome\r\n   */\r\n  getParent: function () {\r\n    var i;\r\n    switch (this.selection) {\r\n      case selection.POWER:\r\n        if (this.population[0].score < this.population[1].score) this.sort();\r\n\r\n        var index = Math.floor(Math.pow(Math.random(), this.selection.power) * this.population.length);\r\n        return this.population[index];\r\n      case selection.FITNESS_PROPORTIONATE:\r\n        // As negative fitnesses are possible\r\n        // https://stackoverflow.com/questions/16186686/genetic-algorithm-handling-negative-fitness-values\r\n        // this is unnecessarily run for every individual, should be changed\r\n\r\n        var totalFitness = 0;\r\n        var minimalFitness = 0;\r\n        for (i = 0; i < this.population.length; i++) {\r\n          var score = this.population[i].score;\r\n          minimalFitness = score < minimalFitness ? score : minimalFitness;\r\n          totalFitness += score;\r\n        }\r\n\r\n        minimalFitness = Math.abs(minimalFitness);\r\n        totalFitness += minimalFitness * this.population.length;\r\n\r\n        var random = Math.random() * totalFitness;\r\n        var value = 0;\r\n\r\n        for (i = 0; i < this.population.length; i++) {\r\n          let genome = this.population[i];\r\n          value += genome.score + minimalFitness;\r\n          if (random < value) return genome;\r\n        }\r\n\r\n        // if all scores equal, return random genome\r\n        return this.population[Math.floor(Math.random() * this.population.length)];\r\n      case selection.TOURNAMENT:\r\n        if (this.selection.size > this.popsize) {\r\n          throw new Error('Your tournament size should be lower than the population size, please change methods.selection.TOURNAMENT.size');\r\n        }\r\n\r\n        // Create a tournament\r\n        var individuals = [];\r\n        for (i = 0; i < this.selection.size; i++) {\r\n          let random = this.population[Math.floor(Math.random() * this.population.length)];\r\n          individuals.push(random);\r\n        }\r\n\r\n        // Sort the tournament individuals by score\r\n        individuals.sort(function (a, b) {\r\n          return b.score - a.score;\r\n        });\r\n\r\n        // Select an individual\r\n        for (i = 0; i < this.selection.size; i++) {\r\n          if (Math.random() < this.selection.probability || i === this.selection.size - 1) {\r\n            return individuals[i];\r\n          }\r\n        }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Export the current population to a json object\r\n   */\r\n  export: function () {\r\n    var json = [];\r\n    for (var i = 0; i < this.population.length; i++) {\r\n      var genome = this.population[i];\r\n      json.push(genome.toJSON());\r\n    }\r\n\r\n    return json;\r\n  },\r\n\r\n  /**\r\n   * Import population from a json object\r\n   */\r\n  import: function (json) {\r\n    var population = [];\r\n    for (var i = 0; i < json.length; i++) {\r\n      var genome = json[i];\r\n      population.push(Network.fromJSON(genome));\r\n    }\r\n    this.population = population;\r\n    this.popsize = population.length;\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/neat.js?");

/***/ }),

/***/ "./node_modules/neataptic/src/neataptic.js":
/*!*************************************************!*\
  !*** ./node_modules/neataptic/src/neataptic.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var Neataptic = {\r\n  methods: __webpack_require__(/*! ./methods/methods */ \"./node_modules/neataptic/src/methods/methods.js\"),\r\n  Connection: __webpack_require__(/*! ./architecture/connection */ \"./node_modules/neataptic/src/architecture/connection.js\"),\r\n  architect: __webpack_require__(/*! ./architecture/architect */ \"./node_modules/neataptic/src/architecture/architect.js\"),\r\n  Network: __webpack_require__(/*! ./architecture/network */ \"./node_modules/neataptic/src/architecture/network.js\"),\r\n  config: __webpack_require__(/*! ./config */ \"./node_modules/neataptic/src/config.js\"),\r\n  Group: __webpack_require__(/*! ./architecture/group */ \"./node_modules/neataptic/src/architecture/group.js\"),\r\n  Layer: __webpack_require__(/*! ./architecture/layer */ \"./node_modules/neataptic/src/architecture/layer.js\"),\r\n  Node: __webpack_require__(/*! ./architecture/node */ \"./node_modules/neataptic/src/architecture/node.js\"),\r\n  Neat: __webpack_require__(/*! ./neat */ \"./node_modules/neataptic/src/neat.js\"),\r\n  multi: __webpack_require__(/*! ./multithreading/multi */ \"./node_modules/neataptic/src/multithreading/multi.js\")\r\n};\r\n\r\n// CommonJS & AMD\r\nif (true) {\r\n  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () { return Neataptic; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n}\r\n\r\n// Node.js\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = Neataptic;\r\n}\r\n\r\n// Browser\r\nif (typeof window === 'object') {\r\n  (function () {\r\n    var old = window['neataptic'];\r\n    Neataptic.ninja = function () {\r\n      window['neataptic'] = old;\r\n      return Neataptic;\r\n    };\r\n  })();\r\n\r\n  window['neataptic'] = Neataptic;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/neataptic/src/neataptic.js?");

/***/ }),

/***/ "./node_modules/os-browserify/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/os-browserify/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\nexports.homedir = function () {\n\treturn '/'\n};\n\n\n//# sourceURL=webpack:///./node_modules/os-browserify/browser.js?");

/***/ }),

/***/ "./node_modules/particle-filter/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/particle-filter/lib/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = particleFilter;\r\n\r\nfunction nextDouble(maxValue, minValue) {\r\n    var max = maxValue || 1,\r\n        min = minValue || 0,\r\n        randomValue = Math.random();\r\n    if (!min) {\r\n        return randomValue * max;\r\n    }\r\n    return (0.5 - randomValue) * (max - min);\r\n}\r\n\r\nfunction uniformDistribution(maxValue) {\r\n    this.maxValue = maxValue;\r\n}\r\n\r\nuniformDistribution.prototype.generate = function () {\r\n    return nextDouble(this.maxValue);\r\n}\r\n\r\nfunction featureParticle(state, weight, variance) {\r\n    var defaultVariance = 50;\r\n\r\n    this.variance = variance || defaultVariance;\r\n    this.weight = weight || 0;\r\n    this.state = state.slice();\r\n};\r\n\r\nfeatureParticle.prototype.diffuse = function () {\r\n    var state = this.state,\r\n        variance = this.variance;\r\n\r\n    for (var i = 0, l = state.length; i < l; i++) {\r\n        state[i] += nextDouble(variance, -variance);\r\n    }\r\n};\r\n\r\nfeatureParticle.prototype.clone = function () {\r\n    return new featureParticle(this.state.slice(), this.weight);\r\n};\r\n\r\nfunction particleFilter(particlesNumber, variablesNumber, distributionSize) {\r\n\r\n    var particlesNumber = particlesNumber || 100,\r\n        variablesNumber = variablesNumber || 1,\r\n        distributionSize = distributionSize || 10;\r\n\r\n    this.particles = [];\r\n    this.epsilon = Number.MIN_VALUE;\r\n    this.variance = 0;\r\n    this.distributions = [];\r\n\r\n    for (var i = 0; i < variablesNumber; i++) {\r\n        this.distributions.push(new uniformDistribution(distributionSize));\r\n    }\r\n\r\n    this.generateParticles(particlesNumber, this.distributions);\r\n};\r\n\r\nparticleFilter.prototype.generateParticles = function (numberOfParticles, distributions) {\r\n    var nDim = distributions.length,\r\n        particles = this.particles;\r\n    for (var i = 0; i < numberOfParticles; i++) {\r\n        var randomParam = [];\r\n        for (var dim = 0; dim < nDim; dim++) {\r\n            randomParam[dim] = distributions[dim].generate();\r\n        }\r\n        particles.push(new featureParticle(randomParam, 1 / numberOfParticles));\r\n    }\r\n};\r\n\r\nparticleFilter.prototype.resample = function (sampleCount) {\r\n    var resampledParticles = [],\r\n        filteredParticles = this.filter(this.particles.length);\r\n\r\n    for (var i = 0, l = filteredParticles.length; i < l; i++) {\r\n        var newPart = filteredParticles[i].clone();\r\n        newPart.weight = 1 / this.particles.length;\r\n        resampledParticles.push(newPart);\r\n    }\r\n\r\n    return resampledParticles;\r\n};\r\n\r\nparticleFilter.prototype.filter = function (sampleCount) {\r\n    var cumulativeWeights = [],\r\n        cumSumInd = 0,\r\n        cumSum = 0,\r\n        particles = this.particles;\r\n\r\n    for (var i = 0, l = particles.length; i < l; i++) {\r\n        var p = particles[i];\r\n        cumSum += p.weight;\r\n        cumulativeWeights[cumSumInd++] = cumSum;\r\n    }\r\n\r\n    var maxCumWeight = cumulativeWeights[particles.length - 1],\r\n        minCumWeight = cumulativeWeights[0];\r\n\r\n    var filteredParticles = [];\r\n\r\n    for (var i = 0; i < sampleCount; i++) {\r\n        var randWeight = minCumWeight + nextDouble(1) * (maxCumWeight - minCumWeight),\r\n            particleInd = 0;\r\n        while (cumulativeWeights[particleInd] < randWeight) {\r\n            particleInd++;\r\n        }\r\n\r\n        var p = particles[particleInd];\r\n        filteredParticles.push(p);\r\n    }\r\n\r\n    return filteredParticles;\r\n};\r\n\r\nparticleFilter.prototype.predict = function (effectiveMinRatio) {\r\n    var newParticles,\r\n        particles = this.particles,\r\n        effectiveRatio = this.effectiveLength(this.normalWeights()) / this.particles.length;\r\n    if (effectiveRatio > this.epsilon &&\r\n        effectiveRatio < effectiveMinRatio) {\r\n        newParticles = this.resample(particles.length);\r\n    }\r\n    else {\r\n        newParticles = [];\r\n        for (var i = 0, l = particles.length; i < l; i++) {\r\n            var cloned = particles[i].clone();\r\n            cloned.diffuse();\r\n            newParticles.push(cloned);\r\n        }\r\n    }\r\n\r\n    this.particles = newParticles;\r\n};\r\n\r\nparticleFilter.prototype.effectiveLength = function (weights) {\r\n    var sumSqr = this.epsilon,\r\n        sum = 0;\r\n    for (var i = 0, l = weights.length; i < l; i++) {\r\n        var w = weights[i];\r\n        sumSqr += w * w;\r\n        sum += w;\r\n    }\r\n\r\n    return sum / sumSqr;\r\n};\r\n\r\nparticleFilter.prototype.normalWeights = function () {\r\n    var particles = this.particles,\r\n        normalizedWeights = [],\r\n        weightSum = this.epsilon;\r\n    for (var i = 0, l = particles.length; i < l; i++) {\r\n        weightSum += particles[i].weight;\r\n    }\r\n\r\n    for (var i = 0, l = particles.length; i < l; i++) {\r\n        normalizedWeights.push(particles[i].weight / weightSum);\r\n    }\r\n\r\n    return normalizedWeights;\r\n};\r\n\r\nparticleFilter.prototype.update = function (measure, effectiveMinRatio) {\r\n\r\n    this.predict(effectiveMinRatio || 0.9);\r\n\r\n    var particles = this.particles,\r\n        maxWeightParticle;\r\n\r\n    for (var i = 0, l = particles.length; i < l; i++) {\r\n        var particle = particles[i],\r\n            state = particle.state,\r\n            sumSqr = 0;\r\n\r\n        for (var j = 0, sl = state.length; j < sl; j++) {\r\n            var diff = measure[j] - state[j];\r\n            sumSqr += diff * diff;\r\n        }\r\n\r\n        var weight = 1 / Math.sqrt(sumSqr);\r\n        particle.weight = weight;\r\n\r\n        if (!maxWeightParticle || maxWeightParticle.weight < weight) {\r\n            maxWeightParticle = particle;\r\n        }\r\n    }\r\n\r\n    this.result = maxWeightParticle;\r\n    return maxWeightParticle;\r\n};\r\n\r\n\n\n//# sourceURL=webpack:///./node_modules/particle-filter/lib/index.js?");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./predictor/predictAction.js":
/*!************************************!*\
  !*** ./predictor/predictAction.js ***!
  \************************************/
/*! exports provided: predictAction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"predictAction\", function() { return predictAction; });\n/* harmony import */ var neataptic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neataptic */ \"./node_modules/neataptic/src/neataptic.js\");\n/* harmony import */ var neataptic__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(neataptic__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nconst network = neataptic__WEBPACK_IMPORTED_MODULE_0__[\"Network\"].fromJSON({\"nodes\":[{\"bias\":-0.09051809614277864,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":0},{\"bias\":-0.010742331696831989,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":1},{\"bias\":0.008055230891690093,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":2},{\"bias\":-0.0894936490637214,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":3},{\"bias\":-0.03208246314605327,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":4},{\"bias\":0.09100747986024058,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":5},{\"bias\":0.01990033917435667,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":6},{\"bias\":0.09821440052079197,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":7},{\"bias\":0.037354533002199736,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":8},{\"bias\":-0.06894154032557331,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":9},{\"bias\":-0.06987054115114466,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":10},{\"bias\":-0.055220060463338966,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":11},{\"bias\":0.08310145961438262,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":12},{\"bias\":-0.09626540979497072,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":13},{\"bias\":-0.050019119988337794,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":14},{\"bias\":-0.06662435242764456,\"type\":\"input\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":15},{\"bias\":-0.0007821449940741977,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":16},{\"bias\":3.3344519846994274,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":17},{\"bias\":0.43576102072570383,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":18},{\"bias\":-0.6252247313259114,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":19},{\"bias\":-0.12659495834427542,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":20},{\"bias\":1.4559238125441802,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":21},{\"bias\":0.9683916959172962,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":22},{\"bias\":2.7877032810179116,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":23},{\"bias\":3.219170915696325,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":24},{\"bias\":0.8176657998104446,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":25},{\"bias\":3.392225005636871,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":26},{\"bias\":3.3503946213606763,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":27},{\"bias\":3.325456294672491,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":28},{\"bias\":3.8698374378350913,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":29},{\"bias\":2.6420081828888073,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":30},{\"bias\":7.66995064664369,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":31},{\"bias\":-3.111118190952033,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":32},{\"bias\":-0.7100565868363629,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":33},{\"bias\":-2.856900920869165,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":34},{\"bias\":-2.915946654314752,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":35},{\"bias\":-5.003504430067407,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":36},{\"bias\":-2.9906010905962908,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":37},{\"bias\":3.1196862508059664,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":38},{\"bias\":-0.5880816906842256,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":39},{\"bias\":0.6373028573923575,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":40},{\"bias\":1.0316288404501932,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":41},{\"bias\":0.15399561778425083,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":42},{\"bias\":0.353279826074774,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":43},{\"bias\":1.2844690920149957,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":44},{\"bias\":1.421087368848455,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":45},{\"bias\":0.6382207620914205,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":46},{\"bias\":0.35775957838788364,\"type\":\"hidden\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":47},{\"bias\":-0.5796909283611376,\"type\":\"output\",\"squash\":\"LOGISTIC\",\"mask\":1,\"index\":48}],\"connections\":[{\"weight\":1,\"from\":32,\"to\":32,\"gater\":24},{\"weight\":1,\"from\":33,\"to\":33,\"gater\":25},{\"weight\":1,\"from\":34,\"to\":34,\"gater\":26},{\"weight\":1,\"from\":35,\"to\":35,\"gater\":27},{\"weight\":1,\"from\":36,\"to\":36,\"gater\":28},{\"weight\":1,\"from\":37,\"to\":37,\"gater\":29},{\"weight\":1,\"from\":38,\"to\":38,\"gater\":30},{\"weight\":1,\"from\":39,\"to\":39,\"gater\":31},{\"weight\":-4.289562888563939,\"from\":0,\"to\":32,\"gater\":16},{\"weight\":-3.471480044487428,\"from\":0,\"to\":33,\"gater\":17},{\"weight\":-4.825558810799225,\"from\":0,\"to\":34,\"gater\":18},{\"weight\":-5.410193693516988,\"from\":0,\"to\":35,\"gater\":19},{\"weight\":0.17315736970903312,\"from\":0,\"to\":36,\"gater\":20},{\"weight\":1.2370805773735862,\"from\":0,\"to\":37,\"gater\":21},{\"weight\":4.150800970974433,\"from\":0,\"to\":38,\"gater\":22},{\"weight\":3.228520786974449,\"from\":0,\"to\":39,\"gater\":23},{\"weight\":0.3124871938119286,\"from\":0,\"to\":16,\"gater\":null},{\"weight\":1.0423559276302594,\"from\":0,\"to\":17,\"gater\":null},{\"weight\":0.32245536563788935,\"from\":0,\"to\":18,\"gater\":null},{\"weight\":-0.060618180525550666,\"from\":0,\"to\":19,\"gater\":null},{\"weight\":0.6640499201262237,\"from\":0,\"to\":20,\"gater\":null},{\"weight\":1.0791575927249388,\"from\":0,\"to\":21,\"gater\":null},{\"weight\":-0.04960109445120877,\"from\":0,\"to\":22,\"gater\":null},{\"weight\":0.1605013112241019,\"from\":0,\"to\":23,\"gater\":null},{\"weight\":0.6280466389468287,\"from\":0,\"to\":40,\"gater\":null},{\"weight\":0.11608759717732156,\"from\":0,\"to\":41,\"gater\":null},{\"weight\":0.756936002037937,\"from\":0,\"to\":42,\"gater\":null},{\"weight\":0.9029321012620857,\"from\":0,\"to\":43,\"gater\":null},{\"weight\":0.8172174405705964,\"from\":0,\"to\":44,\"gater\":null},{\"weight\":-0.2447293322743677,\"from\":0,\"to\":45,\"gater\":null},{\"weight\":1.568781224229161,\"from\":0,\"to\":46,\"gater\":null},{\"weight\":4.645192692256905,\"from\":0,\"to\":47,\"gater\":null},{\"weight\":-0.4477444607589047,\"from\":0,\"to\":24,\"gater\":null},{\"weight\":-0.2172588630067551,\"from\":0,\"to\":25,\"gater\":null},{\"weight\":-0.4604031142363807,\"from\":0,\"to\":26,\"gater\":null},{\"weight\":-0.912190159014062,\"from\":0,\"to\":27,\"gater\":null},{\"weight\":-1.214453107177991,\"from\":0,\"to\":28,\"gater\":null},{\"weight\":-1.1512827758123871,\"from\":0,\"to\":29,\"gater\":null},{\"weight\":-0.754051723419217,\"from\":0,\"to\":30,\"gater\":null},{\"weight\":-2.864059525091461,\"from\":0,\"to\":31,\"gater\":null},{\"weight\":1.0924341991060145,\"from\":0,\"to\":48,\"gater\":null},{\"weight\":-2.4061071634000837,\"from\":1,\"to\":32,\"gater\":16},{\"weight\":-3.406758904273735,\"from\":1,\"to\":33,\"gater\":17},{\"weight\":-2.5388956520420964,\"from\":1,\"to\":34,\"gater\":18},{\"weight\":-3.3306575839842303,\"from\":1,\"to\":35,\"gater\":19},{\"weight\":0.034439668810184364,\"from\":1,\"to\":36,\"gater\":20},{\"weight\":-0.12731901193495523,\"from\":1,\"to\":37,\"gater\":21},{\"weight\":2.781519137870982,\"from\":1,\"to\":38,\"gater\":22},{\"weight\":2.287713064587518,\"from\":1,\"to\":39,\"gater\":23},{\"weight\":0.5184908932493633,\"from\":1,\"to\":16,\"gater\":null},{\"weight\":-0.07250314235421863,\"from\":1,\"to\":17,\"gater\":null},{\"weight\":0.49651843288236025,\"from\":1,\"to\":18,\"gater\":null},{\"weight\":0.6802019780317261,\"from\":1,\"to\":19,\"gater\":null},{\"weight\":-1.0444075893782367,\"from\":1,\"to\":20,\"gater\":null},{\"weight\":0.3347330244224965,\"from\":1,\"to\":21,\"gater\":null},{\"weight\":0.1227554043099131,\"from\":1,\"to\":22,\"gater\":null},{\"weight\":-0.14505820153014415,\"from\":1,\"to\":23,\"gater\":null},{\"weight\":0.17370194810532566,\"from\":1,\"to\":40,\"gater\":null},{\"weight\":0.04916951082340532,\"from\":1,\"to\":41,\"gater\":null},{\"weight\":0.1493911357094776,\"from\":1,\"to\":42,\"gater\":null},{\"weight\":0.4168994321199711,\"from\":1,\"to\":43,\"gater\":null},{\"weight\":0.5720546704140312,\"from\":1,\"to\":44,\"gater\":null},{\"weight\":0.004776149919113771,\"from\":1,\"to\":45,\"gater\":null},{\"weight\":1.7244246388827214,\"from\":1,\"to\":46,\"gater\":null},{\"weight\":1.7918755500003292,\"from\":1,\"to\":47,\"gater\":null},{\"weight\":-0.5880190187122922,\"from\":1,\"to\":24,\"gater\":null},{\"weight\":0.3240793001411135,\"from\":1,\"to\":25,\"gater\":null},{\"weight\":-0.739474769098912,\"from\":1,\"to\":26,\"gater\":null},{\"weight\":-1.100836623747978,\"from\":1,\"to\":27,\"gater\":null},{\"weight\":-1.226271164907494,\"from\":1,\"to\":28,\"gater\":null},{\"weight\":-1.2324824109885768,\"from\":1,\"to\":29,\"gater\":null},{\"weight\":-0.9658102634983923,\"from\":1,\"to\":30,\"gater\":null},{\"weight\":-3.000547504562826,\"from\":1,\"to\":31,\"gater\":null},{\"weight\":-0.4358271913330464,\"from\":1,\"to\":48,\"gater\":null},{\"weight\":-0.27042726408065565,\"from\":2,\"to\":32,\"gater\":16},{\"weight\":-0.2883306958756392,\"from\":2,\"to\":33,\"gater\":17},{\"weight\":-0.2703683113786621,\"from\":2,\"to\":34,\"gater\":18},{\"weight\":-0.2022933900146751,\"from\":2,\"to\":35,\"gater\":19},{\"weight\":1.2320198718349296,\"from\":2,\"to\":36,\"gater\":20},{\"weight\":1.0552913561430408,\"from\":2,\"to\":37,\"gater\":21},{\"weight\":-0.3016175664813484,\"from\":2,\"to\":38,\"gater\":22},{\"weight\":2.6673055311187523,\"from\":2,\"to\":39,\"gater\":23},{\"weight\":0.5519744888874808,\"from\":2,\"to\":16,\"gater\":null},{\"weight\":0.6040926841053557,\"from\":2,\"to\":17,\"gater\":null},{\"weight\":0.6254584580667181,\"from\":2,\"to\":18,\"gater\":null},{\"weight\":0.8291575260471505,\"from\":2,\"to\":19,\"gater\":null},{\"weight\":0.8352446587553838,\"from\":2,\"to\":20,\"gater\":null},{\"weight\":-0.22357027000541338,\"from\":2,\"to\":21,\"gater\":null},{\"weight\":0.2638924785772507,\"from\":2,\"to\":22,\"gater\":null},{\"weight\":-2.6880630739040656,\"from\":2,\"to\":23,\"gater\":null},{\"weight\":0.17721024407267574,\"from\":2,\"to\":40,\"gater\":null},{\"weight\":0.10324781381678715,\"from\":2,\"to\":41,\"gater\":null},{\"weight\":-0.04334236252664942,\"from\":2,\"to\":42,\"gater\":null},{\"weight\":0.07210444541756772,\"from\":2,\"to\":43,\"gater\":null},{\"weight\":0.12443838396724682,\"from\":2,\"to\":44,\"gater\":null},{\"weight\":-0.2521048592632194,\"from\":2,\"to\":45,\"gater\":null},{\"weight\":0.8508332273166356,\"from\":2,\"to\":46,\"gater\":null},{\"weight\":1.4746552147263428,\"from\":2,\"to\":47,\"gater\":null},{\"weight\":-0.5938270950461935,\"from\":2,\"to\":24,\"gater\":null},{\"weight\":0.6790804264314082,\"from\":2,\"to\":25,\"gater\":null},{\"weight\":-1.1023180979102656,\"from\":2,\"to\":26,\"gater\":null},{\"weight\":-1.0563958174276675,\"from\":2,\"to\":27,\"gater\":null},{\"weight\":-1.0947040353148034,\"from\":2,\"to\":28,\"gater\":null},{\"weight\":-1.181745643224465,\"from\":2,\"to\":29,\"gater\":null},{\"weight\":-1.0775716078245932,\"from\":2,\"to\":30,\"gater\":null},{\"weight\":-1.8535935556745504,\"from\":2,\"to\":31,\"gater\":null},{\"weight\":-0.9068606993845351,\"from\":2,\"to\":48,\"gater\":null},{\"weight\":2.57876868678946,\"from\":3,\"to\":32,\"gater\":16},{\"weight\":0.07129471181637172,\"from\":3,\"to\":33,\"gater\":17},{\"weight\":4.10306482237338,\"from\":3,\"to\":34,\"gater\":18},{\"weight\":4.599864638082529,\"from\":3,\"to\":35,\"gater\":19},{\"weight\":1.459797131980343,\"from\":3,\"to\":36,\"gater\":20},{\"weight\":0.4698431554807617,\"from\":3,\"to\":37,\"gater\":21},{\"weight\":-3.613820174964227,\"from\":3,\"to\":38,\"gater\":22},{\"weight\":2.307224145769197,\"from\":3,\"to\":39,\"gater\":23},{\"weight\":0.6985377979405232,\"from\":3,\"to\":16,\"gater\":null},{\"weight\":-0.7173131990272057,\"from\":3,\"to\":17,\"gater\":null},{\"weight\":0.8727983713364734,\"from\":3,\"to\":18,\"gater\":null},{\"weight\":0.8271595555098394,\"from\":3,\"to\":19,\"gater\":null},{\"weight\":0.32322842206215807,\"from\":3,\"to\":20,\"gater\":null},{\"weight\":-1.6313065384750927,\"from\":3,\"to\":21,\"gater\":null},{\"weight\":0.5433229178295689,\"from\":3,\"to\":22,\"gater\":null},{\"weight\":-0.7015065110907649,\"from\":3,\"to\":23,\"gater\":null},{\"weight\":-0.2346059341351355,\"from\":3,\"to\":40,\"gater\":null},{\"weight\":0.018566680868439264,\"from\":3,\"to\":41,\"gater\":null},{\"weight\":-0.28160203235773795,\"from\":3,\"to\":42,\"gater\":null},{\"weight\":-0.3058097680601522,\"from\":3,\"to\":43,\"gater\":null},{\"weight\":-0.05542440840201161,\"from\":3,\"to\":44,\"gater\":null},{\"weight\":-0.27549531083579853,\"from\":3,\"to\":45,\"gater\":null},{\"weight\":0.7641315954124842,\"from\":3,\"to\":46,\"gater\":null},{\"weight\":0.22329506409861838,\"from\":3,\"to\":47,\"gater\":null},{\"weight\":-0.9786181798178308,\"from\":3,\"to\":24,\"gater\":null},{\"weight\":0.30182374983117344,\"from\":3,\"to\":25,\"gater\":null},{\"weight\":-0.9077915638369568,\"from\":3,\"to\":26,\"gater\":null},{\"weight\":-0.9326936305426846,\"from\":3,\"to\":27,\"gater\":null},{\"weight\":-1.0613106297784403,\"from\":3,\"to\":28,\"gater\":null},{\"weight\":-1.2004696006149882,\"from\":3,\"to\":29,\"gater\":null},{\"weight\":-0.9520615245844037,\"from\":3,\"to\":30,\"gater\":null},{\"weight\":-1.7791497873961106,\"from\":3,\"to\":31,\"gater\":null},{\"weight\":-2.5246364283203877,\"from\":3,\"to\":48,\"gater\":null},{\"weight\":-0.6184171607644692,\"from\":4,\"to\":32,\"gater\":16},{\"weight\":-0.6080994418412745,\"from\":4,\"to\":33,\"gater\":17},{\"weight\":-0.8936668824572822,\"from\":4,\"to\":34,\"gater\":18},{\"weight\":-1.2700004801595186,\"from\":4,\"to\":35,\"gater\":19},{\"weight\":0.5165690436965511,\"from\":4,\"to\":36,\"gater\":20},{\"weight\":-0.6522787468035137,\"from\":4,\"to\":37,\"gater\":21},{\"weight\":1.325205463088933,\"from\":4,\"to\":38,\"gater\":22},{\"weight\":1.8667226643406796,\"from\":4,\"to\":39,\"gater\":23},{\"weight\":0.3354021439857949,\"from\":4,\"to\":16,\"gater\":null},{\"weight\":-2.057720685653287,\"from\":4,\"to\":17,\"gater\":null},{\"weight\":0.35869253591814104,\"from\":4,\"to\":18,\"gater\":null},{\"weight\":0.4390073362362864,\"from\":4,\"to\":19,\"gater\":null},{\"weight\":-0.6709875745265483,\"from\":4,\"to\":20,\"gater\":null},{\"weight\":0.883446773197368,\"from\":4,\"to\":21,\"gater\":null},{\"weight\":0.12801898963481423,\"from\":4,\"to\":22,\"gater\":null},{\"weight\":0.3349872185666566,\"from\":4,\"to\":23,\"gater\":null},{\"weight\":-0.468143050783027,\"from\":4,\"to\":40,\"gater\":null},{\"weight\":-0.036701582158229294,\"from\":4,\"to\":41,\"gater\":null},{\"weight\":-0.5183771252074552,\"from\":4,\"to\":42,\"gater\":null},{\"weight\":-0.5823372985857829,\"from\":4,\"to\":43,\"gater\":null},{\"weight\":-0.12105218073764844,\"from\":4,\"to\":44,\"gater\":null},{\"weight\":-0.6424662157256162,\"from\":4,\"to\":45,\"gater\":null},{\"weight\":0.6958984590144365,\"from\":4,\"to\":46,\"gater\":null},{\"weight\":-0.44576295755265816,\"from\":4,\"to\":47,\"gater\":null},{\"weight\":-0.7069292138374649,\"from\":4,\"to\":24,\"gater\":null},{\"weight\":0.22063477401686055,\"from\":4,\"to\":25,\"gater\":null},{\"weight\":-0.698503262632312,\"from\":4,\"to\":26,\"gater\":null},{\"weight\":-0.8116659785195746,\"from\":4,\"to\":27,\"gater\":null},{\"weight\":-1.091568324500641,\"from\":4,\"to\":28,\"gater\":null},{\"weight\":-1.1965355107218307,\"from\":4,\"to\":29,\"gater\":null},{\"weight\":-0.7222013346612769,\"from\":4,\"to\":30,\"gater\":null},{\"weight\":-2.0519853070534833,\"from\":4,\"to\":31,\"gater\":null},{\"weight\":-2.2125607879633646,\"from\":4,\"to\":48,\"gater\":null},{\"weight\":3.3230969306696445,\"from\":5,\"to\":32,\"gater\":16},{\"weight\":2.6953919221674987,\"from\":5,\"to\":33,\"gater\":17},{\"weight\":3.9917381938486782,\"from\":5,\"to\":34,\"gater\":18},{\"weight\":4.0547902262984366,\"from\":5,\"to\":35,\"gater\":19},{\"weight\":2.4030674838010797,\"from\":5,\"to\":36,\"gater\":20},{\"weight\":2.869958554830775,\"from\":5,\"to\":37,\"gater\":21},{\"weight\":-3.557679702340944,\"from\":5,\"to\":38,\"gater\":22},{\"weight\":3.014776057353413,\"from\":5,\"to\":39,\"gater\":23},{\"weight\":0.8744476687241739,\"from\":5,\"to\":16,\"gater\":null},{\"weight\":-0.20270581350384795,\"from\":5,\"to\":17,\"gater\":null},{\"weight\":0.8000445956854783,\"from\":5,\"to\":18,\"gater\":null},{\"weight\":0.9962750699992344,\"from\":5,\"to\":19,\"gater\":null},{\"weight\":0.8763783387549006,\"from\":5,\"to\":20,\"gater\":null},{\"weight\":-0.5389101200234858,\"from\":5,\"to\":21,\"gater\":null},{\"weight\":0.7610808684981775,\"from\":5,\"to\":22,\"gater\":null},{\"weight\":-0.04978147645477702,\"from\":5,\"to\":23,\"gater\":null},{\"weight\":-0.346055969952295,\"from\":5,\"to\":40,\"gater\":null},{\"weight\":0.03454650153215587,\"from\":5,\"to\":41,\"gater\":null},{\"weight\":-0.5731672578944571,\"from\":5,\"to\":42,\"gater\":null},{\"weight\":-0.5673988124226547,\"from\":5,\"to\":43,\"gater\":null},{\"weight\":-0.07994903642889829,\"from\":5,\"to\":44,\"gater\":null},{\"weight\":-0.3329640164364618,\"from\":5,\"to\":45,\"gater\":null},{\"weight\":-0.41856270942744067,\"from\":5,\"to\":46,\"gater\":null},{\"weight\":-0.5721333917521944,\"from\":5,\"to\":47,\"gater\":null},{\"weight\":-0.7399679874221785,\"from\":5,\"to\":24,\"gater\":null},{\"weight\":0.9467932552991408,\"from\":5,\"to\":25,\"gater\":null},{\"weight\":-0.8273617383900056,\"from\":5,\"to\":26,\"gater\":null},{\"weight\":-0.6330895472263983,\"from\":5,\"to\":27,\"gater\":null},{\"weight\":-1.0705183497489785,\"from\":5,\"to\":28,\"gater\":null},{\"weight\":-1.2030013085803157,\"from\":5,\"to\":29,\"gater\":null},{\"weight\":-0.6322733993036085,\"from\":5,\"to\":30,\"gater\":null},{\"weight\":-1.3736452996494213,\"from\":5,\"to\":31,\"gater\":null},{\"weight\":-0.20831708097020027,\"from\":5,\"to\":48,\"gater\":null},{\"weight\":1.535972526816916,\"from\":6,\"to\":32,\"gater\":16},{\"weight\":2.2834450994593385,\"from\":6,\"to\":33,\"gater\":17},{\"weight\":0.694425662780406,\"from\":6,\"to\":34,\"gater\":18},{\"weight\":0.4654448865931303,\"from\":6,\"to\":35,\"gater\":19},{\"weight\":1.7194423846559435,\"from\":6,\"to\":36,\"gater\":20},{\"weight\":0.8622598495949731,\"from\":6,\"to\":37,\"gater\":21},{\"weight\":-1.7127883619553217,\"from\":6,\"to\":38,\"gater\":22},{\"weight\":2.2013036365478884,\"from\":6,\"to\":39,\"gater\":23},{\"weight\":0.4041357305325111,\"from\":6,\"to\":16,\"gater\":null},{\"weight\":-0.8229121832742649,\"from\":6,\"to\":17,\"gater\":null},{\"weight\":0.505745869607977,\"from\":6,\"to\":18,\"gater\":null},{\"weight\":0.7868530870512017,\"from\":6,\"to\":19,\"gater\":null},{\"weight\":-1.3129783746853751,\"from\":6,\"to\":20,\"gater\":null},{\"weight\":1.1237873253525785,\"from\":6,\"to\":21,\"gater\":null},{\"weight\":0.2861878111247386,\"from\":6,\"to\":22,\"gater\":null},{\"weight\":0.4069990472472513,\"from\":6,\"to\":23,\"gater\":null},{\"weight\":-0.3899405469419823,\"from\":6,\"to\":40,\"gater\":null},{\"weight\":0.05719657140921488,\"from\":6,\"to\":41,\"gater\":null},{\"weight\":-0.5579996931876934,\"from\":6,\"to\":42,\"gater\":null},{\"weight\":-0.4036839589486748,\"from\":6,\"to\":43,\"gater\":null},{\"weight\":-0.04224623359023893,\"from\":6,\"to\":44,\"gater\":null},{\"weight\":-0.47977809753367856,\"from\":6,\"to\":45,\"gater\":null},{\"weight\":0.44364213444408956,\"from\":6,\"to\":46,\"gater\":null},{\"weight\":-0.875040326436807,\"from\":6,\"to\":47,\"gater\":null},{\"weight\":-0.6242839353595835,\"from\":6,\"to\":24,\"gater\":null},{\"weight\":0.5109561185109239,\"from\":6,\"to\":25,\"gater\":null},{\"weight\":-0.37557309903711583,\"from\":6,\"to\":26,\"gater\":null},{\"weight\":-0.261851050607707,\"from\":6,\"to\":27,\"gater\":null},{\"weight\":-1.07806981602248,\"from\":6,\"to\":28,\"gater\":null},{\"weight\":-0.9952657877607722,\"from\":6,\"to\":29,\"gater\":null},{\"weight\":-0.158943839497106,\"from\":6,\"to\":30,\"gater\":null},{\"weight\":-1.3497946977667243,\"from\":6,\"to\":31,\"gater\":null},{\"weight\":-0.144333408217255,\"from\":6,\"to\":48,\"gater\":null},{\"weight\":-1.1625024445150345,\"from\":7,\"to\":32,\"gater\":16},{\"weight\":2.015509157728726,\"from\":7,\"to\":33,\"gater\":17},{\"weight\":-1.4052185599197133,\"from\":7,\"to\":34,\"gater\":18},{\"weight\":-1.9026693444264475,\"from\":7,\"to\":35,\"gater\":19},{\"weight\":1.6892770188412656,\"from\":7,\"to\":36,\"gater\":20},{\"weight\":1.5727991024412917,\"from\":7,\"to\":37,\"gater\":21},{\"weight\":0.8501441818973113,\"from\":7,\"to\":38,\"gater\":22},{\"weight\":2.5207164472446615,\"from\":7,\"to\":39,\"gater\":23},{\"weight\":0.2203063939071722,\"from\":7,\"to\":16,\"gater\":null},{\"weight\":-0.25044033662072324,\"from\":7,\"to\":17,\"gater\":null},{\"weight\":0.060533059880598414,\"from\":7,\"to\":18,\"gater\":null},{\"weight\":0.7839468806575386,\"from\":7,\"to\":19,\"gater\":null},{\"weight\":0.6569414851256016,\"from\":7,\"to\":20,\"gater\":null},{\"weight\":-1.1010629792574516,\"from\":7,\"to\":21,\"gater\":null},{\"weight\":0.18307975614738856,\"from\":7,\"to\":22,\"gater\":null},{\"weight\":0.546727437994467,\"from\":7,\"to\":23,\"gater\":null},{\"weight\":-0.07007108286420798,\"from\":7,\"to\":40,\"gater\":null},{\"weight\":-0.05278973914303704,\"from\":7,\"to\":41,\"gater\":null},{\"weight\":-0.17155924989772953,\"from\":7,\"to\":42,\"gater\":null},{\"weight\":-0.13840950707528615,\"from\":7,\"to\":43,\"gater\":null},{\"weight\":-0.03744145773479129,\"from\":7,\"to\":44,\"gater\":null},{\"weight\":-0.519510397904051,\"from\":7,\"to\":45,\"gater\":null},{\"weight\":0.14125784074142336,\"from\":7,\"to\":46,\"gater\":null},{\"weight\":-0.7394873061339142,\"from\":7,\"to\":47,\"gater\":null},{\"weight\":-0.637189454593838,\"from\":7,\"to\":24,\"gater\":null},{\"weight\":-0.9340522961834516,\"from\":7,\"to\":25,\"gater\":null},{\"weight\":-0.3301520175758768,\"from\":7,\"to\":26,\"gater\":null},{\"weight\":-0.35185759605610123,\"from\":7,\"to\":27,\"gater\":null},{\"weight\":-1.197734976448176,\"from\":7,\"to\":28,\"gater\":null},{\"weight\":-1.2588991333229076,\"from\":7,\"to\":29,\"gater\":null},{\"weight\":-0.3418271113302366,\"from\":7,\"to\":30,\"gater\":null},{\"weight\":-1.6514262434210472,\"from\":7,\"to\":31,\"gater\":null},{\"weight\":0.7575864715244005,\"from\":7,\"to\":48,\"gater\":null},{\"weight\":0.44014295234228373,\"from\":8,\"to\":32,\"gater\":16},{\"weight\":0.529549173753144,\"from\":8,\"to\":33,\"gater\":17},{\"weight\":0.8127770218567899,\"from\":8,\"to\":34,\"gater\":18},{\"weight\":0.3237809598965591,\"from\":8,\"to\":35,\"gater\":19},{\"weight\":0.2622584994564417,\"from\":8,\"to\":36,\"gater\":20},{\"weight\":1.3904123057099698,\"from\":8,\"to\":37,\"gater\":21},{\"weight\":-0.3855887595928362,\"from\":8,\"to\":38,\"gater\":22},{\"weight\":2.038704291457327,\"from\":8,\"to\":39,\"gater\":23},{\"weight\":0.2685472412060773,\"from\":8,\"to\":16,\"gater\":null},{\"weight\":-0.2958273572311532,\"from\":8,\"to\":17,\"gater\":null},{\"weight\":0.28095861172202585,\"from\":8,\"to\":18,\"gater\":null},{\"weight\":0.5796688661986749,\"from\":8,\"to\":19,\"gater\":null},{\"weight\":-1.000618532218315,\"from\":8,\"to\":20,\"gater\":null},{\"weight\":-0.8873038734200358,\"from\":8,\"to\":21,\"gater\":null},{\"weight\":0.23471981900474445,\"from\":8,\"to\":22,\"gater\":null},{\"weight\":1.8368809805349502,\"from\":8,\"to\":23,\"gater\":null},{\"weight\":-0.40628271642095637,\"from\":8,\"to\":40,\"gater\":null},{\"weight\":-0.0827378258123712,\"from\":8,\"to\":41,\"gater\":null},{\"weight\":-0.4850949142342597,\"from\":8,\"to\":42,\"gater\":null},{\"weight\":-0.6726291362781487,\"from\":8,\"to\":43,\"gater\":null},{\"weight\":-0.18995386968882197,\"from\":8,\"to\":44,\"gater\":null},{\"weight\":0.3396524578956832,\"from\":8,\"to\":45,\"gater\":null},{\"weight\":-0.24462012206981598,\"from\":8,\"to\":46,\"gater\":null},{\"weight\":-1.8801310704809358,\"from\":8,\"to\":47,\"gater\":null},{\"weight\":-0.395017808493138,\"from\":8,\"to\":24,\"gater\":null},{\"weight\":-0.323689463909715,\"from\":8,\"to\":25,\"gater\":null},{\"weight\":-0.39787770451526816,\"from\":8,\"to\":26,\"gater\":null},{\"weight\":-0.2490148788924179,\"from\":8,\"to\":27,\"gater\":null},{\"weight\":-1.0137676724975766,\"from\":8,\"to\":28,\"gater\":null},{\"weight\":-0.97059500848488,\"from\":8,\"to\":29,\"gater\":null},{\"weight\":0.00792484013627467,\"from\":8,\"to\":30,\"gater\":null},{\"weight\":-1.2152071344501911,\"from\":8,\"to\":31,\"gater\":null},{\"weight\":0.9368409883894679,\"from\":8,\"to\":48,\"gater\":null},{\"weight\":0.6703771346452038,\"from\":9,\"to\":32,\"gater\":16},{\"weight\":0.8500557867258595,\"from\":9,\"to\":33,\"gater\":17},{\"weight\":1.122081234982354,\"from\":9,\"to\":34,\"gater\":18},{\"weight\":1.3301442229346714,\"from\":9,\"to\":35,\"gater\":19},{\"weight\":1.1539806881081869,\"from\":9,\"to\":36,\"gater\":20},{\"weight\":1.8539818572191265,\"from\":9,\"to\":37,\"gater\":21},{\"weight\":-0.6582210816153338,\"from\":9,\"to\":38,\"gater\":22},{\"weight\":1.8402554815183523,\"from\":9,\"to\":39,\"gater\":23},{\"weight\":0.01904257911793247,\"from\":9,\"to\":16,\"gater\":null},{\"weight\":-1.5046210477525457,\"from\":9,\"to\":17,\"gater\":null},{\"weight\":0.09988179899293516,\"from\":9,\"to\":18,\"gater\":null},{\"weight\":0.30397337811238134,\"from\":9,\"to\":19,\"gater\":null},{\"weight\":-0.33642283325992767,\"from\":9,\"to\":20,\"gater\":null},{\"weight\":0.7588566459943924,\"from\":9,\"to\":21,\"gater\":null},{\"weight\":0.4170860587548101,\"from\":9,\"to\":22,\"gater\":null},{\"weight\":-2.0960262173515556,\"from\":9,\"to\":23,\"gater\":null},{\"weight\":-0.11409725019123197,\"from\":9,\"to\":40,\"gater\":null},{\"weight\":0.07171670213711784,\"from\":9,\"to\":41,\"gater\":null},{\"weight\":-0.13036034605233351,\"from\":9,\"to\":42,\"gater\":null},{\"weight\":-0.18089658695511326,\"from\":9,\"to\":43,\"gater\":null},{\"weight\":0.028585664067264784,\"from\":9,\"to\":44,\"gater\":null},{\"weight\":-0.45156353467949123,\"from\":9,\"to\":45,\"gater\":null},{\"weight\":0.34912341829168486,\"from\":9,\"to\":46,\"gater\":null},{\"weight\":-0.12020555946521215,\"from\":9,\"to\":47,\"gater\":null},{\"weight\":-0.48961773181444984,\"from\":9,\"to\":24,\"gater\":null},{\"weight\":0.7069971063628024,\"from\":9,\"to\":25,\"gater\":null},{\"weight\":-0.34201680021787667,\"from\":9,\"to\":26,\"gater\":null},{\"weight\":-0.054652877735668,\"from\":9,\"to\":27,\"gater\":null},{\"weight\":-0.8218839619049298,\"from\":9,\"to\":28,\"gater\":null},{\"weight\":-0.9497772835627454,\"from\":9,\"to\":29,\"gater\":null},{\"weight\":-0.09579952176581542,\"from\":9,\"to\":30,\"gater\":null},{\"weight\":-1.015746329325583,\"from\":9,\"to\":31,\"gater\":null},{\"weight\":-0.4861603212222981,\"from\":9,\"to\":48,\"gater\":null},{\"weight\":1.0264536783337361,\"from\":10,\"to\":32,\"gater\":16},{\"weight\":1.9805645981663391,\"from\":10,\"to\":33,\"gater\":17},{\"weight\":1.7926865959201541,\"from\":10,\"to\":34,\"gater\":18},{\"weight\":2.105562489497556,\"from\":10,\"to\":35,\"gater\":19},{\"weight\":1.7602174949039286,\"from\":10,\"to\":36,\"gater\":20},{\"weight\":0.8594939873461248,\"from\":10,\"to\":37,\"gater\":21},{\"weight\":-0.5145478403007733,\"from\":10,\"to\":38,\"gater\":22},{\"weight\":1.7427695722972245,\"from\":10,\"to\":39,\"gater\":23},{\"weight\":-0.09616286963350454,\"from\":10,\"to\":16,\"gater\":null},{\"weight\":0.44815148671009225,\"from\":10,\"to\":17,\"gater\":null},{\"weight\":-0.21852793198169385,\"from\":10,\"to\":18,\"gater\":null},{\"weight\":-0.41250464394925446,\"from\":10,\"to\":19,\"gater\":null},{\"weight\":1.9582987480177445,\"from\":10,\"to\":20,\"gater\":null},{\"weight\":0.26364192229097694,\"from\":10,\"to\":21,\"gater\":null},{\"weight\":0.2839918482255185,\"from\":10,\"to\":22,\"gater\":null},{\"weight\":-1.402852590350222,\"from\":10,\"to\":23,\"gater\":null},{\"weight\":0.10762574067328029,\"from\":10,\"to\":40,\"gater\":null},{\"weight\":0.001000606587407429,\"from\":10,\"to\":41,\"gater\":null},{\"weight\":0.09373322441603296,\"from\":10,\"to\":42,\"gater\":null},{\"weight\":0.09290603306466634,\"from\":10,\"to\":43,\"gater\":null},{\"weight\":0.1974582170589312,\"from\":10,\"to\":44,\"gater\":null},{\"weight\":0.30691539102834176,\"from\":10,\"to\":45,\"gater\":null},{\"weight\":-0.04993454867450368,\"from\":10,\"to\":46,\"gater\":null},{\"weight\":1.0285716929907684,\"from\":10,\"to\":47,\"gater\":null},{\"weight\":-0.34920629273847215,\"from\":10,\"to\":24,\"gater\":null},{\"weight\":0.6194456826912853,\"from\":10,\"to\":25,\"gater\":null},{\"weight\":-0.14034053871055654,\"from\":10,\"to\":26,\"gater\":null},{\"weight\":0.1649231744623102,\"from\":10,\"to\":27,\"gater\":null},{\"weight\":-0.9835077637099389,\"from\":10,\"to\":28,\"gater\":null},{\"weight\":-1.0387782050088505,\"from\":10,\"to\":29,\"gater\":null},{\"weight\":0.26031158996598824,\"from\":10,\"to\":30,\"gater\":null},{\"weight\":-1.240723057381562,\"from\":10,\"to\":31,\"gater\":null},{\"weight\":-1.014580605331753,\"from\":10,\"to\":48,\"gater\":null},{\"weight\":0.1004934741268264,\"from\":11,\"to\":32,\"gater\":16},{\"weight\":-1.3490956163977221,\"from\":11,\"to\":33,\"gater\":17},{\"weight\":0.6642624365824379,\"from\":11,\"to\":34,\"gater\":18},{\"weight\":0.31950673716118794,\"from\":11,\"to\":35,\"gater\":19},{\"weight\":2.23762528031895,\"from\":11,\"to\":36,\"gater\":20},{\"weight\":2.2893004280463094,\"from\":11,\"to\":37,\"gater\":21},{\"weight\":-0.003481099897392808,\"from\":11,\"to\":38,\"gater\":22},{\"weight\":1.5600209161216256,\"from\":11,\"to\":39,\"gater\":23},{\"weight\":-0.3420468527599594,\"from\":11,\"to\":16,\"gater\":null},{\"weight\":-0.607794394820993,\"from\":11,\"to\":17,\"gater\":null},{\"weight\":-0.42430759186000383,\"from\":11,\"to\":18,\"gater\":null},{\"weight\":-0.6479328193226617,\"from\":11,\"to\":19,\"gater\":null},{\"weight\":1.960288985224543,\"from\":11,\"to\":20,\"gater\":null},{\"weight\":1.1470849981723088,\"from\":11,\"to\":21,\"gater\":null},{\"weight\":0.2409139035295526,\"from\":11,\"to\":22,\"gater\":null},{\"weight\":-1.663316047567601,\"from\":11,\"to\":23,\"gater\":null},{\"weight\":-0.05210276211417793,\"from\":11,\"to\":40,\"gater\":null},{\"weight\":0.008424641509430314,\"from\":11,\"to\":41,\"gater\":null},{\"weight\":0.030070483944016464,\"from\":11,\"to\":42,\"gater\":null},{\"weight\":0.03441584899830987,\"from\":11,\"to\":43,\"gater\":null},{\"weight\":0.3328573897933797,\"from\":11,\"to\":44,\"gater\":null},{\"weight\":0.24450381803209784,\"from\":11,\"to\":45,\"gater\":null},{\"weight\":0.5107258000347807,\"from\":11,\"to\":46,\"gater\":null},{\"weight\":0.2432907679291377,\"from\":11,\"to\":47,\"gater\":null},{\"weight\":-0.15388239281242208,\"from\":11,\"to\":24,\"gater\":null},{\"weight\":0.41395918382839103,\"from\":11,\"to\":25,\"gater\":null},{\"weight\":0.14458854939601734,\"from\":11,\"to\":26,\"gater\":null},{\"weight\":0.5220905369408496,\"from\":11,\"to\":27,\"gater\":null},{\"weight\":-1.0448772964077147,\"from\":11,\"to\":28,\"gater\":null},{\"weight\":-1.035326215668578,\"from\":11,\"to\":29,\"gater\":null},{\"weight\":0.11262181098565964,\"from\":11,\"to\":30,\"gater\":null},{\"weight\":-1.6907094534391112,\"from\":11,\"to\":31,\"gater\":null},{\"weight\":-1.7869216762396634,\"from\":11,\"to\":48,\"gater\":null},{\"weight\":-0.28345753279251756,\"from\":12,\"to\":32,\"gater\":16},{\"weight\":0.5950784236944523,\"from\":12,\"to\":33,\"gater\":17},{\"weight\":-0.7757794983357369,\"from\":12,\"to\":34,\"gater\":18},{\"weight\":-1.1091876986130642,\"from\":12,\"to\":35,\"gater\":19},{\"weight\":0.9498843606735697,\"from\":12,\"to\":36,\"gater\":20},{\"weight\":1.2825718321496598,\"from\":12,\"to\":37,\"gater\":21},{\"weight\":0.7346687116401963,\"from\":12,\"to\":38,\"gater\":22},{\"weight\":1.5194912490631398,\"from\":12,\"to\":39,\"gater\":23},{\"weight\":-0.33706782327655327,\"from\":12,\"to\":16,\"gater\":null},{\"weight\":0.39309772548234345,\"from\":12,\"to\":17,\"gater\":null},{\"weight\":-0.5102372065159786,\"from\":12,\"to\":18,\"gater\":null},{\"weight\":-1.08087327262284,\"from\":12,\"to\":19,\"gater\":null},{\"weight\":0.5203116885664871,\"from\":12,\"to\":20,\"gater\":null},{\"weight\":-0.8546056377461502,\"from\":12,\"to\":21,\"gater\":null},{\"weight\":0.11175158856379364,\"from\":12,\"to\":22,\"gater\":null},{\"weight\":0.051009574440168355,\"from\":12,\"to\":23,\"gater\":null},{\"weight\":-0.07065075777899825,\"from\":12,\"to\":40,\"gater\":null},{\"weight\":0.1045269251824258,\"from\":12,\"to\":41,\"gater\":null},{\"weight\":0.1150027397632106,\"from\":12,\"to\":42,\"gater\":null},{\"weight\":0.04092609712823536,\"from\":12,\"to\":43,\"gater\":null},{\"weight\":0.2042518129918008,\"from\":12,\"to\":44,\"gater\":null},{\"weight\":-0.2343472106669425,\"from\":12,\"to\":45,\"gater\":null},{\"weight\":0.292563345207943,\"from\":12,\"to\":46,\"gater\":null},{\"weight\":-0.575677358627147,\"from\":12,\"to\":47,\"gater\":null},{\"weight\":-0.3003950218035274,\"from\":12,\"to\":24,\"gater\":null},{\"weight\":0.09992956612907611,\"from\":12,\"to\":25,\"gater\":null},{\"weight\":0.23283419613917722,\"from\":12,\"to\":26,\"gater\":null},{\"weight\":0.5047423129662295,\"from\":12,\"to\":27,\"gater\":null},{\"weight\":-0.9244368767470438,\"from\":12,\"to\":28,\"gater\":null},{\"weight\":-1.1121187229965814,\"from\":12,\"to\":29,\"gater\":null},{\"weight\":0.3157707181165442,\"from\":12,\"to\":30,\"gater\":null},{\"weight\":-1.6066593421835165,\"from\":12,\"to\":31,\"gater\":null},{\"weight\":-0.6021498473432828,\"from\":12,\"to\":48,\"gater\":null},{\"weight\":0.9795943534726008,\"from\":13,\"to\":32,\"gater\":16},{\"weight\":0.8340997101043274,\"from\":13,\"to\":33,\"gater\":17},{\"weight\":0.7767763717196728,\"from\":13,\"to\":34,\"gater\":18},{\"weight\":0.7851778977578887,\"from\":13,\"to\":35,\"gater\":19},{\"weight\":-0.30047779338748665,\"from\":13,\"to\":36,\"gater\":20},{\"weight\":0.7184414553496695,\"from\":13,\"to\":37,\"gater\":21},{\"weight\":-0.773166261744348,\"from\":13,\"to\":38,\"gater\":22},{\"weight\":1.747877343003597,\"from\":13,\"to\":39,\"gater\":23},{\"weight\":-0.24330556962735786,\"from\":13,\"to\":16,\"gater\":null},{\"weight\":0.5098809973857813,\"from\":13,\"to\":17,\"gater\":null},{\"weight\":-0.6490860854322925,\"from\":13,\"to\":18,\"gater\":null},{\"weight\":-0.8883649843682624,\"from\":13,\"to\":19,\"gater\":null},{\"weight\":0.2990130665414218,\"from\":13,\"to\":20,\"gater\":null},{\"weight\":-2.8713515043736577,\"from\":13,\"to\":21,\"gater\":null},{\"weight\":0.3828956645315583,\"from\":13,\"to\":22,\"gater\":null},{\"weight\":1.9072904625074514,\"from\":13,\"to\":23,\"gater\":null},{\"weight\":-0.10160058749766415,\"from\":13,\"to\":40,\"gater\":null},{\"weight\":0.07084015041227108,\"from\":13,\"to\":41,\"gater\":null},{\"weight\":-0.2665015752119728,\"from\":13,\"to\":42,\"gater\":null},{\"weight\":-0.3119445646156335,\"from\":13,\"to\":43,\"gater\":null},{\"weight\":-0.2311955376244944,\"from\":13,\"to\":44,\"gater\":null},{\"weight\":-0.450408704261826,\"from\":13,\"to\":45,\"gater\":null},{\"weight\":-0.23549533327410826,\"from\":13,\"to\":46,\"gater\":null},{\"weight\":-0.7748105661033011,\"from\":13,\"to\":47,\"gater\":null},{\"weight\":-0.29810560910968686,\"from\":13,\"to\":24,\"gater\":null},{\"weight\":0.31769410011496413,\"from\":13,\"to\":25,\"gater\":null},{\"weight\":0.17508809785277102,\"from\":13,\"to\":26,\"gater\":null},{\"weight\":0.35156480810515217,\"from\":13,\"to\":27,\"gater\":null},{\"weight\":-0.8831041522465827,\"from\":13,\"to\":28,\"gater\":null},{\"weight\":-0.7298310007633231,\"from\":13,\"to\":29,\"gater\":null},{\"weight\":0.30850697521057874,\"from\":13,\"to\":30,\"gater\":null},{\"weight\":-0.569095665837268,\"from\":13,\"to\":31,\"gater\":null},{\"weight\":-2.2610652173962222,\"from\":13,\"to\":48,\"gater\":null},{\"weight\":3.607781368064541,\"from\":14,\"to\":32,\"gater\":16},{\"weight\":0.18405154655765746,\"from\":14,\"to\":33,\"gater\":17},{\"weight\":5.261822725867953,\"from\":14,\"to\":34,\"gater\":18},{\"weight\":6.374173783012299,\"from\":14,\"to\":35,\"gater\":19},{\"weight\":1.5587068596782552,\"from\":14,\"to\":36,\"gater\":20},{\"weight\":0.7527093069435731,\"from\":14,\"to\":37,\"gater\":21},{\"weight\":-3.8907584440013663,\"from\":14,\"to\":38,\"gater\":22},{\"weight\":0.49114771407410385,\"from\":14,\"to\":39,\"gater\":23},{\"weight\":0.15711042900692818,\"from\":14,\"to\":16,\"gater\":null},{\"weight\":-0.4021196596612141,\"from\":14,\"to\":17,\"gater\":null},{\"weight\":-0.12413050840729793,\"from\":14,\"to\":18,\"gater\":null},{\"weight\":0.09022132647981403,\"from\":14,\"to\":19,\"gater\":null},{\"weight\":1.6797320547652337,\"from\":14,\"to\":20,\"gater\":null},{\"weight\":-0.525650736032929,\"from\":14,\"to\":21,\"gater\":null},{\"weight\":0.5532243497025459,\"from\":14,\"to\":22,\"gater\":null},{\"weight\":-0.24496475441878574,\"from\":14,\"to\":23,\"gater\":null},{\"weight\":-0.38428369595849227,\"from\":14,\"to\":40,\"gater\":null},{\"weight\":-0.061231220056767066,\"from\":14,\"to\":41,\"gater\":null},{\"weight\":-0.24848105902450754,\"from\":14,\"to\":42,\"gater\":null},{\"weight\":-0.26267361429460023,\"from\":14,\"to\":43,\"gater\":null},{\"weight\":-0.1473953740287114,\"from\":14,\"to\":44,\"gater\":null},{\"weight\":-0.6820545915812181,\"from\":14,\"to\":45,\"gater\":null},{\"weight\":0.3480682517939196,\"from\":14,\"to\":46,\"gater\":null},{\"weight\":-0.06786004160701058,\"from\":14,\"to\":47,\"gater\":null},{\"weight\":-0.4641487001410635,\"from\":14,\"to\":24,\"gater\":null},{\"weight\":0.43250256659004205,\"from\":14,\"to\":25,\"gater\":null},{\"weight\":-0.2693279956046046,\"from\":14,\"to\":26,\"gater\":null},{\"weight\":0.11993662324356741,\"from\":14,\"to\":27,\"gater\":null},{\"weight\":-0.7023945128191863,\"from\":14,\"to\":28,\"gater\":null},{\"weight\":-0.7449653467312509,\"from\":14,\"to\":29,\"gater\":null},{\"weight\":-0.12028058345963646,\"from\":14,\"to\":30,\"gater\":null},{\"weight\":-0.7832602330917511,\"from\":14,\"to\":31,\"gater\":null},{\"weight\":-3.286023548876049,\"from\":14,\"to\":48,\"gater\":null},{\"weight\":1.1658250749265335,\"from\":15,\"to\":32,\"gater\":16},{\"weight\":-0.9616436022877948,\"from\":15,\"to\":33,\"gater\":17},{\"weight\":1.0911302813814943,\"from\":15,\"to\":34,\"gater\":18},{\"weight\":1.5188918867315013,\"from\":15,\"to\":35,\"gater\":19},{\"weight\":-1.2331473977167895,\"from\":15,\"to\":36,\"gater\":20},{\"weight\":-2.0599422947144683,\"from\":15,\"to\":37,\"gater\":21},{\"weight\":-0.6826179532432985,\"from\":15,\"to\":38,\"gater\":22},{\"weight\":-1.3683787309391806,\"from\":15,\"to\":39,\"gater\":23},{\"weight\":0.0172164499623431,\"from\":15,\"to\":16,\"gater\":null},{\"weight\":-0.002259758897611631,\"from\":15,\"to\":17,\"gater\":null},{\"weight\":-0.015363114037449615,\"from\":15,\"to\":18,\"gater\":null},{\"weight\":0.12867078329886913,\"from\":15,\"to\":19,\"gater\":null},{\"weight\":0.10110965739854115,\"from\":15,\"to\":20,\"gater\":null},{\"weight\":-0.31240778937388325,\"from\":15,\"to\":21,\"gater\":null},{\"weight\":0.3245258100245633,\"from\":15,\"to\":22,\"gater\":null},{\"weight\":1.927217499834899,\"from\":15,\"to\":23,\"gater\":null},{\"weight\":-0.3772443476426713,\"from\":15,\"to\":40,\"gater\":null},{\"weight\":-0.0006671238906661688,\"from\":15,\"to\":41,\"gater\":null},{\"weight\":-0.4574590196144502,\"from\":15,\"to\":42,\"gater\":null},{\"weight\":-0.4344894144746092,\"from\":15,\"to\":43,\"gater\":null},{\"weight\":-0.5310911214070204,\"from\":15,\"to\":44,\"gater\":null},{\"weight\":-1.3019023928596185,\"from\":15,\"to\":45,\"gater\":null},{\"weight\":2.11877499377707,\"from\":15,\"to\":46,\"gater\":null},{\"weight\":-1.7576305261815448,\"from\":15,\"to\":47,\"gater\":null},{\"weight\":-0.5864800234986439,\"from\":15,\"to\":24,\"gater\":null},{\"weight\":0.5890586759094982,\"from\":15,\"to\":25,\"gater\":null},{\"weight\":-0.9240726236659176,\"from\":15,\"to\":26,\"gater\":null},{\"weight\":-0.5338056436942966,\"from\":15,\"to\":27,\"gater\":null},{\"weight\":-0.8015761352457211,\"from\":15,\"to\":28,\"gater\":null},{\"weight\":-0.7445726939159213,\"from\":15,\"to\":29,\"gater\":null},{\"weight\":-0.06866699667865328,\"from\":15,\"to\":30,\"gater\":null},{\"weight\":-1.379420325460355,\"from\":15,\"to\":31,\"gater\":null},{\"weight\":-8.115730392640375,\"from\":15,\"to\":48,\"gater\":null},{\"weight\":0.6559530881570709,\"from\":32,\"to\":16,\"gater\":null},{\"weight\":0.6594653922369191,\"from\":32,\"to\":17,\"gater\":null},{\"weight\":0.45971858699682344,\"from\":32,\"to\":18,\"gater\":null},{\"weight\":0.3440757219105955,\"from\":32,\"to\":19,\"gater\":null},{\"weight\":0.7672917488135873,\"from\":32,\"to\":20,\"gater\":null},{\"weight\":0.8912666533333484,\"from\":32,\"to\":21,\"gater\":null},{\"weight\":0.28320426226426526,\"from\":32,\"to\":22,\"gater\":null},{\"weight\":1.8225949746713521,\"from\":32,\"to\":23,\"gater\":null},{\"weight\":0.47180417172951805,\"from\":32,\"to\":24,\"gater\":null},{\"weight\":0.5699363019708987,\"from\":32,\"to\":25,\"gater\":null},{\"weight\":0.22997767437721228,\"from\":32,\"to\":26,\"gater\":null},{\"weight\":-0.48541668812294486,\"from\":32,\"to\":27,\"gater\":null},{\"weight\":-1.108034025402204,\"from\":32,\"to\":28,\"gater\":null},{\"weight\":-1.3104811849803508,\"from\":32,\"to\":29,\"gater\":null},{\"weight\":0.05675265831274876,\"from\":32,\"to\":30,\"gater\":null},{\"weight\":0.4623173885424605,\"from\":32,\"to\":31,\"gater\":null},{\"weight\":-0.19319595340021609,\"from\":32,\"to\":40,\"gater\":null},{\"weight\":-0.058728484139512156,\"from\":32,\"to\":41,\"gater\":null},{\"weight\":-0.30073903589048345,\"from\":32,\"to\":42,\"gater\":null},{\"weight\":-0.31785090968643354,\"from\":32,\"to\":43,\"gater\":null},{\"weight\":0.20756831280538618,\"from\":32,\"to\":44,\"gater\":null},{\"weight\":0.1452161916832053,\"from\":32,\"to\":45,\"gater\":null},{\"weight\":-0.2219907352883737,\"from\":32,\"to\":46,\"gater\":null},{\"weight\":-0.3348515439003665,\"from\":32,\"to\":47,\"gater\":null},{\"weight\":2.9709328275514055,\"from\":32,\"to\":48,\"gater\":40},{\"weight\":0.8183002635906624,\"from\":33,\"to\":16,\"gater\":null},{\"weight\":0.7799176201795585,\"from\":33,\"to\":17,\"gater\":null},{\"weight\":0.674137106972985,\"from\":33,\"to\":18,\"gater\":null},{\"weight\":1.9119920868648046,\"from\":33,\"to\":19,\"gater\":null},{\"weight\":0.45941785820789316,\"from\":33,\"to\":20,\"gater\":null},{\"weight\":2.0866957842340526,\"from\":33,\"to\":21,\"gater\":null},{\"weight\":0.5867629172776737,\"from\":33,\"to\":22,\"gater\":null},{\"weight\":-0.3898853354756614,\"from\":33,\"to\":23,\"gater\":null},{\"weight\":-0.9572350894110532,\"from\":33,\"to\":24,\"gater\":null},{\"weight\":0.12359448233017632,\"from\":33,\"to\":25,\"gater\":null},{\"weight\":-0.3650920848934496,\"from\":33,\"to\":26,\"gater\":null},{\"weight\":-1.9226617006854945,\"from\":33,\"to\":27,\"gater\":null},{\"weight\":-0.5531750471572999,\"from\":33,\"to\":28,\"gater\":null},{\"weight\":-1.2061582618087632,\"from\":33,\"to\":29,\"gater\":null},{\"weight\":-0.825438439938674,\"from\":33,\"to\":30,\"gater\":null},{\"weight\":-1.5053972498181054,\"from\":33,\"to\":31,\"gater\":null},{\"weight\":0.10918035550551103,\"from\":33,\"to\":40,\"gater\":null},{\"weight\":0.10736563715771301,\"from\":33,\"to\":41,\"gater\":null},{\"weight\":-0.03824805804445211,\"from\":33,\"to\":42,\"gater\":null},{\"weight\":0.10252883110364337,\"from\":33,\"to\":43,\"gater\":null},{\"weight\":0.3033049680216993,\"from\":33,\"to\":44,\"gater\":null},{\"weight\":-0.552744948128924,\"from\":33,\"to\":45,\"gater\":null},{\"weight\":-0.37904272580878595,\"from\":33,\"to\":46,\"gater\":null},{\"weight\":-0.7845465681504334,\"from\":33,\"to\":47,\"gater\":null},{\"weight\":-0.515660783443284,\"from\":33,\"to\":48,\"gater\":41},{\"weight\":0.742549307396069,\"from\":34,\"to\":16,\"gater\":null},{\"weight\":0.6907103434545612,\"from\":34,\"to\":17,\"gater\":null},{\"weight\":0.44742171544186077,\"from\":34,\"to\":18,\"gater\":null},{\"weight\":0.36584291238558786,\"from\":34,\"to\":19,\"gater\":null},{\"weight\":-0.24603715602949047,\"from\":34,\"to\":20,\"gater\":null},{\"weight\":-1.1042354795641318,\"from\":34,\"to\":21,\"gater\":null},{\"weight\":0.48452649530529757,\"from\":34,\"to\":22,\"gater\":null},{\"weight\":0.550567838530334,\"from\":34,\"to\":23,\"gater\":null},{\"weight\":0.23410096165397876,\"from\":34,\"to\":24,\"gater\":null},{\"weight\":0.3778204254984058,\"from\":34,\"to\":25,\"gater\":null},{\"weight\":0.3164396678234567,\"from\":34,\"to\":26,\"gater\":null},{\"weight\":-0.5092036723062787,\"from\":34,\"to\":27,\"gater\":null},{\"weight\":-1.2755594186855055,\"from\":34,\"to\":28,\"gater\":null},{\"weight\":-1.6310638444325092,\"from\":34,\"to\":29,\"gater\":null},{\"weight\":0.027022525061440924,\"from\":34,\"to\":30,\"gater\":null},{\"weight\":-0.03624506164548296,\"from\":34,\"to\":31,\"gater\":null},{\"weight\":-0.25704539268112037,\"from\":34,\"to\":40,\"gater\":null},{\"weight\":0.056111776154130155,\"from\":34,\"to\":41,\"gater\":null},{\"weight\":-0.4049616000189435,\"from\":34,\"to\":42,\"gater\":null},{\"weight\":-0.36268098461164633,\"from\":34,\"to\":43,\"gater\":null},{\"weight\":0.1153554556983569,\"from\":34,\"to\":44,\"gater\":null},{\"weight\":0.05177267482057777,\"from\":34,\"to\":45,\"gater\":null},{\"weight\":0.5595634046781139,\"from\":34,\"to\":46,\"gater\":null},{\"weight\":-1.6995181013122134,\"from\":34,\"to\":47,\"gater\":null},{\"weight\":2.453695200665841,\"from\":34,\"to\":48,\"gater\":42},{\"weight\":0.7742075476686139,\"from\":35,\"to\":16,\"gater\":null},{\"weight\":0.6869557094347971,\"from\":35,\"to\":17,\"gater\":null},{\"weight\":0.42646878698442087,\"from\":35,\"to\":18,\"gater\":null},{\"weight\":0.13057230343975612,\"from\":35,\"to\":19,\"gater\":null},{\"weight\":1.2203687501633247,\"from\":35,\"to\":20,\"gater\":null},{\"weight\":2.961650996025775,\"from\":35,\"to\":21,\"gater\":null},{\"weight\":0.6368484806668897,\"from\":35,\"to\":22,\"gater\":null},{\"weight\":4.735910551662895,\"from\":35,\"to\":23,\"gater\":null},{\"weight\":0.5870999428664869,\"from\":35,\"to\":24,\"gater\":null},{\"weight\":0.7995401626709602,\"from\":35,\"to\":25,\"gater\":null},{\"weight\":0.17781426602980208,\"from\":35,\"to\":26,\"gater\":null},{\"weight\":-0.4272501276892675,\"from\":35,\"to\":27,\"gater\":null},{\"weight\":-1.3510224249978051,\"from\":35,\"to\":28,\"gater\":null},{\"weight\":-1.839290953271434,\"from\":35,\"to\":29,\"gater\":null},{\"weight\":0.36649764339628665,\"from\":35,\"to\":30,\"gater\":null},{\"weight\":0.5091133599419981,\"from\":35,\"to\":31,\"gater\":null},{\"weight\":-0.2952513672211839,\"from\":35,\"to\":40,\"gater\":null},{\"weight\":-0.04333779693063023,\"from\":35,\"to\":41,\"gater\":null},{\"weight\":-0.29519979278963415,\"from\":35,\"to\":42,\"gater\":null},{\"weight\":-0.2418121754191896,\"from\":35,\"to\":43,\"gater\":null},{\"weight\":0.2385471696083171,\"from\":35,\"to\":44,\"gater\":null},{\"weight\":0.018235025058799093,\"from\":35,\"to\":45,\"gater\":null},{\"weight\":-0.04594723317266024,\"from\":35,\"to\":46,\"gater\":null},{\"weight\":-0.9230922182534301,\"from\":35,\"to\":47,\"gater\":null},{\"weight\":3.1298681433183115,\"from\":35,\"to\":48,\"gater\":43},{\"weight\":0.4301250847833904,\"from\":36,\"to\":16,\"gater\":null},{\"weight\":0.26596105697254346,\"from\":36,\"to\":17,\"gater\":null},{\"weight\":0.2032079219227522,\"from\":36,\"to\":18,\"gater\":null},{\"weight\":0.027099055989384835,\"from\":36,\"to\":19,\"gater\":null},{\"weight\":-0.1626990085613276,\"from\":36,\"to\":20,\"gater\":null},{\"weight\":-1.4609797689539785,\"from\":36,\"to\":21,\"gater\":null},{\"weight\":0.3947296049665863,\"from\":36,\"to\":22,\"gater\":null},{\"weight\":2.0555553988516846,\"from\":36,\"to\":23,\"gater\":null},{\"weight\":0.033304069518483755,\"from\":36,\"to\":24,\"gater\":null},{\"weight\":0.8313038032937545,\"from\":36,\"to\":25,\"gater\":null},{\"weight\":-0.6103851848205591,\"from\":36,\"to\":26,\"gater\":null},{\"weight\":-0.8465727747097681,\"from\":36,\"to\":27,\"gater\":null},{\"weight\":-1.2954390828095108,\"from\":36,\"to\":28,\"gater\":null},{\"weight\":-1.7804346739568413,\"from\":36,\"to\":29,\"gater\":null},{\"weight\":-0.3392404861681661,\"from\":36,\"to\":30,\"gater\":null},{\"weight\":-1.2409910949806406,\"from\":36,\"to\":31,\"gater\":null},{\"weight\":0.39280250983238446,\"from\":36,\"to\":40,\"gater\":null},{\"weight\":0.055606203985130644,\"from\":36,\"to\":41,\"gater\":null},{\"weight\":0.7778644781979523,\"from\":36,\"to\":42,\"gater\":null},{\"weight\":0.861395397452407,\"from\":36,\"to\":43,\"gater\":null},{\"weight\":0.4181991625096981,\"from\":36,\"to\":44,\"gater\":null},{\"weight\":1.173210465872443,\"from\":36,\"to\":45,\"gater\":null},{\"weight\":-0.6827682791439779,\"from\":36,\"to\":46,\"gater\":null},{\"weight\":0.8267321905562602,\"from\":36,\"to\":47,\"gater\":null},{\"weight\":5.436000820686911,\"from\":36,\"to\":48,\"gater\":44},{\"weight\":0.4737658466056736,\"from\":37,\"to\":16,\"gater\":null},{\"weight\":0.057411370948459016,\"from\":37,\"to\":17,\"gater\":null},{\"weight\":0.4134650087195943,\"from\":37,\"to\":18,\"gater\":null},{\"weight\":1.0591324810655562,\"from\":37,\"to\":19,\"gater\":null},{\"weight\":-3.0730187713302044,\"from\":37,\"to\":20,\"gater\":null},{\"weight\":1.2315309377245163,\"from\":37,\"to\":21,\"gater\":null},{\"weight\":0.34616974565950187,\"from\":37,\"to\":22,\"gater\":null},{\"weight\":1.726058841147013,\"from\":37,\"to\":23,\"gater\":null},{\"weight\":-0.07160974831180442,\"from\":37,\"to\":24,\"gater\":null},{\"weight\":1.0640929413992548,\"from\":37,\"to\":25,\"gater\":null},{\"weight\":-0.6553864363756503,\"from\":37,\"to\":26,\"gater\":null},{\"weight\":-1.5274655448813166,\"from\":37,\"to\":27,\"gater\":null},{\"weight\":-1.43576774748092,\"from\":37,\"to\":28,\"gater\":null},{\"weight\":-1.7429365837833186,\"from\":37,\"to\":29,\"gater\":null},{\"weight\":-0.7437750802702856,\"from\":37,\"to\":30,\"gater\":null},{\"weight\":-0.6117454204668981,\"from\":37,\"to\":31,\"gater\":null},{\"weight\":0.669743931376621,\"from\":37,\"to\":40,\"gater\":null},{\"weight\":-0.046000611183502245,\"from\":37,\"to\":41,\"gater\":null},{\"weight\":0.911989341734844,\"from\":37,\"to\":42,\"gater\":null},{\"weight\":1.0215869028213025,\"from\":37,\"to\":43,\"gater\":null},{\"weight\":0.7642163262922678,\"from\":37,\"to\":44,\"gater\":null},{\"weight\":0.34037077125387244,\"from\":37,\"to\":45,\"gater\":null},{\"weight\":-1.5235807128762902,\"from\":37,\"to\":46,\"gater\":null},{\"weight\":3.4281037123543805,\"from\":37,\"to\":47,\"gater\":null},{\"weight\":6.769696582523754,\"from\":37,\"to\":48,\"gater\":45},{\"weight\":-0.06472744688033888,\"from\":38,\"to\":16,\"gater\":null},{\"weight\":0.055798359668462284,\"from\":38,\"to\":17,\"gater\":null},{\"weight\":-0.31426976368247567,\"from\":38,\"to\":18,\"gater\":null},{\"weight\":-0.15393923650342095,\"from\":38,\"to\":19,\"gater\":null},{\"weight\":-0.9418528909159132,\"from\":38,\"to\":20,\"gater\":null},{\"weight\":-1.0522855570524956,\"from\":38,\"to\":21,\"gater\":null},{\"weight\":0.5122149709852628,\"from\":38,\"to\":22,\"gater\":null},{\"weight\":-2.5747147065435567,\"from\":38,\"to\":23,\"gater\":null},{\"weight\":-2.1020253139870846,\"from\":38,\"to\":24,\"gater\":null},{\"weight\":-2.0456695072575872,\"from\":38,\"to\":25,\"gater\":null},{\"weight\":-0.5887321637760217,\"from\":38,\"to\":26,\"gater\":null},{\"weight\":-1.4421401735083907,\"from\":38,\"to\":27,\"gater\":null},{\"weight\":-1.8754000862374773,\"from\":38,\"to\":28,\"gater\":null},{\"weight\":-2.430569229259943,\"from\":38,\"to\":29,\"gater\":null},{\"weight\":-1.7338073375713003,\"from\":38,\"to\":30,\"gater\":null},{\"weight\":-5.446581445150688,\"from\":38,\"to\":31,\"gater\":null},{\"weight\":-0.035765070495136615,\"from\":38,\"to\":40,\"gater\":null},{\"weight\":-0.009722208492329278,\"from\":38,\"to\":41,\"gater\":null},{\"weight\":-0.4630860163390437,\"from\":38,\"to\":42,\"gater\":null},{\"weight\":-0.11949023842278456,\"from\":38,\"to\":43,\"gater\":null},{\"weight\":0.14336604568874506,\"from\":38,\"to\":44,\"gater\":null},{\"weight\":0.3003635158936644,\"from\":38,\"to\":45,\"gater\":null},{\"weight\":-0.049278783265241835,\"from\":38,\"to\":46,\"gater\":null},{\"weight\":0.4859041719148424,\"from\":38,\"to\":47,\"gater\":null},{\"weight\":-4.8485788325769015,\"from\":38,\"to\":48,\"gater\":46},{\"weight\":0.6322455456193898,\"from\":39,\"to\":16,\"gater\":null},{\"weight\":0.9325736968113408,\"from\":39,\"to\":17,\"gater\":null},{\"weight\":0.2811428211687914,\"from\":39,\"to\":18,\"gater\":null},{\"weight\":0.5081383217885054,\"from\":39,\"to\":19,\"gater\":null},{\"weight\":-1.197954606069403,\"from\":39,\"to\":20,\"gater\":null},{\"weight\":-1.934825635223983,\"from\":39,\"to\":21,\"gater\":null},{\"weight\":0.9027098128530762,\"from\":39,\"to\":22,\"gater\":null},{\"weight\":-1.8735616502452748,\"from\":39,\"to\":23,\"gater\":null},{\"weight\":-0.8877960472949762,\"from\":39,\"to\":24,\"gater\":null},{\"weight\":0.26706898221633196,\"from\":39,\"to\":25,\"gater\":null},{\"weight\":-0.19390590608953034,\"from\":39,\"to\":26,\"gater\":null},{\"weight\":-1.2207118159195747,\"from\":39,\"to\":27,\"gater\":null},{\"weight\":-1.864002733954452,\"from\":39,\"to\":28,\"gater\":null},{\"weight\":-2.0854118972424427,\"from\":39,\"to\":29,\"gater\":null},{\"weight\":-1.003655622728177,\"from\":39,\"to\":30,\"gater\":null},{\"weight\":-3.126688167203178,\"from\":39,\"to\":31,\"gater\":null},{\"weight\":0.7735063235787005,\"from\":39,\"to\":40,\"gater\":null},{\"weight\":0.045272051779631374,\"from\":39,\"to\":41,\"gater\":null},{\"weight\":0.1808918519339413,\"from\":39,\"to\":42,\"gater\":null},{\"weight\":0.5162073029806531,\"from\":39,\"to\":43,\"gater\":null},{\"weight\":0.48115990980384404,\"from\":39,\"to\":44,\"gater\":null},{\"weight\":1.2892478737791357,\"from\":39,\"to\":45,\"gater\":null},{\"weight\":-1.1137295500734934,\"from\":39,\"to\":46,\"gater\":null},{\"weight\":0.6424253872612141,\"from\":39,\"to\":47,\"gater\":null},{\"weight\":9.743849490645582,\"from\":39,\"to\":48,\"gater\":47}],\"input\":16,\"output\":1,\"dropout\":0});\r\nconst length = xy => Math.min(1, Math.sqrt(xy[0]*xy[0] + xy[1]*xy[1]) / 100);\r\nconst prepareData = dataPositions => dataPositions.map((dp, i) => {\r\n\tif(i > 0){\r\n\t\tconst last = dataPositions[i-1];\r\n\t\treturn [\r\n\t\t\tdp[0] - last[0],\r\n\t\t\tdp[1] - last[1]\r\n\t\t]\r\n\t}\r\n}).slice(1, dataPositions.length).map(length);\r\n\r\n\r\nconst predictAction = mousePositions => !!Math.round(network.activate(prepareData(mousePositions)));\n\n//# sourceURL=webpack:///./predictor/predictAction.js?");

/***/ }),

/***/ "./styles.js":
/*!*******************!*\
  !*** ./styles.js ***!
  \*******************/
/*! exports provided: addPredictiveHoverRules, addHoverClass, removeHoverClass */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addPredictiveHoverRules\", function() { return addPredictiveHoverRules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addHoverClass\", function() { return addHoverClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeHoverClass\", function() { return removeHoverClass; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./constants.js\");\n\r\n\r\n\r\nconst hoverRegex = /\\S+:hover/g;\r\n\r\nconst addPredictiveHoverRules = () => {\r\n\r\n\tconst sheets = document.styleSheets;\r\n\r\n\tfor(let i = 0, il = sheets.length; i < il; i++){\r\n\t\tconst sheet = sheets[i],\r\n\t\t\trules = sheet.cssRules,\r\n\t\t\trulesToAdd = [];\r\n\r\n\t\tfor(let j = 0, jl = rules.length; j < jl; j++){\r\n\t\t\tconst rule = rules[j],\r\n\t\t\t\tselectorText = rule.selectorText;\r\n\r\n\t\t\tif(selectorText.indexOf(':hover') > -1){\r\n\t\t\t\trulesToAdd.push({\r\n\t\t\t\t\tselector: selectorText.replace(hoverRegex, '.' + _constants__WEBPACK_IMPORTED_MODULE_0__[\"hoverClass\"]),\r\n\t\t\t\t\tcss: rule.style.cssText\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trulesToAdd.map(r => addCSSRule(sheet, r.selector, r.css, 1));\r\n\t}\r\n}\r\n\r\nconst addHoverClass = target => {\r\n    target.classList.add(_constants__WEBPACK_IMPORTED_MODULE_0__[\"hoverClass\"]);\r\n}\r\n\r\nconst removeHoverClass = target => {\r\n    target.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_0__[\"hoverClass\"]);\r\n}\r\n\r\nconst addCSSRule = (sheet, selector, rules, index) => {\r\n\tif(\"insertRule\" in sheet) {\r\n\t\tsheet.insertRule(selector + \"{\" + rules + \"}\", index);\r\n\t}\r\n\telse if(\"addRule\" in sheet) {\r\n\t\tsheet.addRule(selector, rules, index);\r\n\t}\r\n}\n\n//# sourceURL=webpack:///./styles.js?");

/***/ }),

/***/ 0:
/*!*******************************!*\
  !*** child_process (ignored) ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///child_process_(ignored)?");

/***/ })

/******/ });